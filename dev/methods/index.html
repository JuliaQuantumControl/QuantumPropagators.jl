<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Propagation Methods · QuantumPropagators.jl</title><meta name="title" content="Propagation Methods · QuantumPropagators.jl"/><meta property="og:title" content="Propagation Methods · QuantumPropagators.jl"/><meta property="twitter:title" content="Propagation Methods · QuantumPropagators.jl"/><meta name="description" content="Documentation for QuantumPropagators.jl."/><meta property="og:description" content="Documentation for QuantumPropagators.jl."/><meta property="twitter:description" content="Documentation for QuantumPropagators.jl."/><meta property="og:url" content="https://juliaquantumcontrol.github.io/QuantumPropagators.jl/methods/"/><meta property="twitter:url" content="https://juliaquantumcontrol.github.io/QuantumPropagators.jl/methods/"/><link rel="canonical" href="https://juliaquantumcontrol.github.io/QuantumPropagators.jl/methods/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/citations.css" rel="stylesheet" type="text/css"/><link href="https://juliaquantumcontrol.github.io/QuantumControl.jl/dev/assets/topbar/topbar.css" rel="stylesheet" type="text/css"/><script src="https://juliaquantumcontrol.github.io/QuantumControl.jl/dev/assets/topbar/topbar.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">QuantumPropagators.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../overview/">Overview</a></li><li><a class="tocitem" href="../generators/">Dynamical Generators</a></li><li class="is-active"><a class="tocitem" href>Propagation Methods</a><ul class="internal"><li><a class="tocitem" href="#method_expprop"><span><code>ExpProp</code></span></a></li><li><a class="tocitem" href="#method_cheby"><span><code>Cheby</code></span></a></li><li><a class="tocitem" href="#method_newton"><span><code>Newton</code></span></a></li><li><a class="tocitem" href="#method_ode"><span><code>OrdinaryDiffEq</code></span></a></li></ul></li><li><a class="tocitem" href="../storage/">Expectation Values</a></li><li><a class="tocitem" href="../howto/">Howtos</a></li><li><a class="tocitem" href="../benchmarks/">Benchmarks</a></li><li><a class="tocitem" href="../api/quantumpropagators/">API</a></li><li><a class="tocitem" href="../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Propagation Methods</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Propagation Methods</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaQuantumControl/QuantumPropagators.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaQuantumControl/QuantumPropagators.jl/blob/master/docs/src/methods.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Propagation-Methods"><a class="docs-heading-anchor" href="#Propagation-Methods">Propagation Methods</a><a id="Propagation-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Propagation-Methods" title="Permalink"></a></h1><p class="math-container">\[\gdef\op#1{\hat{#1}}
\gdef\ket#1{\vert{#1}\rangle}
\gdef\Liouvillian{\mathcal{L}}
\gdef\Re{\operatorname{Re}}
\gdef\Im{\operatorname{Im}}\]</p><p>As discussed in the <a href="../overview/#overview_approaches">Overview</a>, time propagation can be implemented in one of two ways:</p><ol><li><p>By <em>analytically</em> solving the equation of motion and numerically evaluating the application time evolution operator.</p><p>We consider this especially in the piecewise-constant case (<code>pwc=true</code> in <a href="../api/quantumpropagators/#QuantumPropagators.propagate"><code>propagate</code></a>/<a href="../api/quantumpropagators/#QuantumPropagators.init_prop"><code>init_prop</code></a>), which is required for the traditional optimization methods <a href="https://juliaquantumcontrol.github.io/GRAPE.jl/stable/">GRAPE</a> and <a href="https://juliaquantumcontrol.github.io/Krotov.jl/stable/">Krotov</a>. In these propagations, the time-dependent generator <span>$\op{H}(t)$</span> is <a href="../api/quantumpropagators/#QuantumPropagators.Controls.evaluate">evaluated</a> to a constant operator <span>$\op{H}$</span> on each interval of the time grid. The analytical solution to the Schrödinger or Liouville equation is well known, and propagation step simply has to evaluate the application of the time evolution operator <span>$\op{U} = \exp[-i \op{H} dt]$</span> to the state <span>$|Ψ⟩$</span>. The following methods are built in to <code>QuantumPropagators</code>:</p><ul><li><a href="#method_expprop"><code>ExpProp</code></a> – constructs <span>$\op{U}$</span> explicitly and then applies it to <span>$|Ψ⟩$</span></li><li><a href="#method_cheby"><code>Cheby</code></a> — expansion of <span>$\op{U} |Ψ⟩$</span> into Chebychev polynomials, valid if <span>$\op{H}$</span> has real eigenvalues</li><li><a href="#method_newton"><code>Newton</code></a> – expansion of <span>$\op{U} |Ψ⟩$</span> into Newton polynomials, valid if <span>$\op{H}$</span> has complex eigenvalues (non-Hermitian Hamiltonian, Liouvillian)</li></ul><p>The <code>ExpProp</code> method is generally not numerically efficient, but works well for small system for for debugging. The two &quot;core&quot; methods based on a polynomials series expansions are more suitable for bigger systems and provide both efficiency and high precision (in general, the is truncated as soon as some desired precision is reached, which is machine precision by default).</p><p>Note that this high precision is <em>within the piecewise-constant approximation</em>. The discretization itself may introduce a non-negligible error compared to the time-continuous dynamics. There is tradeoff: A smaller <code>dt</code> decreases the discretization error, but the polynomial expansions are more effective with larger time steps.</p></li><li><p>By solving the equation of motion explicitly with an ODE solver.</p><p>We support the use of any of the ODE solvers in <a href="https://docs.sciml.ai/OrdinaryDiffEq/stable/">OrdinaryDiffEq.jl</a>:</p><ul><li><a href="#method_ode"><code>OrdinaryDiffEq</code></a> – solve the equation of motion as an ODE</li></ul><p>The main benefit of using an ODE solver is that the generator <span>$\op{H}(t)$</span> can be treated as time-continuous, and thus avoid the time discretization error. While this is not compatible with traditional optimal control method like <a href="https://juliaquantumcontrol.github.io/GRAPE.jl/stable/">GRAPE</a> and <a href="https://juliaquantumcontrol.github.io/Krotov.jl/stable/">Krotov</a>, it is suitable for control methods for tuning analytical control parameters [<a href="../references/#LucarelliPRA2018">6</a>–<a href="../references/#SorensenPRA2018">8</a>].</p><p>The <code>method=OrdinaryDiffEq</code> is also available in a piecewise-constant mode by setting <code>pwc=true</code>, for comparison with <code>method=Cheby</code> and <code>method=Newton</code>.</p></li></ol><h2 id="method_expprop"><a class="docs-heading-anchor" href="#method_expprop"><code>ExpProp</code></a><a id="method_expprop-1"></a><a class="docs-heading-anchor-permalink" href="#method_expprop" title="Permalink"></a></h2><p>The method should be loaded with</p><pre><code class="nohighlight hljs">using QuantumPropagators: ExpProp</code></pre><p>and the passed as <code>method=ExpProp</code> to <a href="../api/quantumpropagators/#QuantumPropagators.propagate"><code>propagate</code></a> or <a href="../api/quantumpropagators/#QuantumPropagators.init_prop"><code>init_prop</code></a>:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumPropagators.init_prop-Tuple{Any, Any, Any, Val{:ExpProp}}" href="#QuantumPropagators.init_prop-Tuple{Any, Any, Any, Val{:ExpProp}}"><code>QuantumPropagators.init_prop</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">using QuantumPropagators: ExpProp

exp_propagator = init_prop(
    state,
    generator,
    tlist;
    method=ExpProp,
    inplace=true,
    backward=false,
    verbose=false,
    parameters=nothing,
    func=(H_dt -&gt; exp(-1im * H_dt))
    convert_state=_exp_prop_convert_state(state),
    convert_operator=_exp_prop_convert_operator(generator),
    _...
)</code></pre><p>initializes an <a href="../api/quantumpropagators/#QuantumPropagators.ExpPropagator"><code>ExpPropagator</code></a>.</p><p><strong>Method-specific keyword arguments</strong></p><ul><li><code>func</code>: The function to evaluate. The argument <code>H_dt</code> is obtained by constructing an operator <code>H</code> from <code>generator</code> via the <a href="../api/quantumpropagators/#QuantumPropagators.Controls.evaluate"><code>evaluate</code></a> function and the multiplied with the time step <code>dt</code> for the current time interval. The propagation then simply multiplies the return value of <code>func</code> with the current state</li><li><code>convert_state</code>:  Type to which to temporarily convert states before multiplying the return value of <code>func</code>.</li><li><code>convert_operator</code>: Type to which to convert the operator <code>H</code> before multiplying it with <code>dt</code> and plugging the result into <code>func</code></li></ul><p>The <code>convert_state</code> and <code>convert_operator</code> parameters are useful for when the <code>generator</code> and or <code>state</code> are unusual data structures for which the relevant methods to calculate <code>func</code> are not defined. Often, it is easier to temporarily convert them to standard complex matrices and vectors than to implement the missing methods.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumPropagators.jl/blob/9b2ffc5747168fdd0a94e19d3fb92b0a49c6de6c/src/exp_propagator.jl#L40-L79">source</a></section></article><p><strong>Advantages</strong></p><ul><li>Simple: no knobs to turn</li><li>&quot;Exact&quot; to machine precision (within the piecewise constant approximation)</li><li>Does not require any special properties or knowledge of the dynamical generator</li><li>Efficient for small systems</li></ul><p><strong>Disadvantages</strong></p><ul><li>Bad numerical scaling with the Hilbert space dimension</li><li>Method for <code>exp(-1im * H * dt)</code> must be defined (or <code>H</code> must be convertible to a type that can be exponentiated)</li></ul><p><strong>When to use</strong></p><ul><li>Small Hilbert space dimension (&lt;10)</li><li>Comparing against another propagator</li></ul><h2 id="method_cheby"><a class="docs-heading-anchor" href="#method_cheby"><code>Cheby</code></a><a id="method_cheby-1"></a><a class="docs-heading-anchor-permalink" href="#method_cheby" title="Permalink"></a></h2><p>The method should be loaded with</p><pre><code class="nohighlight hljs">using QuantumPropagators: Cheby</code></pre><p>and then passed as <code>method=Cheby</code> to <a href="../api/quantumpropagators/#QuantumPropagators.propagate"><code>propagate</code></a> or <a href="../api/quantumpropagators/#QuantumPropagators.init_prop"><code>init_prop</code></a>:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumPropagators.init_prop-Tuple{Any, Any, Any, Val{:Cheby}}" href="#QuantumPropagators.init_prop-Tuple{Any, Any, Any, Val{:Cheby}}"><code>QuantumPropagators.init_prop</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">using QuantumPropagators: Cheby

cheby_propagator = init_prop(
    state,
    generator,
    tlist;
    method=Cheby,
    inplace=true,
    backward=false,
    verbose=false,
    parameters=nothing,
    control_ranges=nothing,
    specrange_method=:auto,
    specrange_buffer=0.01,
    cheby_coeffs_limit=1e-12,
    check_normalization=false,
    specrange_kwargs...
)</code></pre><p>initializes a <a href="../api/quantumpropagators/#QuantumPropagators.ChebyPropagator"><code>ChebyPropagator</code></a>.</p><p><strong>Method-specific keyword arguments</strong></p><ul><li><code>control_ranges</code>: a dict the maps the controls in <code>generator</code> (see <a href="../api/quantumpropagators/#QuantumPropagators.Controls.get_controls"><code>get_controls</code></a>) to a tuple of min/max values. The Chebychev coefficients will be calculated based on a spectral envelope that assumes that each control can take arbitrary values within the min/max range. If not given, the ranges are determined automatically. Specifying manual control ranges can be useful when the the control amplitudes (<code>parameters</code>) may change during the propagation, e.g. in a sequential-update control scheme.</li><li><code>specrange_method</code>: Method to pass to the <a href="../api/quantumpropagators/#QuantumPropagators.SpectralRange.specrange"><code>specrange</code></a> function</li><li><code>specrange_buffer</code>: An additional factor by which to enlarge the estimated  spectral range returned by <a href="../api/quantumpropagators/#QuantumPropagators.SpectralRange.specrange"><code>specrange</code></a>, in order to ensure that Chebychev coefficients are based on an overestimation of the spectral range.</li><li><code>cheby_coeffs_limit</code>: The maximum magnitude of Chebychev coefficients that should be treated as non-zero</li><li><code>check_normalization</code>: Check whether the Hamiltonian has been properly normalized, i.e., that the spectral range of <code>generator</code> has not been underestimated. This slowes down the propagation, but is advisable for novel <code>generators</code>.</li><li><code>uniform_dt_tolerance=1e-12</code>: How much the intervals of <code>tlist</code> are allowed to vary while still being considered constant.</li><li><code>specrange_kwargs</code>: All further keyword arguments are passed to the <a href="../api/quantumpropagators/#QuantumPropagators.SpectralRange.specrange"><code>specrange</code></a> function. Most notably, with the default <code>specrange_method=:auto</code> (or <code>specrange_method=:manual</code>), passing <code>E_min</code> and <code>E_max</code> allows to manually specify the spectral range of <code>generator</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumPropagators.jl/blob/9b2ffc5747168fdd0a94e19d3fb92b0a49c6de6c/src/cheby_propagator.jl#L32-L85">source</a></section></article><p>The time evolution operator of the piecewise-constant Schrödinger equation <span>$|Ψ(t)⟩ = e^{-i Ĥ dt} |Ψ(0)⟩$</span> is evaluated by an expansion into Chebychev polynomials [<a href="../references/#Tal-EzerJCP1984">1</a>, <a href="../references/#KosloffJCP1988">2</a>]. This requires <span>$Ĥ$</span> to be Hermitian (have real eigenvalues) and to have a known spectral range, so that it can be normalized to the domain <span>$[-1, 1]$</span> on which the Chebychev polynomials are defined.</p><p>See [<a href="../references/#GoerzPhd2015">9</a>, Chapter 3.2.1] for a detailed description of the method.</p><p><strong>Advantages</strong></p><ul><li>Very efficient for high precision and moderately large time steps</li></ul><p><strong>Disadvantages</strong></p><ul><li>Only valid for Hermitian operators</li><li>Must be able to estimate the spectral envelope</li></ul><p><strong>When to use</strong></p><ul><li>Closed quantum systems with piecewise constant dynamics</li></ul><h2 id="method_newton"><a class="docs-heading-anchor" href="#method_newton"><code>Newton</code></a><a id="method_newton-1"></a><a class="docs-heading-anchor-permalink" href="#method_newton" title="Permalink"></a></h2><p>The method should be loaded with</p><pre><code class="nohighlight hljs">using QuantumPropagators: Newton</code></pre><p>and then passed as <code>method=Newton</code> to <a href="../api/quantumpropagators/#QuantumPropagators.propagate"><code>propagate</code></a> or <a href="../api/quantumpropagators/#QuantumPropagators.init_prop"><code>init_prop</code></a>:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumPropagators.init_prop-Tuple{Any, Any, Any, Val{:Newton}}" href="#QuantumPropagators.init_prop-Tuple{Any, Any, Any, Val{:Newton}}"><code>QuantumPropagators.init_prop</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">using QuantumPropagators: Newton

newton_propagator = init_prop(
    state,
    generator,
    tlist;
    method=Newton,
    inplace=true,
    backward=false,
    verbose=false,
    parameters=nothing,
    m_max=10,
    func=(z -&gt; exp(-1im * z)),
    norm_min=1e-14,
    relerr=1e-12,
    max_restarts=50,
    _...
)</code></pre><p>initializes a <a href="../api/quantumpropagators/#QuantumPropagators.NewtonPropagator"><code>NewtonPropagator</code></a>.</p><p><strong>Method-specific keyword arguments</strong></p><ul><li><code>m_max</code>: maximum Krylov dimension, cf. <a href="../api/quantumpropagators/#QuantumPropagators.Newton.NewtonWrk"><code>NewtonWrk</code></a></li><li><code>func</code>, <code>norm_min</code>, <code>relerr</code>, <code>max_restarts</code>: parameter to pass to <a href="../api/quantumpropagators/#QuantumPropagators.Newton.newton!"><code>newton!</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumPropagators.jl/blob/9b2ffc5747168fdd0a94e19d3fb92b0a49c6de6c/src/newton_propagator.jl#L30-L60">source</a></section></article><p>The time evolution operator of the piecewise-constant Schrödinger equation <span>$|Ψ(t)⟩ = e^{-i Ĥ dt} |Ψ(0)⟩$</span> is evaluated by an expansion into Newton polynomials [<a href="../references/#BermanJPA1992">3</a>, <a href="../references/#AshkenaziJCP1995">5</a>, <a href="../references/#Tal-EzerSJSC2007">10</a>]. Unlike for Chebychev polynomials, this expansion does not require <span>$Ĥ$</span> to be Hermitian or to have a known spectral radius. This makes the Newton propagation applicable to open quantum systems, where <span>$Ĥ$</span> is replaced by a Liouvillian to calculate the time evolution of the density matrix.</p><p>See [<a href="../references/#GoerzPhd2015">9</a>, Chapter 3.2.2] for a detailed description of the method.</p><p><strong>Advantages</strong></p><ul><li>Reasonably efficient for high precision and moderately large time steps</li><li>Spectral radius does not need to be known</li></ul><p><strong>Disadvantages</strong></p><ul><li>Need to choose <code>m_max</code> and <code>max_restarts</code> well for good performance.</li></ul><p><strong>When to use</strong></p><ul><li>Open quantum systems with piecewise constant dynamics</li></ul><h2 id="method_ode"><a class="docs-heading-anchor" href="#method_ode"><code>OrdinaryDiffEq</code></a><a id="method_ode-1"></a><a class="docs-heading-anchor-permalink" href="#method_ode" title="Permalink"></a></h2><p>The method requires that the <a href="https://docs.sciml.ai/OrdinaryDiffEq/stable/">OrdinaryDiffEq</a> package is loaded</p><pre><code class="nohighlight hljs">using OrdinaryDiffEq</code></pre><p>Equivalently, the more general <a href="https://docs.sciml.ai/DiffEqDocs/stable/">DifferentialEquations.jl</a> package can be used.</p><pre><code class="nohighlight hljs">using DifferentialEquations</code></pre><p>There is no difference between these two options: <code>OrdinaryDiffEq</code> is just a smaller dependency, but <code>DifferentialEquations</code> may be preferred if the large DifferentialEquations framework is required for the project.</p><p>In any case, the loaded package to <a href="../api/quantumpropagators/#QuantumPropagators.propagate"><code>propagate</code></a> or <a href="../api/quantumpropagators/#QuantumPropagators.init_prop"><code>init_prop</code></a> via the <code>method</code> keyword argument:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumPropagators.init_prop-Tuple{Any, Any, Any, Val{:OrdinaryDiffEq}}" href="#QuantumPropagators.init_prop-Tuple{Any, Any, Any, Val{:OrdinaryDiffEq}}"><code>QuantumPropagators.init_prop</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">using OrdinaryDiffEq  # or: `using DifferentialEquations`

ode_propagator = init_prop(
    state,
    generator,
    tlist;
    method=OrdinaryDiffEq,  # or: `method=DifferentialEquations`
    inplace=true,
    backward=false,
    verbose=false,
    parameters=nothing,
    piecewise=false,
    pwc=false,
    alg=OrdinaryDiffEq.Tsit5(),
    solver_options...
)</code></pre><p>initializes a <a href="../api/quantumpropagators/#QuantumPropagators.AbstractPropagator">propagator</a> that uses an ODE solver from the <a href="https://github.com/SciML/OrdinaryDiffEq.jl">OrdinaryDiffEq.jl</a> package as a backend.</p><p>By default, the resulting propagator is for time-continuous controls that can be evaluated with <a href="../api/quantumpropagators/#QuantumPropagators.Controls.evaluate"><code>evaluate(control, t)</code></a> for any <code>t</code> in the range of <code>tlist[begin]</code> to <code>tlist[end]</code>. The controls may be parametrized, see <a href="../api/quantumpropagators/#QuantumPropagators.Controls.get_parameters"><code>get_parameters</code></a>. Any parameters will be available in the <code>parameters</code> attribute of the resulting <code>ode_propagator</code>, as a dictionary mapping controls to a vector of parameter values. Mutating <code>ode_propagator.parameters[control]</code> will be reflected in any subsequent call to <a href="../api/quantumpropagators/#QuantumPropagators.prop_step!"><code>prop_step!</code></a>.</p><p>If <code>pwc=true</code> (or, equivalently <code>piecewise=true</code>), all controls will be discretized with <a href="../api/quantumpropagators/#QuantumPropagators.Controls.discretize_on_midpoints"><code>discretize_on_midpoints</code></a> and the propagation will be for piecewise constant dynamics. The resulting <code>ode_propagator</code> will be an instance of <a href="../api/quantumpropagators/#QuantumPropagators.PWCPropagator"><code>PWCPropagator</code></a>, with the corresponding semantics. In particular, the <code>ode_propatator.parameters</code> will be a mapping of controls to discretized pulse values, <em>not</em> the analytical parameters obtained with <code>get_parameters(control)</code> as in the default case.</p><p>Internally, the <code>generator</code> will be wrapped with <a href="../api/quantumpropagators/#QuantumPropagators.ode_function"><code>QuantumPropagators.ode_function</code></a>. The resulting function <code>f</code> will be called internally as <code>f(ϕ, Ψ, vals_dict, t)</code> or <code>f(Ψ, vals_dict, t)</code> depending on the <code>inplace</code> keyword argument.</p><p><strong>Method-specific keyword arguments</strong></p><ul><li><code>pwc</code>: Whether to propagate for piecewise-constant controls or, with the default <code>pwc=false</code>, for time-continuous controls.</li><li><code>piecewise</code>: Currently equivalent to <code>pwc</code>, but future version may change  this to allow for other piecewise (e.g., piecewise-linear) controls.</li><li><code>parameters</code>: If given, a mapping of controls to parameter values (<code>pwc=false</code>) or pulse values on the intervals of the time grid (<code>pwc=true</code>). By default, the <code>parameters</code> are determined automatically using <a href="../api/quantumpropagators/#QuantumPropagators.Controls.get_parameters"><code>get_parameters</code></a>, respectively <a href="../api/quantumpropagators/#QuantumPropagators.Controls.discretize_on_midpoints"><code>discretize_on_midpoints</code></a> if <code>pwc=true</code>. If they are given manually, they must follow the exact same semantics. In particular, for <code>pwc=false</code>, any parameters must alias the parameters in the controls, such that mutating <code>parameters</code> is automatically reflected in <a href="../api/quantumpropagators/#QuantumPropagators.Controls.evaluate"><code>evaluate</code></a>. The <code>parameters</code> will be available as an attribute of the <code>ode_propagator</code>.</li><li><code>alg</code>: The algorithm to use for the ODE Solver, see the list of solvers in the <a href="https://docs.sciml.ai/DiffEqDocs/stable/solvers/ode_solve/">DifferentialEquations manual</a>. The default <code>Tsit5()</code> method is the recommended choice for non-stiff problems.</li><li><code>solver_options</code>: All other keyword arguments are passed to the ODE solver, see the list of <a href="https://docs.sciml.ai/DiffEqDocs/stable/basics/common_solver_opts/#solver_options">Solve Keyword Arguments</a> in the DifferentialEquations manual. Note that the options for &quot;Default Algorithm Hinting&quot; do not apply, since <code>alg</code> must be specified manually. Also, the &quot;Output Control&quot; is managed by the <code>ode_propagator</code>, so these options should not be used.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumPropagators.jl/blob/9b2ffc5747168fdd0a94e19d3fb92b0a49c6de6c/ext/QuantumPropagatorsODEExt.jl#L18-L89">source</a></section></article><p><strong>Advantages</strong></p><ul><li>Suitable for time-continuous dynamics</li><li>The full power of the DifferentialEquations.jl ecosystem</li><li>Efficient for moderate precisions</li></ul><p><strong>Disadvantages</strong></p><ul><li>Less efficient for piecewise-constant dynamics, and thus less suitable of PWC control methods</li></ul><p><strong>When to use</strong></p><ul><li>Time-continuous dynamics</li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../generators/">« Dynamical Generators</a><a class="docs-footer-nextpage" href="../storage/">Expectation Values »</a><div class="flexbox-break"></div><p class="footer-message"><a href="https://github.com/JuliaQuantumControl/QuantumPropagators.jl">QuantumPropagators.jl</a> v0.7.3+dev docs powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.3.0 on <span class="colophon-date" title="Monday 25 March 2024 21:30">Monday 25 March 2024</span>. Using Julia version 1.10.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
