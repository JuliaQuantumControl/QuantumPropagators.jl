<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Overview · QuantumPropagators.jl</title><meta name="title" content="Overview · QuantumPropagators.jl"/><meta property="og:title" content="Overview · QuantumPropagators.jl"/><meta property="twitter:title" content="Overview · QuantumPropagators.jl"/><meta name="description" content="Documentation for QuantumPropagators.jl."/><meta property="og:description" content="Documentation for QuantumPropagators.jl."/><meta property="twitter:description" content="Documentation for QuantumPropagators.jl."/><meta property="og:url" content="https://juliaquantumcontrol.github.io/QuantumPropagators.jl/overview/"/><meta property="twitter:url" content="https://juliaquantumcontrol.github.io/QuantumPropagators.jl/overview/"/><link rel="canonical" href="https://juliaquantumcontrol.github.io/QuantumPropagators.jl/overview/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/citations.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">QuantumPropagators.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Overview</a><ul class="internal"><li><a class="tocitem" href="#Getting-started"><span>Getting started</span></a></li><li><a class="tocitem" href="#Propagation-methods"><span>Propagation methods</span></a></li><li><a class="tocitem" href="#Dynamic-generators"><span>Dynamic generators</span></a></li><li><a class="tocitem" href="#The-Propagator-interface"><span>The Propagator interface</span></a></li><li><a class="tocitem" href="#Backward-propagation"><span>Backward propagation</span></a></li><li><a class="tocitem" href="#Connection-to-DifferentialEquations.jl"><span>Connection to DifferentialEquations.jl</span></a></li></ul></li><li><a class="tocitem" href="../generators/">Dynamical Generators</a></li><li><a class="tocitem" href="../methods/">Propagation Methods</a></li><li><a class="tocitem" href="../storage/">Expectation Values</a></li><li><a class="tocitem" href="../examples/">Examples</a></li><li><a class="tocitem" href="../howto/">Howtos</a></li><li><a class="tocitem" href="../benchmarks/">Benchmarks</a></li><li><a class="tocitem" href="../api/quantumpropagators/">API</a></li><li><a class="tocitem" href="../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Overview</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Overview</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaQuantumControl/QuantumPropagators.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaQuantumControl/QuantumPropagators.jl/blob/master/docs/src/overview.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Overview"><a class="docs-heading-anchor" href="#Overview">Overview</a><a id="Overview-1"></a><a class="docs-heading-anchor-permalink" href="#Overview" title="Permalink"></a></h1><p class="math-container">\[\gdef\op#1{\hat{#1}}
\gdef\ket#1{\vert{#1}\rangle}
\gdef\Liouvillian{\mathcal{L}}
\gdef\Re{\operatorname{Re}}
\gdef\Im{\operatorname{Im}}\]</p><p>The <code>QuantumPropagators</code> packages provides solvers for the dynamic equations of quantum mechanics, most importantly the Schrödinger and Liouville equations.</p><h2 id="Getting-started"><a class="docs-heading-anchor" href="#Getting-started">Getting started</a><a id="Getting-started-1"></a><a class="docs-heading-anchor-permalink" href="#Getting-started" title="Permalink"></a></h2><p>As a simple &quot;Hello World&quot; example, we use the <a href="../api/quantumpropagators/#QuantumPropagators.propagate"><code>propagate</code></a> function to simulate a <a href="https://gist.github.com/goerz//720669c9fffe2a8a7f4263b74d625140">π/2 Rabi flip in a two level system</a>:</p><p>In a two-level system with ground state <span>$\ket{0}$</span> and excited state <span>$\ket{1}$</span>, a constant driving field between the two levels with a pulse area of π/2 results in a population inversion, transforming the initial state <span>$\ket{0}$</span> into <span>$-i \ket{1}$</span>,</p><pre><code class="language-julia hljs">using QuantumPropagators: propagate

Ψ₀ = ComplexF64[1, 0]  #  = |0⟩
H = ComplexF64[0 1; 1 0]
tlist = collect(range(0, π/2, length=101))

Ψ = propagate(Ψ₀, H, tlist)

print(&quot;Ψ = $(round.(Ψ; digits=3))\n&quot;)

# output

Ψ = ComplexF64[0.0 + 0.0im, 0.0 - 1.0im]</code></pre><p>Instead of just returning the final state, we can use <code>storage=true</code> to return an array with all the states at every point in the time grid (<code>tlist</code>). This allows us to plot the Rabi oscillation over time:</p><pre><code class="language-julia hljs">using Plots
states = propagate(Ψ₀, H, tlist; storage=true)
plot(tlist./π, abs.(states&#39;).^2; label=[&quot;ground&quot; &quot;excited&quot;],
     xlabel=&quot;pulse area / π&quot;, ylabel=&quot;population&quot;, legend=:right)</code></pre><img src="eeddc065.svg" alt="Example block output"/><p>The <code>storage</code> parameter provides a powerful way to obtain arbitrary dynamic quantities from the propagation:</p><ul><li>If given as <code>true</code>, return a storage array with the propagated states at each point in time instead of just the final state.</li><li>If given a pre-allocated storage array, fill it with the propagated states at each point in time, and return the final state.</li><li>If given in combination with <code>observables</code>, put arbitrary &quot;observable&quot; data derived from the propagated states in the storage array.</li></ul><p>See the discussion of <a href="../storage/#Expectation-Values">Expectation Values</a> for details.</p><h2 id="Propagation-methods"><a class="docs-heading-anchor" href="#Propagation-methods">Propagation methods</a><a id="Propagation-methods-1"></a><a class="docs-heading-anchor-permalink" href="#Propagation-methods" title="Permalink"></a></h2><p>When <a href="../api/quantumpropagators/#QuantumPropagators.propagate"><code>propagate</code></a> is called without keyword arguments (or with <code>method=:auto</code>), an appropriate propagation method is determined automatically based on the properties of the state and generator. In the above example of a two-level system, this is <code>method=:expprop</code> which solves the Schrödinger equation by exponentiating generator to construct the time evolution operator <span>$\op{U} = \exp[-i \op{H} dt]$</span> in each time step explicitly, and applying it to the state. This is the most appropriate method for very small systems, especially a two-level system.</p><p>A specific propagation method can be forced by passing the <code>method</code> keyword argument to <a href="../api/quantumpropagators/#QuantumPropagators.propagate"><code>propagate</code></a>. The following methods are built-in:</p><ul><li><code>method=:expprop</code>: Solve the piecewise-constant Schrödinger or Liouville equation by explicity matrix exponentiation</li><li><code>method=:cheby</code>: Solve the piecewise-constant Schrödinger equation (Hermitian operators)</li><li><code>method=:newton</code>: Solve the piecewise constant Liouville equation or non-Hermitian Schrödinger equation</li></ul><p>The Schrödinger equation is (ħ = 1)</p><p class="math-container">\[i \frac{\partial}{\partial t} \ket{\Psi(t)} = \op{H}(t) \ket{\Psi(t)}\,.\]</p><p>For open quantum systems, we assume the Liouville equation</p><p class="math-container">\[i \frac{\partial}{\partial t} \hat{\rho}(t) = \Liouvillian(t) \hat{\rho}(t)\,,\]</p><p>which differs from most textbooks by a factor of <span>$i$</span>, but has the benefit that it is structurally identical to the Schrödinger equation, so that the propagation methods do not actually need to know whether they are propagating a Hilbert space vector or a (vectorized) density matrix. See <a href="https://juliaquantumcontrol.github.io/QuantumControl.jl/stable/api/quantum_control_base/#QuantumControlBase.liouvillian"><code>QuantumControl.liouvillian</code></a> with <code>convention=:LvN</code> for how to construct an appropriate <span>$\Liouvillian$</span>.</p><h2 id="Dynamic-generators"><a class="docs-heading-anchor" href="#Dynamic-generators">Dynamic generators</a><a id="Dynamic-generators-1"></a><a class="docs-heading-anchor-permalink" href="#Dynamic-generators" title="Permalink"></a></h2><p>In the above example, the &quot;generator&quot; <code>H</code> that is the second argument to <a href="../api/quantumpropagators/#QuantumPropagators.propagate"><code>propagate</code></a> was a simple static operator. In general, we will want time-dependent Hamiltonians or Liouvillians. The standard way to initialize a time-dependent Hamiltonian is via the <a href="../api/quantumpropagators/#QuantumPropagators.Generators.hamiltonian"><code>hamiltonian</code></a> function, e.g., as  <code>hamiltonian(Ĥ₀, (Ĥ₁, ϵ₁), (Ĥ₂, ϵ₂))</code>. The <code>Ĥ₀</code>, <code>Ĥ₁</code>, and <code>Ĥ₂</code> are static operators, and <code>ϵ₁</code> and <code>ϵ₂</code> are control fields, typically functions of time <code>t</code>. For piecewise-constant propagators, <code>ϵ₁</code> nad <code>ϵ₂</code> may also be an array of amplitude values appropriate to the time grid <code>tlist</code>. The tuple-syntax for the time-dependent terms is inspired by <a href="https://qutip.org/docs/latest/guide/dynamics/dynamics-time.html">QuTiP</a>.</p><p>Generally, the <code>generator</code>, or the operators/controls inside the tuples can be a arbitrary objects, as long as some relevant methods are implemented for these objects, see the full section on <a href="../generators/#Dynamical-Generators">Dynamical Generators</a>.</p><p>Open quantum systems are handled identically to closed quantum system, except that Hamiltonian operator are replaced by Liouvillian super-operators. For any system of non-trivial Hilbert space dimension, all (super-)operators should be sparse matrices.</p><h2 id="The-Propagator-interface"><a class="docs-heading-anchor" href="#The-Propagator-interface">The Propagator interface</a><a id="The-Propagator-interface-1"></a><a class="docs-heading-anchor-permalink" href="#The-Propagator-interface" title="Permalink"></a></h2><p>As a lower-level interface than <a href="../api/quantumpropagators/#QuantumPropagators.propagate"><code>propagate</code></a>, the <code>QuantumPropagators</code> package defines an interface for &quot;propagator&quot; objects. These are initialized via <a href="../api/quantumpropagators/#QuantumPropagators.init_prop"><code>init_prop</code></a> as, e.g.,</p><pre><code class="nohighlight hljs">using QuantumPropagators: init_prop

propagator = init_prop(Ψ₀, H, tlist)</code></pre><p>The <code>propagator</code> is a propagation-method-dependent object with the interface described by <a href="../api/quantumpropagators/#QuantumPropagators.AbstractPropagator"><code>AbstractPropagator</code></a> and <a href="../api/quantumpropagators/#QuantumPropagators.Interfaces.check_propagator"><code>QuantumPropagators.Interfaces.check_propagator</code></a>.</p><p>The  <a href="../api/quantumpropagators/#QuantumPropagators.prop_step!"><code>prop_step!</code></a> function can then be used to advance the <code>propagator</code>:</p><pre><code class="language-julia hljs">using QuantumPropagators: prop_step!

Ψ = prop_step!(propagator)  # single step

while !isnothing(prop_step!(propagator)); end  # go to end
Ψ = propagator.state

print(&quot;Ψ = $(round.(Ψ; digits=3)))\n&quot;)
print(&quot;t = $(round(propagator.t / π; digits=3))π\n&quot;)

# output

Ψ = ComplexF64[0.0 + 0.0im, 0.0 - 1.0im])
t = 0.5π</code></pre><h2 id="Backward-propagation"><a class="docs-heading-anchor" href="#Backward-propagation">Backward propagation</a><a id="Backward-propagation-1"></a><a class="docs-heading-anchor-permalink" href="#Backward-propagation" title="Permalink"></a></h2><p>When <a href="../api/quantumpropagators/#QuantumPropagators.propagate"><code>propagate</code></a> or <a href="../api/quantumpropagators/#QuantumPropagators.init_prop"><code>init_prop</code></a> are called with <code>backward=true</code>, the propagation is initialized to run backward. The initial state is then defined at <code>propagator.t == tlist[end]</code> and each <a href="../api/quantumpropagators/#QuantumPropagators.prop_step!"><code>prop_step!</code></a> moves to the previous point in <code>tlist</code>. The equation of motion is the Schrödinger or Liouville equation with a negative <span>$dt$</span>. For a Hermitian <code>generator</code>, doing a forward propagation followed by a backward propagation will recover the initial state. For a non-Hermitian <code>generator</code>, this no longer holds. Note that in optimal control methods such as GRAPE or Krotov&#39;s method, obtaining gradients involves a &quot;backward propagation with the adjoint generator&quot; (when the generator is non-Hermitian and adjoint/non-adjoint makes a difference). The <a href="../api/quantumpropagators/#QuantumPropagators.propagate"><code>propagate</code></a> routine with <code>backward=true</code> will not automatically take this adjoint of the <code>generator</code>; instead, the adjoint generator must be passed explicitly.</p><h2 id="Connection-to-DifferentialEquations.jl"><a class="docs-heading-anchor" href="#Connection-to-DifferentialEquations.jl">Connection to DifferentialEquations.jl</a><a id="Connection-to-DifferentialEquations.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Connection-to-DifferentialEquations.jl" title="Permalink"></a></h2><p>The <code>QuantumPropagators</code> API is structured similarly to the <a href="https://github.com/SciML/DifferentialEquations.jl">DifferentialEquations.jl</a></p><ul><li><p>The <a href="../api/quantumpropagators/#QuantumPropagators.propagate"><code>propagate</code></a> function is similar to <a href="https://diffeq.sciml.ai/stable/basics/overview/#Solving-the-Problems"><code>DifferentialEquations.solve</code></a></p></li><li><p>The <a href="../api/quantumpropagators/#QuantumPropagators.init_prop"><code>init_prop</code></a> function is similar to <a href="https://diffeq.sciml.ai/stable/basics/integrator/#Initialization-and-Stepping"><code>DifferentialEquations.init</code></a></p></li><li><p>The <a href="../api/quantumpropagators/#QuantumPropagators.reinit_prop!"><code>reinit_prop!</code></a> function is similar to <a href="https://diffeq.sciml.ai/stable/basics/integrator/#SciMLBase.reinit!"><code>DifferentialEquations.reinit!</code></a></p></li><li><p><a href="#The-Propagator-interface">The Propagator interface</a> is similar to DifferentialEquations&#39; <a href="https://diffeq.sciml.ai/stable/basics/integrator/">Integrator Interface</a></p></li><li><p><a href="../api/quantumpropagators/#QuantumPropagators.prop_step!"><code>prop_step!</code></a> corresponds to <a href="https://diffeq.sciml.ai/stable/basics/integrator/#SciMLBase.step!"><code>DifferentialEquations.step!</code></a></p></li><li><p><a href="../api/quantumpropagators/#QuantumPropagators.set_state!"><code>set_state!</code></a> corresponds to <a href="https://diffeq.sciml.ai/stable/basics/integrator/#SciMLBase.set_u!"><code>DifferentialEquations.set_u!</code></a></p></li><li><p><a href="../api/quantumpropagators/#QuantumPropagators.set_t!"><code>set_t!</code></a> corresponds to <a href="https://diffeq.sciml.ai/stable/basics/integrator/#SciMLBase.set_t!"><code>DifferentialEquations.set_t!</code></a></p></li></ul><p>Note that the equation of motion for <code>QuantumPropagators</code> is implicit in the propagation <code>method</code> (usually the Schrödinger/Liouville equation), so the initialization of a Propagator via the initial state and the &quot;generator&quot; is more specialized than DifferentialEquations&#39; <a href="https://diffeq.sciml.ai/stable/basics/problem/#Problem-Interface">Problem Interface</a>.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../generators/">Dynamical Generators »</a><div class="flexbox-break"></div><p class="footer-message"><a href="https://github.com/JuliaQuantumControl/QuantumPropagators.jl">QuantumPropagators.jl</a> v0.6.1+dev docs powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.1.2 on <span class="colophon-date" title="Friday 24 November 2023 22:07">Friday 24 November 2023</span>. Using Julia version 1.9.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
