<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Overview · QuantumPropagators.jl</title><meta name="title" content="Overview · QuantumPropagators.jl"/><meta property="og:title" content="Overview · QuantumPropagators.jl"/><meta property="twitter:title" content="Overview · QuantumPropagators.jl"/><meta name="description" content="Documentation for QuantumPropagators.jl."/><meta property="og:description" content="Documentation for QuantumPropagators.jl."/><meta property="twitter:description" content="Documentation for QuantumPropagators.jl."/><meta property="og:url" content="https://juliaquantumcontrol.github.io/QuantumPropagators.jl/overview/"/><meta property="twitter:url" content="https://juliaquantumcontrol.github.io/QuantumPropagators.jl/overview/"/><link rel="canonical" href="https://juliaquantumcontrol.github.io/QuantumPropagators.jl/overview/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/citations.css" rel="stylesheet" type="text/css"/><link href="https://juliaquantumcontrol.github.io/QuantumControl.jl/dev/assets/topbar/topbar.css" rel="stylesheet" type="text/css"/><script src="https://juliaquantumcontrol.github.io/QuantumControl.jl/dev/assets/topbar/topbar.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">QuantumPropagators.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Overview</a><ul class="internal"><li><a class="tocitem" href="#getting_started"><span>Getting started</span></a></li><li><a class="tocitem" href="#overview_approaches"><span>Approaches to time propagation</span></a></li><li><a class="tocitem" href="#overview_propagation"><span>Propagation methods</span></a></li><li><a class="tocitem" href="#overview_dynamical_generators"><span>Dynamical generators</span></a></li><li><a class="tocitem" href="#The-Propagator-interface"><span>The Propagator interface</span></a></li><li><a class="tocitem" href="#In-place-propagation"><span>In-place propagation</span></a></li><li><a class="tocitem" href="#Backward-propagation"><span>Backward propagation</span></a></li><li><a class="tocitem" href="#Parameterized-controls"><span>Parameterized controls</span></a></li><li><a class="tocitem" href="#Connection-to-DifferentialEquations.jl"><span>Connection to DifferentialEquations.jl</span></a></li></ul></li><li><a class="tocitem" href="../generators/">Dynamical Generators</a></li><li><a class="tocitem" href="../methods/">Propagation Methods</a></li><li><a class="tocitem" href="../storage/">Expectation Values</a></li><li><a class="tocitem" href="../howto/">How-to Guides</a></li><li><a class="tocitem" href="../benchmarks/">Benchmarks</a></li><li><a class="tocitem" href="../api/quantumpropagators/">API</a></li><li><a class="tocitem" href="../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Overview</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Overview</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaQuantumControl/QuantumPropagators.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaQuantumControl/QuantumPropagators.jl/blob/master/docs/src/overview.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Overview"><a class="docs-heading-anchor" href="#Overview">Overview</a><a id="Overview-1"></a><a class="docs-heading-anchor-permalink" href="#Overview" title="Permalink"></a></h1><p class="math-container">\[\gdef\op#1{\hat{#1}}
\gdef\Liouvillian{\mathcal{L}}
\gdef\Re{\operatorname{Re}}
\gdef\Im{\operatorname{Im}}\]</p><p>The <code>QuantumPropagators</code> packages provides solvers for the dynamic equations of quantum mechanics, most importantly the Schrödinger and Liouville equations. We refer to the numerical evaluation of a quantum state <span>$|Ψ(t + dt)⟩$</span>  from a state <span>$|Ψ(t)⟩$</span> under a given equation of motion as &quot;time propagation&quot;.</p><h2 id="getting_started"><a class="docs-heading-anchor" href="#getting_started">Getting started</a><a id="getting_started-1"></a><a class="docs-heading-anchor-permalink" href="#getting_started" title="Permalink"></a></h2><p>As a simple &quot;Hello World&quot; example, we use the <a href="../api/quantumpropagators/#QuantumPropagators.propagate"><code>propagate</code></a> function to simulate a <a href="https://gist.github.com/goerz//720669c9fffe2a8a7f4263b74d625140">π/2 Rabi flip in a two level system</a>:</p><p>In a two-level system with ground state <span>$|0⟩$</span> and excited state <span>$|1⟩$</span>, a constant driving field between the two levels with a pulse area of π/2 results in a population inversion, transforming the initial state <span>$|0⟩$</span> into <span>$-i |1⟩$</span>,</p><pre><code class="language-julia hljs">using QuantumPropagators: propagate, ExpProp

Ψ₀ = ComplexF64[1, 0]  #  = |0⟩
H = ComplexF64[0 1; 1 0]
tlist = collect(range(0, π/2, length=101))

Ψ = propagate(Ψ₀, H, tlist; method=ExpProp)

print(&quot;Ψ = $(round.(Ψ; digits=3))\n&quot;)

# output

Ψ = ComplexF64[0.0 + 0.0im, 0.0 - 1.0im]</code></pre><p>We&#39;ve used a simple <a href="../methods/#method_expprop">exponential propagator (<code>ExpProp</code>)</a> here, which directly calculates <code>U = exp(-1im * H * dt)</code> in every time step and applies it to the current state <code>Ψ</code>.</p><p>Instead of just returning the final state, we can use <code>storage=true</code> to return an array with all the states at every point in the time grid (<code>tlist</code>). This allows us to plot the Rabi oscillation over time:</p><pre><code class="language-julia hljs">using Plots
states = propagate(Ψ₀, H, tlist; method=ExpProp, storage=true)
fig = plot(tlist./π, abs.(states&#39;).^2; label=[&quot;ground&quot; &quot;excited&quot;],
           xlabel=&quot;pulse area / π&quot;, ylabel=&quot;population&quot;, legend=:right)</code></pre><img src="a244f1fc.svg" alt="Example block output"/><p>The <code>storage</code> parameter provides a powerful way to obtain arbitrary dynamic quantities from the propagation:</p><ul><li>If given as <code>true</code>, return a storage array with the propagated states at each point in time instead of just the final state.</li><li>If given a pre-allocated storage array, fill it with the propagated states at each point in time, and return the final state.</li><li>If given in combination with <code>observables</code>, put arbitrary &quot;observable&quot; data derived from the propagated states in the storage array.</li></ul><p>See the discussion of <a href="../storage/#Expectation-Values">Expectation Values</a> for details.</p><h2 id="overview_approaches"><a class="docs-heading-anchor" href="#overview_approaches">Approaches to time propagation</a><a id="overview_approaches-1"></a><a class="docs-heading-anchor-permalink" href="#overview_approaches" title="Permalink"></a></h2><p>We are primarily interested in the time propagation of a quantum state under the Schrödinger equation (ħ = 1)</p><p class="math-container">\[i \frac{\partial}{\partial t} |\Psi(t)⟩ = \op{H}(t) |\Psi(t)⟩\,,\]</p><p>which describes the dynamics of a closed quantum system. For open quantum systems, the equivalent equation is the Liouville equation, which we write as</p><p class="math-container">\[i \frac{\partial}{\partial t} \hat{\rho}(t) = \Liouvillian(t) \hat{\rho}(t)\,.\]</p><p>This form differs from most textbooks by a factor of <span>$i$</span>, but has the benefit that it is structurally identical to the Schrödinger equation, so that the propagation methods do not actually need to know whether they are propagating a Hilbert space vector or a (vectorized) density matrix. See <a href="../api/quantumpropagators/#QuantumPropagators.Generators.liouvillian"><code>liouvillian</code></a> with <code>convention=:LvN</code> for how to construct an appropriate <span>$\Liouvillian$</span>.</p><p>There are two fundamental approaches to solving the Schrödinger equation (or any equation of motion):</p><ol><li><p>We can analytically solve the Schrödinger equation and then numerically evaluate the solution. Mathematically, this is the application of the time evolution operator <span>$\op{H}$</span> as <span>$|Ψ(t+dt)⟩ = \op{U}(t) |Ψ(t)⟩$</span>. For a piecewise-constant <span>$\op{H}(t)$</span>where there is a time-independent <span>$\op{H}$</span> in the interval <span>$[t, t+dt]$</span>, the time evolution operator is well-known to be</p><p class="math-container">\[\op{U} = \exp[-i \op{H} dt]\,.\]</p><p>The propagated state <span>$\op{U} |Ψ(t)⟩$</span> would then be obtained, e.g., by expanding the exponentiation of the operator <span>$\op{H}$</span> into a polynomial series. This can be done to arbitrary precision by truncating the series at an appropriate point.</p></li><li><p>We can use a general ODE solver, e.g., using some kind of Runge-Kutta scheme. These work by following the derivative between <span>$t$</span> and <span>$t+dt$</span> with some adaptive internal step size to achieve a given precision.</p></li></ol><p>The first case of a piecewise-constant time evolution operator is particularly relevant to quantum control, since the two most venerable methods of quantum control (<a href="https://juliaquantumcontrol.github.io/GRAPE.jl/stable/">GRAPE</a> and <a href="https://juliaquantumcontrol.github.io/Krotov.jl/stable/">Krotov&#39;s method</a>) are inherently piecewise-constant. Hence, the <code>QuantumPropagators</code> package implements two efficient polynomial propagators that have a long history in quantum control, using Chebychev polynomials for closed quantum systems [<a href="../references/#Tal-EzerJCP1984">1</a>, <a href="../references/#KosloffJCP1988">2</a>] and Newton polynomials for open quantum systems [<a href="../references/#BermanJPA1992">3</a>–<a href="../references/#AshkenaziJCP1995">5</a>].</p><p>For propagation via an ODE Solver, <code>QuantumPropagators</code> delegates to the <a href="https://docs.sciml.ai/DiffEqDocs/stable/">DifferentialEquations.jl</a>, respectively the <a href="https://docs.sciml.ai/OrdinaryDiffEq/stable/">OrdinaryDiffEq.jl</a> package.</p><h2 id="overview_propagation"><a class="docs-heading-anchor" href="#overview_propagation">Propagation methods</a><a id="overview_propagation-1"></a><a class="docs-heading-anchor-permalink" href="#overview_propagation" title="Permalink"></a></h2><p>The <a href="../api/quantumpropagators/#QuantumPropagators.propagate"><code>propagate</code></a> function has a mandatory <code>method</code> keyword argument. It should be passed a module that implements the method. For the built-in methods, this would be one of the following submodule of <code>QuantumPropagators</code>:</p><pre><code class="language-julia hljs">using QuantumPropagators: ExpProp, Cheby, Newton</code></pre><p>The equation of motion is implicit in the propagation method. The above methods target the Schrödinger or Liouville equations for a piecewise-constant Hamiltonian that is evaluated on the midpoints of the propagation time grid.</p><p>The two core method are:</p><ul><li><code>method=Cheby</code>: Evaluate the application of the unitary time-evolution operator via an expansion into Chebychev polynomials.</li><li><code>method=Newton</code>: Evaluate the application of the non-unitary time-evolution operator via an expansion into Newton polynomials, for a Liouvillian or a non-Hermitian Hamiltonian.</li></ul><p>Furthermore, as a fallback for very small system or for debugging,</p><ul><li><code>method=ExpProp</code>: Explicitly construct the time evolution operator by matrix exponentiation and apply it to the state.</li></ul><p>If the <a href="https://github.com/SciML/OrdinaryDiffEq.jl">OrdinaryDiffEq.jl</a> or (equivalently) th <a href="https://docs.sciml.ai/DiffEqDocs/stable/">DifferentialEquations.jl</a> package is loaded, <code>QuantumPropagators</code> can delegate to it:</p><pre><code class="language-julia hljs">using OrdinaryDiffEq</code></pre><p>allows to pass</p><ul><li><code>method=OrdinaryDiffEq</code>: Use <a href="https://github.com/SciML/OrdinaryDiffEq.jl">OrdinaryDiffEq.jl</a> as a backend with any of the <a href="https://docs.sciml.ai/DiffEqDocs/stable/solvers/ode_solve/">algorithms available for ODEs in DifferentialEquations.jl</a>, <code>alg=Tsit5()</code> by default.</li></ul><p>Unlike any of the built-in methods, <code>OrdinaryDiffEq</code> is able to propagate for time-continuous generators. This is the default for that propagator (<code>pwc=false</code>). By setting <code>pwc=true</code> or <code>piecewise=true</code>) the ODE solvers can also be used for piecewise-constant Hamiltonians or Liouvillians, providing an alternative to the built-in <code>method=Cheby</code> and <code>method=Newton</code>.</p><p>See the more extended discussion of <a href="../methods/#Propagation-Methods">Propagation Methods</a> for more details.</p><h2 id="overview_dynamical_generators"><a class="docs-heading-anchor" href="#overview_dynamical_generators">Dynamical generators</a><a id="overview_dynamical_generators-1"></a><a class="docs-heading-anchor-permalink" href="#overview_dynamical_generators" title="Permalink"></a></h2><p>In the <a href="#getting_started">initial example</a>, the &quot;generator&quot; <code>H</code> that is the second argument to <a href="../api/quantumpropagators/#QuantumPropagators.propagate"><code>propagate</code></a> was a simple static operator. In general, we will want time-dependent Hamiltonians or Liouvillians. The standard way to initialize a time-dependent Hamiltonian is via the <a href="../api/quantumpropagators/#QuantumPropagators.Generators.hamiltonian"><code>hamiltonian</code></a> function, e.g., as  <code>hamiltonian(Ĥ₀, (Ĥ₁, ϵ₁), (Ĥ₂, ϵ₂))</code>. The <code>Ĥ₀</code>, <code>Ĥ₁</code>, and <code>Ĥ₂</code> are static operators, and <code>ϵ₁</code> and <code>ϵ₂</code> are control fields, typically functions (<a href="https://docs.julialang.org/en/v1/manual/methods/#Function-like-objects">or function-like objects</a>) of time <code>t</code>. For piecewise-constant propagators, <code>ϵ₁</code> and <code>ϵ₂</code> may also be an array of amplitude values appropriate to the time grid <code>tlist</code>. The tuple-syntax for the time-dependent terms is inspired by <a href="https://qutip.readthedocs.io/en/qutip-5.0.x/guide/dynamics/dynamics-time.html#time">QuTiP</a>.</p><p>Generally, the <code>generator</code>, or the operators/controls inside the tuples can be a arbitrary objects, as long as some relevant methods are implemented for these objects, see the full section on <a href="../generators/#Dynamical-Generators">Dynamical Generators</a>.</p><p>Open quantum systems are handled identically to closed quantum system, except that Hamiltonian operator are replaced by Liouvillian super-operators. For any system of non-trivial Hilbert space dimension, all (super-)operators should be sparse matrices.</p><h2 id="The-Propagator-interface"><a class="docs-heading-anchor" href="#The-Propagator-interface">The Propagator interface</a><a id="The-Propagator-interface-1"></a><a class="docs-heading-anchor-permalink" href="#The-Propagator-interface" title="Permalink"></a></h2><p>As a lower-level interface than <a href="../api/quantumpropagators/#QuantumPropagators.propagate"><code>propagate</code></a>, the <code>QuantumPropagators</code> package defines an interface for &quot;propagator&quot; objects. These are initialized via <a href="../api/quantumpropagators/#QuantumPropagators.init_prop"><code>init_prop</code></a> as, e.g.,</p><pre><code class="nohighlight hljs">using QuantumPropagators: init_prop

propagator = init_prop(Ψ₀, H, tlist; method)</code></pre><p>with a mandatory <code>method</code> keyword argument.</p><p>The <code>propagator</code> is a propagation-method-dependent object with the interface described by <a href="../api/quantumpropagators/#QuantumPropagators.AbstractPropagator"><code>AbstractPropagator</code></a> and <a href="../api/quantumpropagators/#QuantumPropagators.Interfaces.check_propagator"><code>QuantumPropagators.Interfaces.check_propagator</code></a>.</p><p>The  <a href="../api/quantumpropagators/#QuantumPropagators.prop_step!"><code>prop_step!</code></a> function can then be used to advance the <code>propagator</code>:</p><pre><code class="language-julia hljs">using QuantumPropagators: prop_step!

Ψ = prop_step!(propagator)  # single step

while !isnothing(prop_step!(propagator)); end  # go to end
Ψ = propagator.state

print(&quot;Ψ = $(round.(Ψ; digits=3)))\n&quot;)
print(&quot;t = $(round(propagator.t / π; digits=3))π\n&quot;)

# output

Ψ = ComplexF64[0.0 + 0.0im, 0.0 - 1.0im])
t = 0.5π</code></pre><h2 id="In-place-propagation"><a class="docs-heading-anchor" href="#In-place-propagation">In-place propagation</a><a id="In-place-propagation-1"></a><a class="docs-heading-anchor-permalink" href="#In-place-propagation" title="Permalink"></a></h2><p>Most propagators support both an in-place and a not-in-place mode. These modes can be switched via the <code>inplace</code> parameter to <a href="../api/quantumpropagators/#QuantumPropagators.propagate"><code>propagate</code></a>/<a href="../api/quantumpropagators/#QuantumPropagators.init_prop"><code>init_prop</code></a>, which defaults to the value of <a href="../api/quantumpropagators/#QuantumPropagators.Interfaces.supports_inplace"><code>QuantumPropagators.Interfaces.supports_inplace</code></a> for the given initial <code>state</code>. When using in-place operations, propagators should minimize the allocation of memory and modify states using in-place linear algebra operations (<a href="https://docs.julialang.org/en/v1/stdlib/LinearAlgebra/#BLAS-functions">BLAS</a>). Otherwise, with <code>inplace=false</code>, mutating states or operators is avoided. See the in-place and not-in-place operations described in <a href="../api/quantumpropagators/#QuantumPropagators.Interfaces.check_state"><code>QuantumPropagators.Interfaces.check_state</code></a> and <a href="../api/quantumpropagators/#QuantumPropagators.Interfaces.check_operator"><code>QuantumPropagators.Interfaces.check_operator</code></a>.</p><p>In-place operations can be dramatically more efficient for large Hilbert space dimensions. On the other hand, not-in-place operations can be more efficient for small Hilbert spaces, in particular when a <a href="https://juliaarrays.github.io/StaticArrays.jl/stable/api/#SVector">static vector</a> can be used to represent the state. Moreover, frameworks for automatic differentiation such as <a href="https://fluxml.ai/Zygote.jl/stable/">Zygote</a> do not support in-place operations.</p><p>When using custom structs for states, operators, or generators, the struct itself not not need to be mutable (according to <a href="https://docs.julialang.org/en/v1/base/base/#Base.ismutable"><code>Base.ismutable</code></a>) in order to support <code>inplace=true</code>. It only must support the in-place operations defined in the <a href="../api/quantumpropagators/#QuantumPropagatorsInterfacesAPI">formal interface</a> and indicate that support by defining <a href="../api/quantumpropagators/#QuantumPropagators.Interfaces.supports_inplace"><code>QuantumPropagators.Interfaces.supports_inplace</code></a>. Typically, in-place operations on immutable custom structs involve mutating the mutable properties of that struct.</p><h2 id="Backward-propagation"><a class="docs-heading-anchor" href="#Backward-propagation">Backward propagation</a><a id="Backward-propagation-1"></a><a class="docs-heading-anchor-permalink" href="#Backward-propagation" title="Permalink"></a></h2><p>When <a href="../api/quantumpropagators/#QuantumPropagators.propagate"><code>propagate</code></a> or <a href="../api/quantumpropagators/#QuantumPropagators.init_prop"><code>init_prop</code></a> are called with <code>backward=true</code>, the propagation is initialized to run backward. The initial state is then defined at <code>propagator.t == tlist[end]</code> and each <a href="../api/quantumpropagators/#QuantumPropagators.prop_step!"><code>prop_step!</code></a> moves to the previous point in <code>tlist</code>. The equation of motion is the Schrödinger or Liouville equation with a negative <span>$dt$</span>. For a Hermitian <code>generator</code>, doing a forward propagation followed by a backward propagation will recover the initial state. For a non-Hermitian <code>generator</code>, this no longer holds. Note that in optimal control methods such as GRAPE or Krotov&#39;s method, obtaining gradients involves a &quot;backward propagation with the adjoint generator&quot; (when the generator is non-Hermitian and adjoint/non-adjoint makes a difference). The <a href="../api/quantumpropagators/#QuantumPropagators.propagate"><code>propagate</code></a> routine with <code>backward=true</code> will not automatically take this adjoint of the <code>generator</code>; instead, the adjoint generator must be passed explicitly.</p><h2 id="Parameterized-controls"><a class="docs-heading-anchor" href="#Parameterized-controls">Parameterized controls</a><a id="Parameterized-controls-1"></a><a class="docs-heading-anchor-permalink" href="#Parameterized-controls" title="Permalink"></a></h2><p>Controls may depend on a list of tunable parameters. Such controls must be especially defined and should be subtypes of <a href="../api/quantumpropagators/#QuantumPropagators.Controls.ParameterizedFunction"><code>QuantumPropagators.Controls.ParameterizedFunction</code></a>, or more generally <a href="https://docs.julialang.org/en/v1/manual/methods/#Function-like-objects">&quot;functors&quot;</a> of a single float <code>t</code> for which <a href="../api/quantumpropagators/#QuantumPropagators.Controls.get_parameters"><code>QuantumPropagators.Controls.get_parameters</code></a> is implemented.</p><p>Independently, all <a href="../api/quantumpropagators/#QuantumPropagators.AbstractPropagator">propagators</a> have a field <code>parameters</code> that is a dict of controls to <em>propagation parameters</em> for that control. For continuous-time propagators, such as a propagator initialized with <code>method=OrdinaryDiffEq</code> and <code>pwc=false</code>, these propagation parameters are exactly the analytic parameters of the <code>control</code> as obtained by <a href="../api/quantumpropagators/#QuantumPropagators.Controls.get_parameters"><code>QuantumPropagators.Controls.get_parameters</code></a>.</p><p>For piecewise-constant propagators (all the default built-in propagators), the propagation parameters are always the values of the control evaluated on the mid points of the time grid, see <a href="../api/quantumpropagators/#QuantumPropagators.Controls.discretize_on_midpoints"><code>QuantumPropagators.Controls.discretize_on_midpoints</code></a>. Specifically, the analytic parameters from <code>get_parameters(control)</code> are not used as propagation parameters for piecewise propagators.</p><p>In any case, mutating <code>propagator.parameters</code> affects the propagation in subsequent calls to <a href="../api/quantumpropagators/#QuantumPropagators.prop_step!"><code>prop_step!</code></a>.</p><h2 id="Connection-to-DifferentialEquations.jl"><a class="docs-heading-anchor" href="#Connection-to-DifferentialEquations.jl">Connection to DifferentialEquations.jl</a><a id="Connection-to-DifferentialEquations.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Connection-to-DifferentialEquations.jl" title="Permalink"></a></h2><p>The <code>QuantumPropagators</code> API is structured similarly to the <a href="https://github.com/SciML/DifferentialEquations.jl">DifferentialEquations.jl</a></p><ul><li><p>The <a href="../api/quantumpropagators/#QuantumPropagators.propagate"><code>propagate</code></a> function is similar to <a href="https://diffeq.sciml.ai/stable/basics/overview/#Solving-the-Problems"><code>DifferentialEquations.solve</code></a></p></li><li><p>The <a href="../api/quantumpropagators/#QuantumPropagators.init_prop"><code>init_prop</code></a> function is similar to <a href="https://diffeq.sciml.ai/stable/basics/integrator/#Initialization-and-Stepping"><code>DifferentialEquations.init</code></a></p></li><li><p>The <a href="../api/quantumpropagators/#QuantumPropagators.reinit_prop!"><code>reinit_prop!</code></a> function is similar to <a href="https://diffeq.sciml.ai/stable/basics/integrator/#SciMLBase.reinit!"><code>DifferentialEquations.reinit!</code></a></p></li><li><p><a href="#The-Propagator-interface">The Propagator interface</a> is similar to DifferentialEquations&#39; <a href="https://diffeq.sciml.ai/stable/basics/integrator/">Integrator Interface</a></p></li><li><p><a href="../api/quantumpropagators/#QuantumPropagators.prop_step!"><code>prop_step!</code></a> corresponds to <a href="https://diffeq.sciml.ai/stable/basics/integrator/#SciMLBase.step!"><code>DifferentialEquations.step!</code></a></p></li><li><p><a href="../api/quantumpropagators/#QuantumPropagators.set_state!"><code>set_state!</code></a> corresponds to <a href="https://diffeq.sciml.ai/stable/basics/integrator/#SciMLBase.set_u!"><code>DifferentialEquations.set_u!</code></a></p></li><li><p><a href="../api/quantumpropagators/#QuantumPropagators.set_t!"><code>set_t!</code></a> corresponds to <a href="https://diffeq.sciml.ai/stable/basics/integrator/#SciMLBase.set_t!"><code>DifferentialEquations.set_t!</code></a></p></li></ul><p>Note that the equation of motion for <code>QuantumPropagators</code> is implicit in the propagation <code>method</code> (usually the Schrödinger/Liouville equation), so the initialization of a Propagator via the initial state and the &quot;generator&quot; is more specialized than DifferentialEquations&#39; <a href="https://diffeq.sciml.ai/stable/basics/problem/#Problem-Interface">Problem Interface</a>.</p><p>The propagator returned by <code>using DifferentialEquations; init_prop(Ψ₀, H, tlist; method=DifferentialEquations)</code> is a thin wrapper around DifferentialEquations&#39; integrator. That propagator uses an un-exported function <a href="../api/quantumpropagators/#QuantumPropagators.ode_function"><code>QuantumPropagators.ode_function</code></a> to wrap around the evaluation of a time-dependent generator. The <a href="../api/quantumpropagators/#QuantumPropagators.ode_function"><code>ode_function</code></a> wrapper could also be used directly to enable working with the data structures defined in <code>QuantumPropagators</code> in the context of the <code>DifferentialEquations</code> package.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../generators/">Dynamical Generators »</a><div class="flexbox-break"></div><p class="footer-message"><a href="https://github.com/JuliaQuantumControl/QuantumPropagators.jl">QuantumPropagators.jl</a> v0.8.5+dev docs powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Monday 15 December 2025 14:49">Monday 15 December 2025</span>. Using Julia version 1.12.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
