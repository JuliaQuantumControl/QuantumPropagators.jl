var documenterSearchIndex = {"docs":
[{"location":"benchmarks/#Benchmarks","page":"Benchmarks","title":"Benchmarks","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"TODO","category":"page"},{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/#QuantumPropagatorsAPI","page":"API","title":"QuantumPropagators","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"The QuantumPropagators.jl package exports the following high-level routines:","category":"page"},{"location":"api/","page":"API","title":"API","text":"initpropwrk — Initialize a work space for propagation\npropagate — Propagate a state over an entire time grid.\npropstep — Perform a single propagation step\npropstep! — Perform a single propagation step in-place.","category":"page"},{"location":"api/","page":"API","title":"API","text":"These delegate to routines implementing the various propagation method defined in the respective sub-modules.","category":"page"},{"location":"api/","page":"API","title":"API","text":"Furthermore, the following routines from the Storage sub-module are re-exported:","category":"page"},{"location":"api/","page":"API","title":"API","text":"init_storage – Create a storage array for propagated states or expectation values\nwrite_to_storage! – Place data into storage\nget_from_storage! – Obtain data from storage (in-place)","category":"page"},{"location":"api/#Reference","page":"API","title":"Reference","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Modules = [QuantumPropagators]","category":"page"},{"location":"api/#QuantumPropagators.initpropwrk-Tuple{Any, Any, Val{:auto}, Vararg{Any}}","page":"API","title":"QuantumPropagators.initpropwrk","text":"Initialize a workspace for propagation.\n\nwrk = initpropwrk(state, tlist, method=:auto, generator...; kwargs...)\n\nThe resulting wrk can be passed to propagate or propstep!.\n\nArguments\n\nstate: An exemplary state for the propagation (e.g., the initial state)\ntlist: The time grid over which propagate will be called. Must include at least to points in order to determine the propagation time step to prepare. If the propagation will be over a tlist with a variable dt, the full tlist must be passed here.\ngenerator: An exemplary (non-time-dependent) dynamical generator. For full generality (if method=:cheby), the given generator should have a spectral range sufficiently large to encompass the entire propagation. If given multiple times, a spectral envelope enclosing all the generators will be determined automatically. In this case, you should pass the generators with the extremal values of all the controls.\nmethod: The propagation method to use. The default value of :auto attempts to choose the best method available, based on the properties of the given state, tlist, and generator. Alternative values are :cheby and :newton, and :expprop.\nspecrad_method: for method=:cheby, method to use for estimating the  spectral radius, see QuantumPropagators.SpectralRange.specrange.  Defaults to :auto.\ntolerance: for method=:cheby, a tolerance factor for the estimated spectral radius. That is, Chebychev coefficients will be calculated for a spectral radius increased by the tolerance factor compared to the specral radius estimated for the generator.\n\nAll other kwargs are filtered and passed to the contructor for returned workspace, e.g. limit for method=:cheby or m_max for method=:newton. For method=:cheby, they are also passed to specrange.\n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumPropagators.propagate-Tuple{Any, Any, Any}","page":"API","title":"QuantumPropagators.propagate","text":"Propagate a state over an entire time grid.\n\nstate_out = propagate(\n    state, genfunc, tlist; method=:auto,\n    backwards=false; storage=nothing, observables=(<store state>, ),\n    hook=nothing, showprogress=false, control_parameters=nothing,\n    in_place=true, kwargs...)\n\npropagates state over the time grid in tlist, using piecewise-constant dynamical generators (Hamiltonians or Liouvillians) determined by genfunc, and returns the resulting propagated state. The propagation is performed by calling propstep! for every interval in tlist, or propstep if in_place=false.\n\nFor the i'th time interval, genfunc(tlist, i) must return the generator for that time interval. Generally, when approximating a time-continuous dynamical generator as piecewise-constant on the time grid, it should be evaluated at the midpoint of the interval. A possible exception is the first and last interval, which may be better evaluated at tlist[1] and tlist[end] to ensure exact boundary conditions like control fields that are exactly zero.\n\nIn addition to the two positional parameters indicating the time interval, genfunc will also receive the state (the input state for the propagation step), backwards, storage, observables, control_parameters, and init as keyword arguments.\n\nThe control_parameters are an optional array of floats with parameters for genfunc. This is required when propagate is used in the context of automatic differentiation (AD). E.g., the Zygote framework can automatically calculate gradients of a function control_parameters -> J_T, where J_T might be be a function of the overlap between a propagated state (returned by propagate) and a target state. Thus, the control_parameters must be explicit in propagate.  Outside of an AD context, control_parameters are not generally required: they can be implicit in genfunc.\n\nThe remaining keyword arguments may be used for unusual equations of motion beyond the standard Schrödinger or Liouville-von-Neumann equation, e.g. state would enter the genfunc for a Gross–Pitaevskii equation. For standard equations of motion that do not use the additional parameters, it is best to capture the keyword arguments to genfunc with a definition like\n\ngenfunc(tlist, i; kwargs...) = ...\n\nFor valid propagation methods, see initpropwrk.\n\nIn general, there is no requirement that tlist has a constant time step, although some propagation methods (most notably cheby!) only support a uniform time grid.\n\nIf storage is given as an Array, it will be filled with data determined by the observables. The default \"observable\" results in the propagated states at every point in time being stored. The storage array should be created with init_storage. See its documentation for details.\n\nThe storage parameter may also be given as true, and a new storage array will be created internally with init_storage and returned instead of the propagated state:\n\ndata = propagate(\n    state, genfunc, tlist; method=:auto\n    backwards=false; storage=true, observables=observables,\n    hook=nothing, showprogress=false, kwargs...)\n\nIf backwards is true, the input state is assumed to be at time tlist[end], and the propagation progresses backwards in time (with a negative time step dt). If storage is given, it will be filled back-to-front during the backwards propagation.\n\nIf hook is given as a callable, it will be called after each propagation step, as hook(state, generator, tlist, i, wrk, observables) where i is the index of the time interval on tlist covered by the propagation step (0 for the initial state, respectives lastindex(tlist) for the backward propagation).  The hook is called before calculating any observables. Example usage includes writing data to file, or modifying state, e.g., removing amplitude from the lowest and highest level to mitigate \"truncation error\".\n\nIf showprogress is given as true, a progress bar will be shown for long-running propagationn. In order to customize the progress bar, showprogress may also be a function that receives length(tlist) and returns a ProgressMeter.Progress instance.\n\nIf in_place=false is given, the propagation avoids in-place operations by using propstep instead of propstep!. This is often required in the context of automatic differentiation (AD), e.g., with Zygote. That is, use in_place=false if propagate is called inside a function to be passed to Zygote.gradient, Zygote.pullback, or a similar function. In and AD context, storage and showprogress should not be used.\n\nThe propagate routine returns the propagated state at tlist[end], respectively tlist[1] if backwards=true, or a storage array with the stored states / observable data if storage=true.\n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumPropagators.propstep!-Tuple{Any, Any, Any, QuantumPropagators.Cheby.ChebyWrk}","page":"API","title":"QuantumPropagators.propstep!","text":"Perform a single propagation step in-place.\n\npropstep!(state, generator, dt, wrk; kwargs...)\n\nThe propagation method is determined by wrk, see initpropwrk.\n\nGenerally, an in-place propagation will not be suitable for in the context of automatic differentiation.  See propagate for a method that does not act in-place.\n\nThe kwargs are forwarded to the underlying method.\n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumPropagators.propstep-Tuple{Any, Any, Any, QuantumPropagators.ExpProp.ExpPropWrk}","page":"API","title":"QuantumPropagators.propstep","text":"Perform a single propagation step and return the propagated state.\n\nstate_out = propstep(state, generator, dt, wrk; kwargs...)\n\nThe propagation method is determined by wrk, see initpropwrk.\n\nUnlike propstep!, this method does not act in place, which generally makes it more suitable for automatic differentiation. However, there may be a performance penalty associated with the additional memory allocations.\n\nThe kwargs are forwarded to the underlying method.\n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumPropagtorsStorageAPI","page":"API","title":"QuantumPropagators.Storage","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"The following routine allow manage and extend storage arrays storage parameter in propagate. See Storage of states or expectation values for more details. Note that the high-level routines init_storage, write_to_storage!, and get_from_storage! are also re-exported in the top-level QuantumPropagators directly.","category":"page"},{"location":"api/","page":"API","title":"API","text":"Modules = [QuantumPropagators.Storage]","category":"page"},{"location":"api/#QuantumPropagators.Storage.get_from_storage!-Tuple{Any, AbstractVector, Any}","page":"API","title":"QuantumPropagators.Storage.get_from_storage!","text":"Obtain data from storage.\n\nget_from_storage!(state, storage, i)\n\nextracts data from the storage for the i'th time slot. Invese of write_to_storage!\n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumPropagators.Storage.init_storage-Tuple{Any, AbstractVector}","page":"API","title":"QuantumPropagators.Storage.init_storage","text":"Create a storage array for propagation.\n\nstorage = init_storage(state, tlist)\n\ncreates a storage array suitable for storing a state for each point in tlist.\n\nstorage = init_storage(state, tlist, observables))\n\ncreates a storage array suitable for the data generated by the observables applied to state, see map_observables, for each point in tlist.\n\nstorage = init_storage(data, nt))\n\ncreates a storage arrays suitable for storing data nt times, where nt=length(tlist). By default, this will be a vector of typeof(data) and length nt, or a n × nt Matrix with the same eltype as data if data is a Vector of length n.\n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumPropagators.Storage.map_observable-Tuple{Any, Any}","page":"API","title":"QuantumPropagators.Storage.map_observable","text":"Apply a single observable to state.\n\ndata = map_observable(observable, state)\n\nBy default, observable is assumed to be callable, and the above is equivalent to data = observable(state).\n\nIf observable is a matrix and state is a vector evaluate the expectation value of the observable as dot(state, observable, state).\n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumPropagators.Storage.map_observables-Tuple{Any, Any}","page":"API","title":"QuantumPropagators.Storage.map_observables","text":"Obtain \"observable\" data from state.\n\ndata = map_observables(observables, state)\n\ncalculates the data for a tuple of observables applied to state. For a single observable (tuple of length 1), simply return the result of map_observable.\n\nFor multiple observables, return the tuple resulting from applying map_observable for each observable. If the tuple is \"uniform\" (all elements are of the same type, e.g. if each observable calculates the expectation value of a Hermitian operator), it is converted to a Vector. This allows for compact storage in a storage array, see init_storage.\n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumPropagators.Storage.write_to_storage!-Tuple{Any, Integer, Any, Any}","page":"API","title":"QuantumPropagators.Storage.write_to_storage!","text":"Place data into storage for time slot i.\n\nwrite_to_storage!(storage, i, state, observables)\n\nFor a storage array created by init_storage, store the data obtains from map_observables into the storage for time slot i. This delegates to the more general\n\nwrite_to_storage!(storage, i, data)\n\nConceptually, this corresponds roughly to storage[i] = data, but storage may have its own idea on how to store data for a specific time slot. For example, with the default init_storage Vector data will be stored in a matrix, and write_to_storage! will in this case write data to the i'th column of the matrix.\n\nFor a given type of storage and data, it is the developer's responsibility that init_storage and write_to_storage! are compatible.\n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumPropagatorsChebyAPI","page":"API","title":"QuantumPropagators.Cheby","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"The following routines implement time propagation via expansion in Chebychev polynomials.","category":"page"},{"location":"api/","page":"API","title":"API","text":"Modules = [QuantumPropagators.Cheby]","category":"page"},{"location":"api/#QuantumPropagators.Cheby.ChebyWrk","page":"API","title":"QuantumPropagators.Cheby.ChebyWrk","text":"Workspace for the Chebychev propagation routine.\n\nChebyWrk(Ψ, Δ, E_min, dt; limit=1e-12)\n\ninitializes the workspace for the propagation of a state similar to Ψ under a Hamiltonian with eigenvalues between E_min and E_min + Δ, and a time step dt. Chebychev coefficients smaller than the given limit are discarded.\n\n\n\n\n\n","category":"type"},{"location":"api/#QuantumPropagators.Cheby.cheby!-NTuple{4, Any}","page":"API","title":"QuantumPropagators.Cheby.cheby!","text":"Evaluate Ψ = exp(-i H dt) Ψ in-place.\n\ncheby!(Ψ, H, dt, wrk; E_min=nothing, check_normalization=false)\n\nArguments\n\nΨ: on input, initial vector. Will be overwritten with result.\nH: Hermitian operator\ndt: time step\nwrk: internal workspace\nE_min: minimum eigenvalue of H, to be used instead of the E_min from the  initialization of wrk. The same wrk may be used for different values  E_min, as long as the spectra radius Δ and the time step dt are the  same as those used for the initialization of wrk.\ncheck_normalizataion: perform checks that the H does not exceed the spectral radius for which the the workspace was initialized.\n\nThe routine will not allocate any internal storage. This implementation requires copyto! lmul!, and axpy! to be implemented for Ψ, and the three-argument mul! for Ψ and H.\n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumPropagators.Cheby.cheby-NTuple{4, Any}","page":"API","title":"QuantumPropagators.Cheby.cheby","text":"Evaluate Ψ = exp(i- H dt) Ψ.\n\nΨ_out = cheby(Ψ, H, dt, wrk; E_min=nothing, check_normalization=false)\n\nacts like cheby! but does not modify Ψ in-place.\n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumPropagators.Cheby.cheby_coeffs!","page":"API","title":"QuantumPropagators.Cheby.cheby_coeffs!","text":"Calculate Chebychev coefficients in-place.\n\nn::Int = cheby_coeffs!(coeffs, Δ, dt, limit=1e-12)\n\noverwrites the first n values in coeffs with new coefficients larger than limit for the given new spectral radius Δ and time step dt. The coeffs array will be resized if necessary, and may have a length > n on exit.\n\nSee also cheby_coeffs for an non-in-place version.\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumPropagators.Cheby.cheby_coeffs-Tuple{Any, Any}","page":"API","title":"QuantumPropagators.Cheby.cheby_coeffs","text":"Calculate Chebychev coefficients.\n\na::Vector{Float64} = cheby_coeffs(Δ, dt; limit=1e-12)\n\nreturn an array of coefficiencts larger than limit.\n\nArguments\n\nΔ: the spectral radius of the underlying operator\ndt: the time step\n\nSee also cheby_coeffs! for an in-place version.\n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumPropagtorsNewtonAPI","page":"API","title":"QuantumPropagators.Newton","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"The following routines implement time propagation via expansion in Newton polynomials using a restarted Arnoldi scheme to determine evaluation points.","category":"page"},{"location":"api/#Public-members","page":"API","title":"Public members","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Modules = [QuantumPropagators.Newton]\nPublic = true\nPrivate = false","category":"page"},{"location":"api/#QuantumPropagators.Newton.NewtonWrk","page":"API","title":"QuantumPropagators.Newton.NewtonWrk","text":"NewtonWrk(v0, m_max=10)\n\nWorkspace for the Newton-with-restarted-Arnoldi propagation routine.\n\nInitializes the workspace for the propagation of a vector v0, using a maximum Krylov dimension of m_max in each restart iteration. Note that m_max should be smaller than the length of v0.\n\n\n\n\n\n","category":"type"},{"location":"api/#QuantumPropagators.Newton.newton!-NTuple{4, Any}","page":"API","title":"QuantumPropagators.Newton.newton!","text":"newton!(Ψ, H, dt, wrk; func=(z -> exp(-1im*z)), norm_min=1e-14, relerr=1e-12,\n        max_restarts=50)\n\nEvaluate Ψ = func(H*dt) Ψ using a Newton-with-restarted-Arnoldi scheme.\n\nArguments\n\nΨ: The state to propagate, will be overwritten in-place with the propagated state\nH: Operator acting on Ψ. Together with dt, this is the argument to func\ndt: Implicit time step. Together with H, this is the argument to func\nwkr: Work array, initialized with NewtonWrk\nfunc: The function to apply to H dt, taking a single (scalar) complex-valued argument z in place of H dt. The default func is to evaluate the time evoluation operator for the Schrödinger equation\nnorm_min: the minium norm at which to consider a state similar to Ψ as zero\nrelerr: The relative error defining the convergence condition for the restart iteration. Propagation stops when the norm of the accumulated Ψ is stable up to the given relative error\nmax_restart: The maximum number of restart iterations. Exceeding max_restart will throw an AssertionError.\n\n\n\n\n\n","category":"method"},{"location":"api/#Private-members","page":"API","title":"Private members","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Modules = [QuantumPropagators.Newton]\nPublic = false\nPrivate = true","category":"page"},{"location":"api/#QuantumPropagators.Newton.extend_leja!-Tuple{OffsetArrays.OffsetVector{ComplexF64, AA} where AA<:AbstractVector{ComplexF64}, Any, OffsetArrays.OffsetVector{ComplexF64, AA} where AA<:AbstractVector{ComplexF64}, Any}","page":"API","title":"QuantumPropagators.Newton.extend_leja!","text":"extend_leja!(leja, n, newpoints, n_use)\n\nGiven an array of n (ordered) Leja points, extract n_use points from newpoints, and append them to the existing Leja points. The array leja should be sufficiently large to hold the new Leja points, which are appended after index n_old. It will be re-allocated if necessary and may have a size of up to 2*(n+n_use).\n\nArguments\n\nleja: Array of leja values. Must contain the \"old\" leja values to be kept  in leja(0:n-1). On output, n_use new leja points will be in  leja(n+:n+n_use-1), for the original value of n.  The leja array must  use zero-based indexing.\nn: On input, number of \"old\" leja points in leja. On output, total number of leja points (i.e. n=n+n_use)\nnewpoints: On input, candidate points for new leja points.  The n_use best values will be chosen and added to leja. On output, the values of new_points are undefined.\nn_use: Number of points that should be added to leja\n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumPropagators.Newton.extend_newton_coeffs!-Tuple{OffsetArrays.OffsetVector{ComplexF64, AA} where AA<:AbstractVector{ComplexF64}, Int64, OffsetArrays.OffsetVector{ComplexF64, AA} where AA<:AbstractVector{ComplexF64}, Any, Int64, Float64}","page":"API","title":"QuantumPropagators.Newton.extend_newton_coeffs!","text":"extend_newton_coeffs!(a, n_a, leja, func, n_leja, radius)\n\nExtend the array a of existing Newton coefficients for the expansion of the func from n_a coefficients to n_leja coefficients. Return a new value n_a=n_a+n_leja with the total number of Newton coefficients in the updated a.\n\nArguments\n\na: On input, a zero-based array of length n_a or greater, containing Newton coefficients. On output, array containing a total n_leja coefficients. The array a will be resized if necessary, and may have a length greater than n_leja on output\nn_a:  The number of Newton coefficients in a, on input. Elements of a  beyond the first n_a elements will be overwritten.\nleja: Array of normalized Leja points, containing at least n_leja elements.\nfunc: Function for which to calcluate Newton coeffiecients\nn_leja: The number of elements in leja to use for calculating new coefficients, and the total number of Newton coefficients on output\nradius: Normalization radius for divided differences\n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumPropagtorsExpPropAPI","page":"API","title":"QuantumPropagators.ExpProp","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"The following routines implement time propagation via explicit exponentiation of the dynamical generator.","category":"page"},{"location":"api/","page":"API","title":"API","text":"Modules = [QuantumPropagators.ExpProp]\nPublic = true\nPrivate = false","category":"page"},{"location":"api/#QuantumPropagators.ExpProp.ExpPropWrk","page":"API","title":"QuantumPropagators.ExpProp.ExpPropWrk","text":"ExpPropWrk(v0)\n\nWorkspace for propagation via direct matrix exponentiation.\n\nInitializes the workspace for the propagation of a vector v0\n\n\n\n\n\n","category":"type"},{"location":"api/#QuantumPropagators.ExpProp.expprop!-NTuple{4, Any}","page":"API","title":"QuantumPropagators.ExpProp.expprop!","text":"expprop!(Ψ, H, dt, wrk; func=(H_dt -> exp(-1im * H_dt)))\n\nEvaluate Ψ = func(H*dt) Ψ by directly evaluating U = func(H*dt), i.e. by matrix exponentiation for the default func, and then multiplying U and Ψ in-place with mul!.\n\nThe workspace wrk must be initialized with ExpPropWrk to provide storage for a temporary state.\n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumPropagtorsSpectralRangeAPI","page":"API","title":"QuantumPropagators.SpectralRange","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Chebychev propagation relies on estimating the spectral range of the Hamiltonian, which in turn may be done via Arnoldi iteration.","category":"page"},{"location":"api/#Public-members-2","page":"API","title":"Public members","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Modules = [QuantumPropagators.SpectralRange]\nPublic = true\nPrivate = false","category":"page"},{"location":"api/#QuantumPropagators.SpectralRange.specrange-Tuple{Any, Val{:arnoldi}}","page":"API","title":"QuantumPropagators.SpectralRange.specrange","text":"E_min, E_max = specrange(H, :arnoldi; state=random_state(H), m_min=20,\n                         m_max=60, prec=1e-3, nom_min=1e-15, enlarge=true)\n\nuses Arnoldi iteration with state as the starting vector. It approximates the eigenvalues of H with between m_min and m_max Ritz values, until the lowest and highest eigenvalue are stable to a releative precision of prec. The norm_min parameter is passed to the underlying arnoldi!.\n\nIf enlarge=true (default) the returned E_min and E_max will be enlarged via a heuristic to slightly over-estimate the spectral radius instead of under-estimating it.\n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumPropagators.SpectralRange.specrange-Tuple{Any, Val{:diag}}","page":"API","title":"QuantumPropagators.SpectralRange.specrange","text":"E_min, E_max = specrange(H, :diag)\n\nuses exact diagonization via the standard eigenvals function to obtain the smallest and largest eigenvalue. This should only be used for relatively small matrices.\n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumPropagators.SpectralRange.specrange-Tuple{Any}","page":"API","title":"QuantumPropagators.SpectralRange.specrange","text":"Calculate the spectral range of a Hamiltonian H on the real axis.\n\nE_min, E_max = specrange(H; method=:auto, kwargs...)\n\ncalculates the approximate lowest and highest eigenvalues of H. Any imaginary part in the eigenvalues is ignored: the routine is intended for (although not strictly limited to) a Hermitian H.\n\nThis delegates to\n\nspecrange(H, method; kwargs...)\n\nfor the different methods.\n\nThe default method=:auto chooses the best method for the given H. This is :diag for small matrices, and :arnoldi otherwise. Keyword arguments not relevant to the underlying implementation will be ignored.\n\n\n\n\n\n","category":"method"},{"location":"api/#Private-members-2","page":"API","title":"Private members","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Modules = [QuantumPropagators.SpectralRange]\nPublic = false\nPrivate = true","category":"page"},{"location":"api/#QuantumPropagators.SpectralRange.random_state-Tuple{AbstractMatrix}","page":"API","title":"QuantumPropagators.SpectralRange.random_state","text":"Random normalized quantum state.\n\n    Ψ = random_state(H)\n\nreturns a random normalized state compatible with the Hamiltonian H. This is intended to provide a starting vector for estimating the spectral radius of H via an Arnoldi method.\n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumPropagators.SpectralRange.ritzvals","page":"API","title":"QuantumPropagators.SpectralRange.ritzvals","text":"Calculate a vector for Ritz values converged to a given precision.\n\nR = ritzvals(G, state, m_min, m_max=2*m_min; prec=1e-5, norm_min=1e-15)\n\ncalculates a complex vector R of at least m_min and at most m_max Ritz values.\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumPropagtorsArnoldiAPI","page":"API","title":"QuantumPropagators.Arnoldi","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Arnoldi iteration is an approximate method to find extremal eigenvalues of a dynamical generator by projecting it into a Krylov subspace. It is used to estimate spectral ranges for Chebychev Propagation and to find appropriate Leja points to support Newton Propagation","category":"page"},{"location":"api/#Private-members-3","page":"API","title":"Private members","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"<!--There are no public routines in Arnoldi-->","category":"page"},{"location":"api/","page":"API","title":"API","text":"Modules = [QuantumPropagators.Arnoldi]\nPublic = false\nPrivate = true","category":"page"},{"location":"api/#QuantumPropagators.Arnoldi.arnoldi!-Union{Tuple{T}, Tuple{Matrix{ComplexF64}, Array{T}, Int64, T, Any}, Tuple{Matrix{ComplexF64}, Array{T}, Int64, T, Any, Float64}} where T","page":"API","title":"QuantumPropagators.Arnoldi.arnoldi!","text":"m = arnoldi!(Hess, q, m, Ψ, H, dt=1.0; extended=true, norm_min=1e-15)\n\nCalculate the Hessenberg matrix and Arnoldi vectors of H dt, from Ψ.\n\nFor a given order m, the m×m Hessemberg matrix is calculated and stored in in the pre-allocated Hess. Further  an array of m normalized Arnoldi vectors is stored in in the pre-allocated q, plus one additional unnormalized Arnoldi vector.  The unnormalized m+1st vector could be used to easily extend a given m×m Hessenberg matrix to a (m+1)×(m+1) matrix.\n\nIf the extended Hessenberg matrix is requested (extended=true, default), the m+1st Arnoldi vector is also normalized, and it's norm will be stored in m+1, m entry of the (extended) Hessenberg matrix, which is an (m+1)×(m+1) matrix.\n\nReturn the size m of the calculated Hessenberg matrix. This will usually be the input m, except when the Krylov dimension of H starting from Ψ is less then m. E.g., if Ψ is an eigenstate of H, the returned m will be 1.\n\nSee http://en.wikipedia.org/wiki/Arnoldi_iteration for a description of the algorithm.\n\nArguments\n\nHess::Matrix{ComplexF64}: Pre-allocated storage for the Hessemberg matrix.  Can be uninitialized on input. The matrix must be at least of size m×m, or  (m+1)×(m+1) if extended=true. On output, the m×m sub-matrix of Hess  (with the returned output m) will contain the Hessenberg matrix, and all  other elements of Hess be be set to zero.\nq: Pre-allocated array of states similar to Ψ, as storage for the calculated Arnoldi vectors. These may be un-initialized on input. Must be at least of length m+1\nm: The requested dimensions of the output Hessenberg matrix.\nΨ: The starting vector for the Arnoldi procedure. This can be of any type,  as long as Φ = H * Ψ results in a vector similar to Ψ, there is an inner  products of Φ and Ψ (Ψ⋅Φ is defined), and norm(Ψ) is defined.\nH: The operator (up to dt) for which to calculate the Arnoldi procedure. Can be of any type, as long as H * Ψ is defined.\ndt: The implicit time step; the total operator for which to calculate the Arnoldi procedure is H * dt\nextended: If true (default), calculate the extended Hessenberg matrix, and normalized the final Arnoldi vector\nnorm_min: the minimum value of the norm of Ψ at which Ψ should be  considered the zero vector\n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumPropagators.Arnoldi.diagonalize_hessenberg_matrix-Tuple{Any, Any}","page":"API","title":"QuantumPropagators.Arnoldi.diagonalize_hessenberg_matrix","text":"diagonalize_hessenberg_matrix(Hess, m; accumulate=false)\n\nDiagonalize the m × m top left submatrix of the given Hessenberg matrix.\n\nIf accumulate is true, return the concatenated eigenvalues for Hess[1:1,1:1] to Hess[1:m,1:m], that is, all sumatrices of size 1 through m.\n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumPropagators.Arnoldi.extend_arnoldi!","page":"API","title":"QuantumPropagators.Arnoldi.extend_arnoldi!","text":"Extend dimension of Hessenberg matrix by one.\n\nextend_arnoldi!(Hess, q, m, H, dt; norm_min=1e-15)\n\nextends the entries in Hess from size (m-1)×(m-1) to size m×m, and the list q of Arnoldi vectors from m to (m+1). It is assumed that the input Hess was created by a call to arnoldi! with extended=false or a previous call to extend_arnoldi!. Note that Hess itself is not resized, so it must be allocated to size m×m or greater on input.\n\n\n\n\n\n","category":"function"},{"location":"api/#Index","page":"API","title":"Index","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"","category":"page"},{"location":"howto/#Howtos","page":"Howtos","title":"Howtos","text":"","category":"section"},{"location":"howto/#Howto-extend-QuantumPropagators-with-a-new-propagation-method","page":"Howtos","title":"Howto extend QuantumPropagators with a new propagation method","text":"","category":"section"},{"location":"howto/","page":"Howtos","title":"Howtos","text":"Define a new workspace type that is unique to the propagation method, e.g. MyNewMethodWrk\nSpecialize the method initpropwrk for method::Val{:mynewmethod}\nSpecialize the method propstep! for wrk::MyNewMethodWrk","category":"page"},{"location":"howto/","page":"Howtos","title":"Howtos","text":"By defining only the above two methods, it becomes possible to call","category":"page"},{"location":"howto/","page":"Howtos","title":"Howtos","text":"propagate(state, genfunc, tlist, :mynewmethod; kwargs...)","category":"page"},{"location":"history/#History","page":"History","title":"History","text":"","category":"section"},{"location":"history/#.0.3-(2020-12-30)","page":"History","title":"0.0.3 (2020-12-30)","text":"","category":"section"},{"location":"history/","page":"History","title":"History","text":"First public release","category":"page"},{"location":"overview/#Overview","page":"Overview","title":"Overview","text":"","category":"section"},{"location":"overview/#Storage-of-states-or-expectation-values","page":"Overview","title":"Storage of states or expectation values","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"The propagate routine allows the storage of data for every point of the time grid.  This is done by passing it a storage object created with init_storage, or simply storage=true in order to create the appropriate storage automatically.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"By default, the storage will be used to store the propagated states at each point in time. More generally, what goes into storage can be customized via the observables parameter of propagate.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"After each propagation step, with a propagate state at time slot i,","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"QuantumPropagators.Storage.map_observables generates data from the propagated state\nQuantumPropagators.Storage.write_to_storage! places that data into storage for time slot i","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"After propagate returns, the get_from_storage! routine can be used to extract data from any time slot. This interface hides the internal memory organization of storage, which is set up by init_storage based on the type of state and the given observables. This system can can extended with multiple dispatch, allowing to optimize the storage for custom data types. Obviously, init_storage, map_observables, write_to_storage!, and get_from_storage! must all be consistent.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"The default implementation of these routine uses either a standard Vector or a Matrix as storage.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"Roughly speaking, when storing states, if the state of some arbitrary type, the storage will be a Vector where the i'th entry points to a copy of the propagated state at the i'th time slot. If the state is a Vector, the storage will be a Matrix containing the state for the i'th time slot in the i'th column.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"When a tuple of observables is passed to propagate, if map_observables returns data of the same type for each observable, storage will be a Matrix containing the values from the different observables for the i'th time slot in the i'th column. This would be typical for the storage of expectation values, e.g. with","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"observables=(state->dot(state, Ô₁, state), state->dot(state, Ô₂, state))","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"where Ô₁, Ô₂ are two Hermitian operators. In this case, storage would be a 2 × nt Float64 array. Calling get_from_storage!(data, storage, i) would be equivalent to copyto!(data, storage[:,i]) and extract the i'th column of storage, i.e. the vector [⟨Ô₁⟩, ⟨Ô₂A]⟩] at time slot i. Alternatively, storage[1,:] would return the values of ⟨Ô₁⟩ over time. This would be useful for plotting, and illustrates the benefits of using a Matrix as storage.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"Usually, the observables should be functions acting on the state, but map_observables can be extended to other types of observables as well. For example, the situation were state is a vector and the observables are matrices is also supported; if  Ô₁, Ô₂ are matrices,","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"observables=(Ô₁, Ô)","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"would have the same result of storing the expectation values of those two operators.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"The observables are not required to yield real values: the term \"observables\" is used very loosely here. We could directly calculate, e.g., the complex amplitude α of a coherent state in quantum optics, the number of levels with non-zero population (as an integer), or the propagated state transformed from a moving frame to a lab frame.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"If there are multiple observables that return data of different types, by default storage will be a Vector that contains tuples with the result for each observable. For example, with","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"observables=(state->dot(state, Ô₁, state), state->count_poplevels(state))","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"where count_poplevels is a function that counts the number of levels with non-zero population, the resulting storage would be a Vector{Tuple{Float64, Int64}}.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"If there is a single observable that yields a vector, that vector is stored in the i'th column of a storage matrix. This is in fact what happens when storing the propagated states (observables=(Ψ->copy(Ψ), )) if Ψ is a Vector, but there are other use cases, such as calculating the population in all levels in one go, with observables=(Ψ -> abs.(Ψ).^2, ).","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"If there is a single variable that yields a non-vector object, storage will be a Vector where the i'th entry points to the object. This is in fact what happens by default when storing states  that are e.g. instances of QuantumOptics.Ket. In such a case, it might be advisable to add new methods for QuantumPropagators.Storage.init_storage and QuantumPropagators.Storage.write_to_storage! that implement a more efficient in-place storage.","category":"page"},{"location":"background/#Background","page":"Background","title":"Background","text":"","category":"section"},{"location":"background/#Chebychev-Propagation","page":"Background","title":"Chebychev Propagation","text":"","category":"section"},{"location":"background/","page":"Background","title":"Background","text":"TODO","category":"page"},{"location":"background/#Newton-Propagation","page":"Background","title":"Newton Propagation","text":"","category":"section"},{"location":"background/","page":"Background","title":"Background","text":"TODO","category":"page"},{"location":"background/#Propagation-with-Explicit-Matrix-Exponentiation","page":"Background","title":"Propagation with Explicit Matrix Exponentiation","text":"","category":"section"},{"location":"background/","page":"Background","title":"Background","text":"TODO","category":"page"},{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"TODO","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Pages=[\n    \"1.md\",\n    \"2.md\",\n]\nDepth = 1","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = QuantumPropagators","category":"page"},{"location":"#QuantumPropagators","page":"Home","title":"QuantumPropagators","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The QuantumPropagators package implements methods for simulating the time dynamics of a quantum system. It is the numerical backend for all packages implementing methods of optimal control within the JuliaQuantumControl organization.","category":"page"},{"location":"#Contents","page":"Home","title":"Contents","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages=[\n \"overview.md\",\n \"background.md\",\n \"examples/index.md\",\n \"howto.md\",\n \"benchmarks.md\",\n \"api.md\",\n \"history.md\",\n]\nDepth = 2","category":"page"}]
}
