var documenterSearchIndex = {"docs":
[{"location":"benchmarks/#Benchmarks","page":"Benchmarks","title":"Benchmarks","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"TODO","category":"page"},{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/#High-level-routines","page":"API","title":"High level routines","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"The QuantumPropagators.jl package provides the following high-level routines:","category":"page"},{"location":"api/","page":"API","title":"API","text":"init_storage — Return a storage object for propagate\ninitpropwrk — Initialize a work space for propagation\npropagate — Propagate a state over an entire time grid.\npropstep! — Perform a single propagation step in-place.","category":"page"},{"location":"api/","page":"API","title":"API","text":"These delegate the routines implementing the various propagation methods, detailed in the reference sections below.","category":"page"},{"location":"api/","page":"API","title":"API","text":"See the Index for the full list of routines.","category":"page"},{"location":"api/#Reference","page":"API","title":"Reference","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Modules = [QuantumPropagators]\nPages = [\"propagate.jl\"]","category":"page"},{"location":"api/#QuantumPropagators.init_storage","page":"API","title":"QuantumPropagators.init_storage","text":"Return a storage object for propagate.\n\nstorage = init_storage(state, tlist, observables=(state->copy(state), ))\n\nReturn an Array suitable for storing the result of applying the given observables to a state for every point in tlist. There are three cases:\n\nFor a single observable, the resulting storage is a Vector of the same  length as tlist that holds the result of applying the observable. For the  default observable state->copy(state), that is a Vector of states  (Vector{typeof(state)}).\nFor multiple observables, if the observables are uniform (all return an  object of the same type), the resulting storage will be an Array of size  n × nt where n is the number of observables and nt is the length of  tlist.  This applies to e.g. the case where the observables are  normal expectation values.\n observables=(state->dot(state, Ô₁, state), state->dot(state, Ô₂, state))\nfor two Hermitian operators Ô₁, Ô₂ would result in a storage of type  Matrix{Float64}. After a propagation with propagate, the  expectation values of Ô₁ over time would then be accessible as  storage[1,:]\nFor multiple observables, if the observables are not uniform, the resulting  storage will be a Vector of length nt for the observable-tuples. For  example,\n observables=(state->dot(state, Ô₁, state), state->count_poplevels(state))\nwhere count_poplevels is a function that counts the number of levels with  non-zero population, the resulting storage would be a  Vector{Tuple{Float64, Int64}}.\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumPropagators.initpropwrk-Tuple{Any, Any, Vararg{Any, N} where N}","page":"API","title":"QuantumPropagators.initpropwrk","text":"Initialize a workspace for propagation.\n\nwrk = initpropwrk(state, tlist, generator...; method=:auto, kwargs...)\n\nThe resulting wrk can be passed to propagate or propstep!.\n\nArguments\n\nstate: An exemplary state for the propagation (e.g., the initial state)\ntlist: The time grid over which propagate will be called. Must include at least to points in order to determine the propagation time step to prepare. If the propagation will be over a tlist with a variable dt, the full tlist must be passed here.\ngenerator: An exemplary (non-time-dependent) dynamical generator. For full generality (if method=:cheby), the given generator should have a spectral range sufficiently large to encompass the entire propagation. If given multiple times, a spectral envelope enclosing all the generators will be determined automatically. In this case, you should pass the generators with the extremal values of all the controls.\nmethod: The propagation method to use. The default value of :auto attempts to choose the best method available, based on the properties of the given state, tlist, and generator. Alternative values are :cheby and :newton.\n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumPropagators.propagate","page":"API","title":"QuantumPropagators.propagate","text":"Propagate a state over an entire time grid.\n\npropagate(state, genfunc, tlist, backwards=false;\n          wrk=nothing, storage=nothing, observables=(state->copy(state), ),\n          storage_in_place=false)\n\npropagates state over the time grid in tlist, using piecewise-constant dynamical generators (Hamiltonians or Liouvillians) determined by genfunc, and returns the resulting propagated state.\n\nFor the i'th time interval, genfunc(tlist, i) must return the generator for that time interval. Generally, when approximating a time-continuous dynamical generator as piecewise-constant on the time grid, it should be evaluated at the midpoint of the interval. A possible exception is the first and last interval, which may be better evaluated at tlist[1] and tlist[end] to ensure exact boundary conditions like control fields that are exactly zero.\n\nThe propagation method is determined by wrk, see initpropwrk. If wrk is not given, propagate will attempt to choose the most appropriate method for the given parameters.\n\nIn general, there is no requirement that tlist has a constant time step, although some propagation methods (most notably cheby!) only support a uniform time grid.\n\nIf storage is given as an Array, it will be filled with data determined by the observables. The default \"observable\", state->copy(state) results in the propagated states at every point in time being stored. Other use cases would include the storage of expectation values, e.g. with\n\nobservables=(state->dot(state, Ô₁, state), state->dot(state, Ô₂, state))\n\nwhere Ô₁, Ô₂ are two Hermitian operators.\n\nThe storage array should be initialized with init_storage. See its documentation for the required layout of storage for different types of observables. If storage_in_place is true, copyto! will be used to store values into storage. This only works in special cases (like the default storage of propagated states) and may require additional initialization beyond init_storage (e.g., pre-allocating the states in storage).  Use with caution.\n\nNote that the term \"observables\" is used very loosely here: the observables are not required to yield real values, but are allowed to directly calculate, e.g., the complex amplitude α of a coherent state in quantum optics, the number of levels with non-zero population, or the propagated state transformed from a moving frame to a lab frame.\n\nIf backwards is true, the input state is assumed to be at time tlist[end], and the propagation progresses backwards in time (with a negative time step dt). If storage is given, it will be filled back-to-front during the backwards propagation.\n\nThe propagate routine returns the propagated state at tlist[end], respectively tlist[1] if backwards=true.\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumPropagators.propstep!-Tuple{Any, Any, Any, ChebyWrk}","page":"API","title":"QuantumPropagators.propstep!","text":"Perform a single propagation step in-place.\n\npropstep!(state, generator, dt, wrk;, kwargs...)\n\nThe propagation method is determined by wrk, see initpropwrk. The kwargs are forwarded to the underlying method\n\n\n\n\n\n","category":"method"},{"location":"api/#Chebychev-reference","page":"API","title":"Chebychev reference","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"The following routines implement time propagation via expansion in Chebychev polynomials.","category":"page"},{"location":"api/","page":"API","title":"API","text":"Modules = [QuantumPropagators]\nPages = [\"cheby.jl\"]","category":"page"},{"location":"api/#QuantumPropagators.ChebyWrk","page":"API","title":"QuantumPropagators.ChebyWrk","text":"Workspace for the Chebychev propagation routine.\n\n    ChebyWrk(Ψ, Δ, E_min, dt; limit=1e-12)\n\ninitializes the workspace for the propagation of a state similar to Ψ under a Hamiltonian with eigenvalues between E_min and E_min + Δ, and a time step dt. Chebychev coefficients smaller than the given limit are discarded.\n\n\n\n\n\n","category":"type"},{"location":"api/#QuantumPropagators.cheby!-NTuple{4, Any}","page":"API","title":"QuantumPropagators.cheby!","text":"Evaluate Ψ = exp(-i H dt) Ψ in-place.\n\nArgs:\n\nΨ: on input, initial vector. Will be overwritten with result.\nH: Hermitian operator\ndt: time step\nE_min: minimum eigenvalue of H, to be used instead of the E_min from the  initialization of wrk. The same wrk may be used for different values  E_min, as long as the spectra radius Δ and the time step dt are the  same as those used for the initialization of wrk.\n\nThe routine will not allocate any internal storage. This implementation requires copyto! lmul!, and axpy! to be implemented for Ψ, and the three-argument mul! for Ψ and H.\n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumPropagators.cheby_coeffs!-Tuple{Any, Any, Any}","page":"API","title":"QuantumPropagators.cheby_coeffs!","text":"Calculate Chebychev coefficients in-place.\n\nWrites the coefficients into coeffs. Returns the number n of coefficients required for convergence, or the size of coeffs, whichever is less.\n\ncoeffs: An array to hold the Chebychev cofficients. On output, the elements  1 through n will hold the calculated coefficients, while the remaining  elements will be unchanged\ndt: the time step\n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumPropagators.cheby_coeffs-Tuple{Any, Any}","page":"API","title":"QuantumPropagators.cheby_coeffs","text":"Calculate Chebychev coefficients.\n\nReturn an array of coefficiencts larger than limit.\n\nArgs:\n\nΔ: the spectral radius of the underlying operator\ndt: the time step\n\n\n\n\n\n","category":"method"},{"location":"api/#Newton-reference","page":"API","title":"Newton reference","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"The following routines implement time propagation via expansion in Newton polynomials using a restarted Arnoldi scheme to determine evaluation points.","category":"page"},{"location":"api/#Public-members","page":"API","title":"Public members","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Modules = [QuantumPropagators]\nPages = [\"newton.jl\"]\nPublic = true\nPrivate = false","category":"page"},{"location":"api/#QuantumPropagators.NewtonWrk","page":"API","title":"QuantumPropagators.NewtonWrk","text":"    NewtonWrk(v0, m_max=10)\n\nWorkspace for the Newton-with-restarted-Arnoldi propagation routine.\n\nInitializes the workspace for the propagation of a vector v0, using a maximum Krylov dimension of m_max in each restart iteration. Note that m_max should be smaller than the length of v0.\n\n\n\n\n\n","category":"type"},{"location":"api/#QuantumPropagators.newton!","page":"API","title":"QuantumPropagators.newton!","text":"newton!(Ψ, H, dt, wrk, func=(z -> exp(-1im*z)); norm_min=1e-14, relerr=1e-12,\n        max_restarts=50)\n\nEvaluate Ψ = func(H*dt) Ψ using a Newton-with-restarted-Arnoldi scheme.\n\nArguments\n\nΨ: The state to propagate, will be overwritten in-place with the propagated state\nH: Operator acting on Ψ. Together with dt, this is the argument to func\ndt: Implicit time step. Together with H, this is the argument to func\nwkr: Work array, initialized with NewtonWrk\nfunc: The function to apply to H dt, taking a single (scalar) complex-valued argument z in place of H dt. The default func is to evaluate the time evoluation operator for the Schrödinger equation\nnorm_min: the minium norm at which to consider a state similar to Ψ as zero\nrelerr: The relative error defining the convergence condition for the restart iteration. Propagation stops when the norm of the accumulated Ψ is stable up to the given relative error\nmax_restart: The maximum number of restart iterations. Exceeding max_restart will throw an AssertionError.\n\n\n\n\n\n","category":"function"},{"location":"api/#Private-members","page":"API","title":"Private members","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Modules = [QuantumPropagators]\nPages = [\"newton.jl\"]\nPublic = false\nPrivate = true","category":"page"},{"location":"api/#QuantumPropagators.arnoldi!-Union{Tuple{T}, Tuple{Matrix{ComplexF64}, Array{T, N} where N, Int64, T, Any}, Tuple{Matrix{ComplexF64}, Array{T, N} where N, Int64, T, Any, Float64}} where T","page":"API","title":"QuantumPropagators.arnoldi!","text":"arnoldi!(Hess, q, m, Ψ, H, dt=1.0; extended=true, norm_min=1e-15)\n\nCalculate the Hessenberg matrix and Arnoldi vectors of H dt, from Ψ.\n\nFor a given order m, the m×m Hessemberg matrix is calculated and stored in in the pre-allocated Hess. Further  an array of m normalized Arnoldi vectors is stored in in the pre-allocated q, plus one additional unnormalized Arnoldi vector.  The unnormalized m+1st vector could be used to easily extend a given m×m Hessenberg matrix to a (m+1)×(m+1) matrix.\n\nIf the extended Hessenberg matrix is requested (extended=true, default), the m+1st Arnoldi vector is also normalized, and it's norm will be stored in m+1, m entry of the (extended) Hessenberg matrix, which is an (m+1)×(m+1) matrix.\n\nReturn the size m of the calculated Hessenberg matrix. This will usually be the input m, except when the Krylov dimension of H starting from Ψ is less then m. E.g., if Ψ is an eigenstate of H, the returned m will be 1.\n\nSee http://en.wikipedia.org/wiki/Arnoldi_iteration for a description of the algorithm.\n\nArguments\n\nHess::Matrix{ComplexF64}: Pre-allocated storage for the Hessemberg matrix.  Can be uninitialized on input. The matrix must be at least of size m×m, or  (m+1)×(m+1) if extended=true. On output, the m×m sub-matrix of Hess  (with the returned output m) will contain the Hessenberg matrix, and all  other elements of Hess be be set to zero.\nq: Pre-allocated array of states similar to Ψ, as storage for the calculated Arnoldi vectors. These may be un-initialized on input. Must be at least of length m+1\nm: The requested dimensions of the output Hessenberg matrix.\nΨ: The starting vector for the Arnoldi procedure. This can be of any type,  as long as Φ = H * Ψ results in a vector similar to Ψ, there is an inner  products of Φ and Ψ (Ψ⋅Φ is defined), and norm(Ψ) is defined.\nH: The operator (up to dt) for which to calculate the Arnoldi procedure. Can be of any type, as long as H * Ψ is defined.\ndt: The implicit time step; the total operator for which to calculate the Arnoldi procedure is H * dt\nextended: If true (default), calculate the extended Hessenberg matrix, and normalized the final Arnoldi vector\nnorm_min: the minimum value of the norm of Ψ at which Ψ should be  considered the zero vector\n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumPropagators.diagonalize_hessenberg_matrix-Tuple{Any, Any}","page":"API","title":"QuantumPropagators.diagonalize_hessenberg_matrix","text":"diagonalize_hessenberg_matrix(Hess, m; accumulate=false)\n\nDiagonalize the m × m top left submatrix of the given Hessenberg matrix.\n\nIf accumulate is true, return the concatenated eigenvalues for Hess[1:1,1:1] to Hess[1:m,1:m], that is, all sumatrices of size 1 through m.\n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumPropagators.extend_leja!-Tuple{OffsetArrays.OffsetVector{ComplexF64, AA} where AA<:AbstractVector{ComplexF64}, Any, OffsetArrays.OffsetVector{ComplexF64, AA} where AA<:AbstractVector{ComplexF64}, Any}","page":"API","title":"QuantumPropagators.extend_leja!","text":"extend_leja!(leja, n, newpoints, n_use)\n\nGiven an array of n (ordered) Leja points, extract n_use points from newpoints, and append them to the existing Leja points. The array leja should be sufficiently large to hold the new Leja points, which are appended after index n_old. It will be re-allocated if necessary and may have a size of up to 2*(n+n_use).\n\nArguments\n\nleja: Array of leja values. Must contain the \"old\" leja values to be kept  in leja(0:n-1). On output, n_use new leja points will be in  leja(n+:n+n_use-1), for the original value of n.  The leja array must  use zero-based indexing.\nn: On input, number of \"old\" leja points in leja. On output, total number of leja points (i.e. n=n+n_use)\nnewpoints: On input, candidate points for new leja points.  The n_use best values will be chosen and added to leja. On output, the values of new_points are undefined.\nn_use: Number of points that should be added to leja\n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumPropagators.extend_newton_coeffs!-Tuple{OffsetArrays.OffsetVector{ComplexF64, AA} where AA<:AbstractVector{ComplexF64}, Int64, OffsetArrays.OffsetVector{ComplexF64, AA} where AA<:AbstractVector{ComplexF64}, Any, Int64, Float64}","page":"API","title":"QuantumPropagators.extend_newton_coeffs!","text":"extend_newton_coeffs!(a, n_a, leja, func, n_leja, radius)\n\nExtend the array a of existing Newton coefficients for the expansion of the func from n_a coefficients to n_leja coefficients. Return a new value n_a=n_a+n_leja with the total number of Newton coefficients in the updated a.\n\nArguments\n\na: On input, a zero-based array of length n_a or greater, containing Newton coefficients. On output, array containing a total n_leja coefficients. The array a will be resized if necessary, and may have a length greater than n_leja on output\nn_a:  The number of Newton coefficients in a, on input. Elements of a  beyond the first n_a elements will be overwritten.\nleja: Array of normalized Leja points, containing at least n_leja elements.\nfunc: Function for which to calcluate Newton coeffiecients\nn_leja: The number of elements in leja to use for calculating new coefficients, and the total number of Newton coefficients on output\nradius: Normalization radius for divided differences\n\n\n\n\n\n","category":"method"},{"location":"api/#Matrix-exponentiation-reference","page":"API","title":"Matrix exponentiation reference","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"The following routines implement time propagation via explicit exponentiation of the dynamical generator.","category":"page"},{"location":"api/","page":"API","title":"API","text":"Modules = [QuantumPropagators]\nPages = [\"expprop.jl\"]\nPublic = true\nPrivate = false","category":"page"},{"location":"api/#QuantumPropagators.ExpPropWrk","page":"API","title":"QuantumPropagators.ExpPropWrk","text":"    ExpPropWrk(v0)\n\nWorkspace for propagation via direct matrix exponentiation.\n\nInitializes the workspace for the propagation of a vector v0\n\n\n\n\n\n","category":"type"},{"location":"api/#QuantumPropagators.expprop!","page":"API","title":"QuantumPropagators.expprop!","text":"expprop!(Ψ, H, dt, wrk, func=(z -> exp(-1im*z)))\n\nEvaluate Ψ = func(H*dt) Ψ by directly evaluating U = func(H*dt), i.e. by matrix exponentiation for the default func, and then multiplying U and Ψ in-place with mul!.\n\nThe workspace wrk must be initialized with ExpPropWrk to provide storage for a temporary state.\n\n\n\n\n\n","category":"function"},{"location":"api/#Index","page":"API","title":"Index","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"","category":"page"},{"location":"howto/#Howtos","page":"Howtos","title":"Howtos","text":"","category":"section"},{"location":"howto/","page":"Howtos","title":"Howtos","text":"TODO","category":"page"},{"location":"overview/#Overview","page":"Overview","title":"Overview","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"TODO","category":"page"},{"location":"background/#Background","page":"Background","title":"Background","text":"","category":"section"},{"location":"background/#Chebychev-Propagation","page":"Background","title":"Chebychev Propagation","text":"","category":"section"},{"location":"background/","page":"Background","title":"Background","text":"TODO","category":"page"},{"location":"background/#Newton-Propagation","page":"Background","title":"Newton Propagation","text":"","category":"section"},{"location":"background/","page":"Background","title":"Background","text":"TODO","category":"page"},{"location":"background/#Propagation-with-Explicit-Matrix-Exponentiation","page":"Background","title":"Propagation with Explicit Matrix Exponentiation","text":"","category":"section"},{"location":"background/","page":"Background","title":"Background","text":"TODO","category":"page"},{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"TODO","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Pages=[\n    \"1.md\",\n    \"2.md\",\n]\nDepth = 1","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = QuantumPropagators","category":"page"},{"location":"#QuantumPropagators","page":"Home","title":"QuantumPropagators","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for QuantumPropagators.","category":"page"},{"location":"#Contents","page":"Home","title":"Contents","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages=[\n \"overview.md\",\n \"background.md\",\n \"examples/index.md\",\n \"howto.md\",\n \"benchmarks.md\",\n \"api.md\",\n]\nDepth = 2","category":"page"}]
}
