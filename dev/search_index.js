var documenterSearchIndex = {"docs":
[{"location":"benchmarks/#Benchmarks","page":"Benchmarks","title":"Benchmarks","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"TODO","category":"page"},{"location":"howto/#Howtos","page":"Howtos","title":"Howtos","text":"","category":"section"},{"location":"howto/#How-to-extend-QuantumPropagators-with-a-new-propagation-method","page":"Howtos","title":"How to extend QuantumPropagators with a new propagation method","text":"","category":"section"},{"location":"howto/","page":"Howtos","title":"Howtos","text":"Define a new sub-type of AbstractPropagator type that is unique to the propagation method, e.g. MyNewMethodPropagator. If appropriate, sub-type PiecewisePropagator or PWCPropagator.\nChoose a name for the propagation method, e.g. mynewmethod and implement a new initprop method with the following signature\nfunction initprop(\n    state,\n    generator,\n    tlist,\n    method::Val{:mynewmethod};\n    inplace=true,\n    backward=false,\n    verbose=false,\n    parameters=nothing,\n    # ... method-specific keyword arguments\n    _...  # ignore other keyword arguments\n)\nNote the method::Val{:mynewmethod} as the fourth positional parameter. While the public interface for initprop takes method as a keyword argument, privately initprop dispatches for different methods as above.\nImplement the remaining methods in The Propagator interface","category":"page"},{"location":"storage/#Storage-of-states-or-expectation-values","page":"Storage","title":"Storage of states or expectation values","text":"","category":"section"},{"location":"storage/","page":"Storage","title":"Storage","text":"The propagate routine allows the storage of data for every point of the time grid.  This is done by passing it a storage object created with init_storage, or simply storage=true in order to create the appropriate storage automatically.","category":"page"},{"location":"storage/","page":"Storage","title":"Storage","text":"By default, the storage will be used to store the propagated states at each point in time. More generally, what goes into storage can be customized via the observables parameter of propagate.","category":"page"},{"location":"storage/","page":"Storage","title":"Storage","text":"After each propagation step, with a propagate state at time slot i,","category":"page"},{"location":"storage/","page":"Storage","title":"Storage","text":"QuantumPropagators.Storage.map_observables generates data from the propagated state\nQuantumPropagators.Storage.write_to_storage! places that data into storage for time slot i","category":"page"},{"location":"storage/","page":"Storage","title":"Storage","text":"After propagate returns, the get_from_storage! routine can be used to extract data from any time slot. This interface hides the internal memory organization of storage, which is set up by init_storage based on the type of state and the given observables. This system can can extended with multiple dispatch, allowing to optimize the storage for custom data types. Obviously, init_storage, map_observables, write_to_storage!, and get_from_storage! must all be consistent.","category":"page"},{"location":"storage/","page":"Storage","title":"Storage","text":"The default implementation of these routine uses either a standard Vector or a Matrix as storage.","category":"page"},{"location":"storage/","page":"Storage","title":"Storage","text":"Roughly speaking, when storing states, if the state of some arbitrary type, the storage will be a Vector where the i'th entry points to a copy of the propagated state at the i'th time slot. If the state is a Vector, the storage will be a Matrix containing the state for the i'th time slot in the i'th column.","category":"page"},{"location":"storage/","page":"Storage","title":"Storage","text":"When a tuple of observables is passed to propagate, if map_observables returns data of the same type for each observable, storage will be a Matrix containing the values from the different observables for the i'th time slot in the i'th column. This would be typical for the storage of expectation values, e.g. with","category":"page"},{"location":"storage/","page":"Storage","title":"Storage","text":"observables=(state->dot(state, Ô₁, state), state->dot(state, Ô₂, state))","category":"page"},{"location":"storage/","page":"Storage","title":"Storage","text":"where Ô₁, Ô₂ are two Hermitian operators. In this case, storage would be a 2 × nt Float64 array. Calling get_from_storage!(data, storage, i) would be equivalent to copyto!(data, storage[:,i]) and extract the i'th column of storage, i.e. the vector [⟨Ô₁⟩, ⟨Ô₂A]⟩] at time slot i. Alternatively, storage[1,:] would return the values of ⟨Ô₁⟩ over time. This would be useful for plotting, and illustrates the benefits of using a Matrix as storage.","category":"page"},{"location":"storage/","page":"Storage","title":"Storage","text":"Usually, the observables should be functions acting on the state, but map_observables can be extended to other types of observables as well. For example, the situation were state is a vector and the observables are matrices is also supported; if  Ô₁, Ô₂ are matrices,","category":"page"},{"location":"storage/","page":"Storage","title":"Storage","text":"observables=(Ô₁, Ô)","category":"page"},{"location":"storage/","page":"Storage","title":"Storage","text":"would have the same result of storing the expectation values of those two operators.","category":"page"},{"location":"storage/","page":"Storage","title":"Storage","text":"The observables are not required to yield real values: the term \"observables\" is used very loosely here. We could directly calculate, e.g., the complex amplitude α of a coherent state in quantum optics, the number of levels with non-zero population (as an integer), or the propagated state transformed from a moving frame to a lab frame.","category":"page"},{"location":"storage/","page":"Storage","title":"Storage","text":"If there are multiple observables that return data of different types, by default storage will be a Vector that contains tuples with the result for each observable. For example, with","category":"page"},{"location":"storage/","page":"Storage","title":"Storage","text":"observables=(state->dot(state, Ô₁, state), state->count_poplevels(state))","category":"page"},{"location":"storage/","page":"Storage","title":"Storage","text":"where count_poplevels is a function that counts the number of levels with non-zero population, the resulting storage would be a Vector{Tuple{Float64, Int64}}.","category":"page"},{"location":"storage/","page":"Storage","title":"Storage","text":"If there is a single observable that yields a vector, that vector is stored in the i'th column of a storage matrix. This is in fact what happens when storing the propagated states (observables=(Ψ->copy(Ψ), )) if Ψ is a Vector, but there are other use cases, such as calculating the population in all levels in one go, with observables=(Ψ -> abs.(Ψ).^2, ).","category":"page"},{"location":"storage/","page":"Storage","title":"Storage","text":"If there is a single variable that yields a non-vector object, storage will be a Vector where the i'th entry points to the object. This is in fact what happens by default when storing states  that are e.g. instances of QuantumOptics.Ket. In such a case, it might be advisable to add new methods for QuantumPropagators.Storage.init_storage and QuantumPropagators.Storage.write_to_storage! that implement a more efficient in-place storage.","category":"page"},{"location":"api/quantumpropagators/","page":"API","title":"API","text":"EditURL = \"../../generate_api.jl\"","category":"page"},{"location":"api/quantumpropagators/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/quantumpropagators/#QuantumPropagatorsAPI","page":"API","title":"QuantumPropagators","text":"","category":"section"},{"location":"api/quantumpropagators/","page":"API","title":"API","text":"The highest-level API of the QuantumPropagators.jl package consists of a single function:","category":"page"},{"location":"api/quantumpropagators/","page":"API","title":"API","text":"propagate — Propagate a quantum state over an entire time grid under a given generator","category":"page"},{"location":"api/quantumpropagators/","page":"API","title":"API","text":"At a slightly lower level, propagation of quantum states in encapsulated by The Propagator interface:","category":"page"},{"location":"api/quantumpropagators/","page":"API","title":"API","text":"initprop — Initialize a propagator object, which is of some concrete (method-dependent) sub-type of AbstractPropagator\nreinitprop! — Re-initialize the propagator\npropstep! — Advance the propagator  by a single time step forward or backward\nset_state! — Mutate the current quantum state of the propagator.\nset_t! — Mutate the current time of the propagator (not exported)","category":"page"},{"location":"api/quantumpropagators/","page":"API","title":"API","text":"The dynamics of a quantum state are determined by a time-dependent dynamical generator (a Hamiltonian or Liouvillian). The QuantumPropagators package re-exports the two main initialization routines for generators from QuantumPropagators.Generators:","category":"page"},{"location":"api/quantumpropagators/","page":"API","title":"API","text":"hamiltonian — Construct a time-dependent generator for a propagation in Hilbert space under the Schrödinger equation\nliouvillian — Construct a time-dependent generator for a propagation in Liouville space under the master equation in Lindblad form","category":"page"},{"location":"api/quantumpropagators/","page":"API","title":"API","text":"To support the storage feature of propagate, the following routines from the Storage sub-module are re-exported in QuantumPropagators:","category":"page"},{"location":"api/quantumpropagators/","page":"API","title":"API","text":"init_storage – Create a storage array for propagated states or expectation values\nwrite_to_storage! – Place data into storage\nget_from_storage! – Obtain data from storage (in-place)","category":"page"},{"location":"api/quantumpropagators/","page":"API","title":"API","text":"The above list of methods constitutes the entire public interface of QuantumPropagators. At the lowest level, further functionality is provided by sub-modules like QuantumPropagators.Cheby, which defines a standalone API specifically for the Chebychev propagation method.","category":"page"},{"location":"api/quantumpropagators/","page":"API","title":"API","text":"The full list of sub-modules is","category":"page"},{"location":"api/quantumpropagators/","page":"API","title":"API","text":"QuantumPropagators.Generators\nQuantumPropagators.Shapes\nQuantumPropagators.Controls\nQuantumPropagators.Amplitudes\nQuantumPropagators.Storage\nQuantumPropagators.Cheby\nQuantumPropagators.Newton\nQuantumPropagators.ExpProp\nQuantumPropagators.SpectralRange\nQuantumPropagators.Arnoldi","category":"page"},{"location":"api/quantumpropagators/#Reference","page":"API","title":"Reference","text":"","category":"section"},{"location":"api/quantumpropagators/","page":"API","title":"API","text":"Public Members:","category":"page"},{"location":"api/quantumpropagators/","page":"API","title":"API","text":"initprop\npropagate\npropstep!\nreinitprop!\nset_state!","category":"page"},{"location":"api/quantumpropagators/","page":"API","title":"API","text":"Re-exported Members:","category":"page"},{"location":"api/quantumpropagators/","page":"API","title":"API","text":"get_from_storage!\nhamiltonian\ninit_storage\nliouvillian\nwrite_to_storage!","category":"page"},{"location":"api/quantumpropagators/","page":"API","title":"API","text":"Private Members:","category":"page"},{"location":"api/quantumpropagators/","page":"API","title":"API","text":"cheby_get_spectral_envelope\nset_t!\nchoose_propmethod\nNewtonPropagator\nExpPropagator\nPiecewisePropagator\nChebyPropagator\nAbstractPropagator\nPWCPropagator","category":"page"},{"location":"api/quantumpropagators/#Public-members","page":"API","title":"Public members","text":"","category":"section"},{"location":"api/quantumpropagators/","page":"API","title":"API","text":"QuantumPropagators.initprop\nQuantumPropagators.propagate\nQuantumPropagators.propstep!\nQuantumPropagators.reinitprop!\nQuantumPropagators.set_state!","category":"page"},{"location":"api/quantumpropagators/#QuantumPropagators.initprop","page":"API","title":"QuantumPropagators.initprop","text":"Initialize a Propagator.\n\npropagator = initprop(\n    state, generator, tlist;\n    method=:auto,\n    backward=false,\n    inplace=true,\n    piecewise=nothing,\n    pwc=nothing,\n    kwargs...\n)\n\ninitializes a propagator for the time propagation of the given state over a time grid tlist under the time-dependent generator (Hamiltonian/Liouvillian) generator.\n\nArguments\n\nstate: The \"initial\" state for the propagation. For backward=false, this state is taken to be at initial time (tlist[begin]); and for backward=true, at the final time (tlist[end])\ngenerator: The time-dependent generator of the dynamics\ntlist: The time grid over which which the propagation is defined. This may or may not be equidistant.\n\nKeyword arguments\n\nmethod: The propagation method to use. The default value of :auto attempts to choose the best method available, based on the properties of the given state, tlist, and generator, cf. choose_propmethod\nbackward: If true, initialize the propagator for a backward propagation. The resulting propagator.t will be tlist[end], and subsequent calls to propstep! will move backward on tlist.\ninplace: If true, the state property of the resulting propagator will be changed in-place by any call to propstep!. If false, each call to propstep! changes the reference for propgator.state, and the progation will not use any in-place operations. Not all propagation methods may support both in-place and not-in-place propagation. In-place propagation is generally more efficient but may not be compatible, e.g., with automatic differentiation.\npiecewise: If given a a boolean, true enforces that the resulting propagator is a PiecewisePropagator, and false enforces is not to be a PiecewisePropagator\npwc: Like piecewise, for for the stronger PWCPropagator\n\nAll other kwargs are method-dependent and are ignored for methods that do not support them.\n\nThe type of the returned propagator is a sub-type of AbstractPropagator, respectively a sub-type of PiecewisePropagator if piecewise=true or a sub-type of PWCPropagator if pwc=true.\n\nSee also\n\nreinitprop! — Re-initialize a propagator\npropagate — Higher-level propagation interface\n\n\n\n\n\ncheby_propagator = initprop(\n    state,\n    generator,\n    tlist;\n    method=:cheby,\n    inplace=true,\n    backward=false,\n    verbose=false,\n    parameters=nothing,\n    control_ranges=nothing,\n    specrange_method=:auto,\n    specrange_buffer=0.01,\n    cheby_coeffs_limit=1e-12,\n    check_normalization=false,\n    specrange_kwargs...\n)\n\ninitializes a ChebyPropagator.\n\nMethod-specific keyword arguments\n\ncontrol_ranges: a dict the maps the controls in generator (see getcontrols) to a tuple of min/max values. The Chebychev coefficients will be calculated based on a spectral envelope that assumes that each control can take arbitrary values within the min/max range. If not given, the ranges are determined automatically. Specifying manual control ranges can be useful when the the control amplitudes (parameters) may change during the propagation, e.g. in a sequential-update control scheme.\nspecrange_method: Method to pass to the specrange function\nspecrange_buffer: An additional factor by which to enlarge the estimated  spectral range returned by specrange, in order to ensure that Chebychev coefficients are based on an overestimation of the spectral range.\ncheby_coeffs_limit: The maximum magnitude of Chebychev coefficients that should be treated as non-zero\ncheck_normalization: Check whether the Hamiltonian has been properly normalized, i.e., that the spectral range of generator has not been underestimated. This slowes down the propagation, but is advisable for novel generators.\nspecrange_kwargs: All further keyword arguments are passed to the specrange function\n\n\n\n\n\nnewton_propagator = initprop(\n    state,\n    generator,\n    tlist,\n    method::Val{:newton};\n    inplace=true,\n    backward=false,\n    verbose=false,\n    parameters=nothing,\n    m_max=10,\n    func=(z -> exp(-1im * z)),\n    norm_min=1e-14,\n    relerr=1e-12,\n    max_restarts=50,\n    _...\n)\n\ninitializes a NewtonPropagator.\n\nMethod-specific keyword arguments\n\nm_max: maximum Krylov dimension, cf. NewtonWrk\nfunc, norm_min, relerr, max_restarts: parameter to pass to newton!\n\n\n\n\n\nexp_propagator = initprop(\n    state,\n    generator,\n    tlist,\n    method::Val{:expprop};\n    inplace=true,\n    backward=false,\n    verbose=false,\n    parameters=nothing,\n    func=(H_dt -> exp(-1im * H_dt))\n    convert_state=_exp_prop_convert_state(state),\n    convert_operator=_exp_prop_convert_operator(generator),\n    _...\n)\n\ninitializes an ExpPropagator.\n\nMethod-specific keyword arguments\n\nfunc: The function to evaluate. The argument H_dt is obtained by constructing an operator H from generator via the evalcontrols function and the multiplied with the time step dt for the current time interval. The propagation then simply multiplies the return value of func with the current state\nconvert_state:  Type to which to temporarily convert states before multiplying the return value of func.\nconvert_operator: Type to which to convert the operator H before multiplying it with dt and plugging the result into func\n\nThe convert_state and convert_operator parameters are useful for when the generator and or state are unusual data structures for which the relevant methods to calculate func are not defined. Often, it is easier to temporarily convert them to standard complex matrices and vectors than to implement the missing methods.\n\n\n\n\n\n","category":"function"},{"location":"api/quantumpropagators/#QuantumPropagators.propagate","page":"API","title":"QuantumPropagators.propagate","text":"Propagate a state over an entire time grid.\n\nstate = propagate(\n    state,\n    generator,\n    tlist;\n    method=:auto,\n    backward=false,\n    inplace=true,\n    verbose=false,\n    piecewise=nothing,\n    pwc=nothing,\n    storage=nothing,\n    observables=(<store state>, ),\n    callback=nothing,\n    showprogress=false,\n    initprop_kwargs...)\n\npropagates state of the entire time grid and returns the propagates states, or a storage array of data collected during the propagation.\n\nArguments\n\nstate: The \"initial\" state for the propagation. For backward=false, this state is taken to be at initial time (tlist[begin]); and for backward=true, at the final time (tlist[end])\ngenerator: The time-dependent generator of the dynamics\ntlist: The time grid over which which the propagation is defined. This may or may not be equidistant.\n\nKeyword arguments\n\nmethod: The propagation method to use. The default value of :auto attempts to choose the best method available, based on the properties of the given state, tlist, and generator.\nbackward: If true, propagate backward in time\ninplace: If true, propagate using in-place operations. If false, avoid in-place operations. Not all propagation methods support both in-place and not-in-place propagation.\npiecewise: If given a a boolean, limit the propagation to \"piecewise\" methods, respectively disallow piecewise methods\npwc: If given a a boolean, limit the propagation to piecewise-constant methods, respectively disallow piecewise-constant methods\nstorage: Flag whether to store and return the propagated states / observables, or pre-allocated storage array. See Notes below.\nobservables: Converters for data to be stored in storage. See Notes below.\ncallback: Function to call after each propagation step. See Notes below.\nshowprogess: Whether to show a progress bar. See Notes below.\n\nAll remaining keyword arguments are passed to initprop to initialize the Propagator that is used internally to drive the optimization. Unknown keyword arguments will be ignored.\n\nNotes\n\nIn general, there is no requirement that tlist has a constant time step, although some propagation methods (most notably cheby!) only support a uniform time grid.\n\nIf storage is given as an Array, it will be filled with data determined by the observables. The default \"observable\" results in the propagated states at every point in time being stored. The storage array should be created with init_storage. See its documentation for details.\n\nThe storage parameter may also be given as true, and a new storage array will be created internally with init_storage and returned instead of the propagated state:\n\ndata = propagate(\n    state, generator, tlist; method=:auto\n    backward=false; storage=true, observables=observables,\n    callback=nothing, showprogress=false, kwargs...)\n\nIf backward is true, the input state is assumed to be at time tlist[end], and the propagation progresses backward in time (with a negative time step dt). If storage is given, it will be filled back-to-front during the backward propagation.\n\nIf callback is given as a callable, it will be called after each propagation step, as callback(propagator, observables) where propagator is Propagator object driving the propagation. The callback is called before calculating any observables. Example usage includes writing data to file, or modifying state via set_state!, e.g., removing amplitude from the lowest and highest level to mitigate \"truncation error\".\n\nIf showprogress is given as true, a progress bar will be shown for long-running propagationn. In order to customize the progress bar, showprogress may also be a function that receives length(tlist) and returns a ProgressMeter.Progress instance.\n\nIf in_place=false is given, the propagation avoids in-place operations. This is slower than inplace=true, but is often required in the context of automatic differentiation (AD), e.g., with Zygote. That is, use in_place=false if propagate is called inside a function to be passed to Zygote.gradient, Zygote.pullback, or a similar function. In an AD context, storage and showprogress should not be used.\n\nThe propagate routine returns the propagated state at tlist[end], respectively tlist[1] if backward=true, or a storage array with the stored states / observable data if storage=true.\n\nSee also\n\ninitprop — Propagate via a Propagator object\n\n\n\n\n\n","category":"function"},{"location":"api/quantumpropagators/#QuantumPropagators.propstep!","page":"API","title":"QuantumPropagators.propstep!","text":"Advance the propagator by a single time step.\n\nstate = propstep!(propagator)\n\nreturns the state obtained from propagating to the next point on the time grid from propagator.t, respectively the previous point if propagator.backward is true.\n\nWhen the propagation would lead out of the time grid, propstep! leaves propagator unchanged and returns nothing. Thus, a return value of nothing may be used to signal that a propagation has completed.\n\n\n\n\n\n","category":"function"},{"location":"api/quantumpropagators/#QuantumPropagators.reinitprop!","page":"API","title":"QuantumPropagators.reinitprop!","text":"Re-initialize a propagator.\n\nreinitprop!(propagator, state; kwargs...)\n\nresets the propagator to state at the beginning of the time grid, respectively the end of the time grid if propagator.backward is true.\n\nAt a minimum, this is equivalent to a call to set_state! follow by a call to set_t!, but some propagators may have additional requirements on re-initialization, such as refreshing expansion coefficients for ChebyPropagator. In this case, the kwargs may be additional keyword arguments specific to the concrete type of propagator.\n\n\n\n\n\nreinitprop!(\n    propagator::ChebyPropagator,\n    state;\n    transform_control_ranges=((c, ϵ_min, ϵ_max, check) => (ϵ_min, ϵ_max)),\n    kwargs...\n)\n\nre-initializes an existing ChebyPropagator. This may or may not involve recalculating the Chebychev coefficients based on the current control amplitudes in propagator.parameters.\n\nMethod-specific keyword arguments\n\ntransform_control_ranges: a function (c, ϵ_min, ϵ_max, check) => (ϵ_min′, ϵ_max′). For each control c, the function is called with check=true and ϵ_min (ϵ_max) the current minimum (maximum) values for the control from propagator.parameters). The Chebychev coefficients will be recalculated if the existing coefficients were obtained assuming a range for c outside the returned ϵ_min′, ϵ_max′.\nIf the coefficients do need to be recalculated, transform_control_ranges is called a second time with check=false, and the returned (ϵ_min′, ϵ_max′) are used for estimating the new spectral range.\nFor example,\nfunction transform_control_ranges(c, ϵ_min, ϵ_max, check)\n    if check\n        return (min(ϵ_min, 2 * ϵ_min), max(ϵ_max, 2 * ϵ_max))\n    else\n        return (min(ϵ_min, 5 * ϵ_min), max(ϵ_max, 5 * ϵ_max))\n    end\nend\nwill re-calculate the Chebychev coefficients only if the current amplitudes differ by more than a factor of two from the ranges that were used when initializing the propagator (control_ranges parameter in initprop, which would have had to overestimate the actual amplitudes by at least a factor of two).  When re-calculating, the control_ranges will overestimate the amplitudes by a factor of five. With this transform_control_ranges, the propagation will be stable as long as the amplitudes do not change dynamically by more than a factor of 2.5 from their original range, while also not re-calculating coefficients unnecessarily in each pass because of modest changes in the amplitudes.\nThe transform_control_ranges argument is only relevant in the context of optimal control, where the same propagator will be used for many iterations with changing control field amplitudes.\n\nAll other keyword arguments are ignored.\n\n\n\n\n\n","category":"function"},{"location":"api/quantumpropagators/#QuantumPropagators.set_state!","page":"API","title":"QuantumPropagators.set_state!","text":"Set the current state of the propagator.\n\nset_state!(propagator, state)\n\nsets the propagator.state property. In order to mutate the current state after a call to propstep!, the following pattern is recommended:\n\nΨ = propagator.state\nmutate!(Ψ)\nset_state!(propagator, Ψ)\n\nThis is guaranteed to work efficiently both for in-place and not-in-place propagators, without incurring unnecessary copies.\n\nwarning: Warning\nmutate!(propagator.state)by itself is not a safe operation. Always follow it byset_state!(propagator, propagator.state)\n\nSee also\n\nset_t! — set propagator.t.\n\n\n\n\n\n","category":"function"},{"location":"api/quantumpropagators/#Private-members","page":"API","title":"Private members","text":"","category":"section"},{"location":"api/quantumpropagators/","page":"API","title":"API","text":"QuantumPropagators.cheby_get_spectral_envelope\nQuantumPropagators.set_t!\nQuantumPropagators.choose_propmethod\nQuantumPropagators.NewtonPropagator\nQuantumPropagators.ExpPropagator\nQuantumPropagators.PiecewisePropagator\nQuantumPropagators.ChebyPropagator\nQuantumPropagators.AbstractPropagator\nQuantumPropagators.PWCPropagator","category":"page"},{"location":"api/quantumpropagators/#QuantumPropagators.cheby_get_spectral_envelope","page":"API","title":"QuantumPropagators.cheby_get_spectral_envelope","text":"Determine the spectral envelope of a generator.\n\nE_min, E_max = cheby_get_spectral_envelope(\n    generator, tlist, control_ranges, method; kwargs...\n)\n\nestimates a lower bound E_min the lowest eigenvalue of the generator for any values of the controls specified by control_ranges, and an upper bound E_max for the highest eigenvalue.\n\nThis is done by constructing operators from the extremal values for the controls as specified in control_ranges and taking the smallest/largest return values from specrange for those operators.\n\nArguments\n\ngenerator: dynamical generator, e.g. a time-dependent\ntlist: The time grid for the propagation\ncontrol_ranges: a dict that maps controls that occur in generator (cf. getcontrols to a tuple of mimimum and maximum amplitude for that control\nmethod: method name to pass to  specrange\nkwargs: Any remaining keyword arguments are passed to specrange\n\n\n\n\n\n","category":"function"},{"location":"api/quantumpropagators/#QuantumPropagators.set_t!","page":"API","title":"QuantumPropagators.set_t!","text":"Set the current time for the propagation.\n\nset_t!(propagator, t)\n\nSets propagator.t to the given value of t, where t must be an element of propagator.tlist.\n\nSee also\n\nset_state! — set propagator.state\n\n\n\n\n\n","category":"function"},{"location":"api/quantumpropagators/#QuantumPropagators.choose_propmethod","page":"API","title":"QuantumPropagators.choose_propmethod","text":"Choose a suitable propagation method.\n\nmethod = choose_propmethod(generator, state, tlist;\n                           pwc=nothing, piecewise=nothing, inplace=true)\n\nidentifies a suitable propagation method for the given generator, state and tlist. If piecewise or pwc are given as true, only consider methods that result in in a PiecewisePropagator or PWCPropagator, respectively. If piecewise or pwc are given as false, disregard any methods that result in these propagators. Only propagators that support the given inplace are taken into account.\n\n\n\n\n\n","category":"function"},{"location":"api/quantumpropagators/#QuantumPropagators.NewtonPropagator","page":"API","title":"QuantumPropagators.NewtonPropagator","text":"Propagator for Newton propagation (method=:newton).\n\nThis is a PWCPropagator.\n\n\n\n\n\n","category":"type"},{"location":"api/quantumpropagators/#QuantumPropagators.ExpPropagator","page":"API","title":"QuantumPropagators.ExpPropagator","text":"Propagator for propagation via direct exponentiation (method=:expprop)\n\nThis is a PWCPropagator.\n\n\n\n\n\n","category":"type"},{"location":"api/quantumpropagators/#QuantumPropagators.PiecewisePropagator","page":"API","title":"QuantumPropagators.PiecewisePropagator","text":"AbstractPropagator sub-type for piecewise propagators.\n\nA piecewise propagator is determined by a single parameter per control and time grid interval. Consequently, the propagator.parameters are a dictionary mapping the controls found in the generator via getcontrols to a vector of values defined on the intervals of the time grid, see discretize_on_midpoints. This does not necessarily imply that these values are the piecewise-constant amplitudes for the intervals. A general piecwise propagatore might use interpolation to obtain actual amplitudes within any given time interval.\n\nWhen the amplitudes are piecewise-constant, the propagator should be a concrete intantiation of a PWCPropagator.\n\n\n\n\n\n","category":"type"},{"location":"api/quantumpropagators/#QuantumPropagators.ChebyPropagator","page":"API","title":"QuantumPropagators.ChebyPropagator","text":"Propagator for Chebychev propagation (method=:cheby).\n\nThis is a PWCPropagator.\n\n\n\n\n\n","category":"type"},{"location":"api/quantumpropagators/#QuantumPropagators.AbstractPropagator","page":"API","title":"QuantumPropagators.AbstractPropagator","text":"Abstract base type for all Propagator objects.\n\nAll Propagator objects must be instantiated via initprop and implement the following interface.\n\nProperties\n\nstate (read-only): The current quantum state in the propagation\ntlist (read-only): The time grid for the propatation\nt (read-only): The time at which state is defined. An element of tlist.\nparameters: parameters that determine the dynamics. The structure of the parameters depends on the concrete Propagator type (i.e., the propagation method). Mutating the parameters affects subsequent propagation steps.\nbackward: Boolean flag to indicate whether the propagation moves forward or backward in time\ninplace: Boolean flag to indicate whether propagator.state is modified in-place or is recreated by every call of propstep! or set_state!. For inplace=true, we find Ψ = propagator.state; propstep!(propagator); propagator.state === Ψ to be true, while for inplace=false it is false.\n\nConcrete Propagator types may have additional properties or fields, but these should be considered private.\n\nMethods\n\nreinitprop! — reset the propagator to a new initial state at the beginning of the time grid (or the end, for backward propagation)\npropstep! – advance the propagator by one step forward (or backward) on the time grid.\nset_state! — safely mutate the current quantum state of the propagation. Note that directly mutating the state property is not safe. However, Ψ = propagator.state; mutate!(Ψ), set_state!(propagator, Ψ) is guaranteed to be safe and efficient for both in-place and not-in-place propagators.\nset_t! — safely mutate the current time (propagator.t), snapping to the values of tlist.\n\nSee also\n\nPiecewisePropagator — specialization of AbstractPropagator for piecewise propagation methods.\nPWCPropagator — specialization of PiecewisePropagator for piecewise-constant propagation methods.\n\n\n\n\n\n","category":"type"},{"location":"api/quantumpropagators/#QuantumPropagators.PWCPropagator","page":"API","title":"QuantumPropagators.PWCPropagator","text":"PiecewisePropagator sub-type for piecewise-constant propagators.\n\nLike the more general PiecewisePropagator, this is characterized by propagator.parameters mapping the controls in the generator to a vector of amplitude value on the midpoints of the time grid intervals.\n\nThe propagation will use these values as constant within each interval.\n\n\n\n\n\n","category":"type"},{"location":"api/quantumpropagators/#QuantumPropagatorsGeneratorsAPI","page":"API","title":"QuantumPropagators.Generators","text":"","category":"section"},{"location":"api/quantumpropagators/","page":"API","title":"API","text":"The following routines define dynamical generators (Hamiltonians, Liouvillians). This includes the initialization of generators and the methods that define how these generators contain controls and control amplitudes. These methods must be defined for any custom generator or control amplitude.","category":"page"},{"location":"api/quantumpropagators/#Reference-2","page":"API","title":"Reference","text":"","category":"section"},{"location":"api/quantumpropagators/","page":"API","title":"API","text":"Public Members:","category":"page"},{"location":"api/quantumpropagators/","page":"API","title":"API","text":"Generator\nOperator\nScaledOperator\nhamiltonian\nliouvillian","category":"page"},{"location":"api/quantumpropagators/","page":"API","title":"API","text":"Private Members:","category":"page"},{"location":"api/quantumpropagators/","page":"API","title":"API","text":"check_amplitude\ncheck_generator\ncheck_operator","category":"page"},{"location":"api/quantumpropagators/#Public-members-2","page":"API","title":"Public members","text":"","category":"section"},{"location":"api/quantumpropagators/","page":"API","title":"API","text":"QuantumPropagators.Generators.Generator\nQuantumPropagators.Generators.Operator\nQuantumPropagators.Generators.ScaledOperator\nQuantumPropagators.Generators.hamiltonian\nQuantumPropagators.Generators.liouvillian","category":"page"},{"location":"api/quantumpropagators/#QuantumPropagators.Generators.Generator","page":"API","title":"QuantumPropagators.Generators.Generator","text":"A time-dependent generator.\n\nGenerator(ops::Vector{OT}, amplitudes::Vector{AT})\n\nproduces an object of type Generator{OT,AT} that represents\n\nH(t)= H_0 + sum_l a_l(ϵ_l(t) t)  H_l\n\nwhere H_l are the ops and a_l(t) are the amplitudes. H(t) and H_l may represent operators in Hilbert space or super-operators in Liouville space. If the number of amplitudes is less than the number of ops, the first ops are considered as drift terms (H_0, respectively subsequent terms with a_l  1). At least one time-dependent amplitude is required. Each amplitude may depend on one or more control functions ϵ_l(t), although most typically a_l(t)  ϵ_l(t), that is, the amplitudes are simply a vector of the controls. See hamiltonian for details.\n\nA Generator object should generally not be instantiated directly, but via hamiltonian or liouvillian.\n\nThe list of ops and amplitudes are properties of the Generator. They should not be mutated.\n\nSee also\n\nOperator for static generators, which may be obtained from a Generator via evalcontrols.\n\n\n\n\n\n","category":"type"},{"location":"api/quantumpropagators/#QuantumPropagators.Generators.Operator","page":"API","title":"QuantumPropagators.Generators.Operator","text":"A static operator in Hilbert or Liouville space.\n\nOperator(ops::Vector{OT}, coeffs::Vector{CT})\n\nproduces an object of type Operator{OT,CT} that encapsulates the \"lazy\" sum\n\nH = sum_l c_l H_l\n\nwhere H_l are the ops and c_l are the coeffs, which each must be a constant Number. If the number of coefficients is less than the number of operators, the first ops are considered to have c_l = 1.\n\nAn Operator object would generally not be instantiated directly, but be obtained from a Generator via evalcontrols.\n\n\n\n\n\n","category":"type"},{"location":"api/quantumpropagators/#QuantumPropagators.Generators.ScaledOperator","page":"API","title":"QuantumPropagators.Generators.ScaledOperator","text":"A static operator with a scalar pre-factor.\n\nop = ScaledOperator(α, Ĥ)\n\nrepresents the \"lazy\" product α H where H is an operator (typically an Operator instance) and α is a scalar.\n\n\n\n\n\n","category":"type"},{"location":"api/quantumpropagators/#QuantumPropagators.Generators.hamiltonian","page":"API","title":"QuantumPropagators.Generators.hamiltonian","text":"Initialize a (usually time-dependent) Hamiltonian.\n\nThe most common usage is, e.g.,\n\nusing QuantumPropagators\n\nH₀ = ComplexF64[0 0; 0 1];\nH₁ = ComplexF64[0 1; 1 0];\nϵ₁(t) = 1.0;\n\nhamiltonian(H₀, (H₀, ϵ₁))\n\n# output\n\nGenerator{Matrix{ComplexF64}, typeof(ϵ₁)}(<2 ops>, <1 amplitudes>)\n\nIn general,\n\nH = hamiltonian(terms...; check=true)\n\nconstructs a Hamiltonian based on the given terms. Each term must be an operator or a tuple (op, ampl) of an operator and a control amplitude. Single operators are considered \"drift\" terms.\n\nIn most cases, each control amplitude will simply be a control function or vector of pulse values. In general, ampl can be an arbitrary object that depends on one or more controls, which must be obtainable via getcontrols(ampl).\n\nThe hamiltonian function will generally return a Generator instance. However, if none of the given terms are time-dependent, it may return a static operator (e.g., an AbstractMatrix or Operator):\n\nhamiltonian(H₀)\n# output\n2×2 Matrix{ComplexF64}:\n 0.0+0.0im  0.0+0.0im\n 0.0+0.0im  1.0+0.0im\n\nhamiltonian(H₀, (H₁, 2.0))\n# output\nOperator{Matrix{ComplexF64}, Float64}(<2 ops>, <1 coeffs>)\n\nThe hamiltonian function may generate warnings if the terms are of an unexpected type or structure as well was warnings or errors for any ampl that does not implement the interface required for control amplitudes.  These can be suppressed with check=false.\n\n\n\n\n\n","category":"function"},{"location":"api/quantumpropagators/#QuantumPropagators.Generators.liouvillian","page":"API","title":"QuantumPropagators.Generators.liouvillian","text":"Construct a Liouvillian Generator.\n\nℒ = liouvillian(Ĥ, c_ops=(); convention=:LvN, check=true)\n\ncalculates the sparse Liouvillian super-operator ℒ from the Hamiltonian Ĥ and a list c_ops of Lindblad operators.\n\nWith convention=:LvN, applying the resulting ℒ to a vectorized density matrix ρ⃗ calculates fracddt vecrho(t) = ℒ vecrho(t) equivalent to the Liouville-von-Neumann equation for the density matrix ρ,\n\nfracddt ρ(t)\n= -i H ρ(t) + sum_kleft(\n    A_k ρ A_k^dagger\n    - frac12 A_k^dagger A_k ρ\n    - frac12 ρ A_k^dagger A_k\n  right)\n\nwhere the Lindblad operators A_k are the elements of c_ops.\n\nThe Hamiltonian H will generally be time-dependent. For example, it may be a Generator as returned by hamiltonian. For example, for a Hamiltonian with the terms (Ĥ₀, (Ĥ₁, ϵ₁), (Ĥ₂, ϵ₂)), where Ĥ₀, Ĥ₁, Ĥ₂ are matrices, and ϵ₁ and ϵ₂ are functions of time, the resulting ℒ will be a Generator corresponding to terms (ℒ₀, (ℒ₁, ϵ₁), (ℒ₂, ϵ₂)), where the initial terms is the superoperator ℒ₀ for the static component of the Liouvillian, i.e., the commutator with the drift Hamiltonian Ĥ₀, plus the dissipator (sum over k), as a sparse matrix. Time-dependent Lindblad operators are not currently supported. The remaining elements are tuples (ℒ₁, ϵ₁) and (ℒ₂, ϵ₂) corresponding to the commutators with the two control Hamiltonians, where ℒ₁ and ℒ₂ again are sparse matrices.\n\nIf H is not time-dependent, the resulting ℒ will likewise be a static operator. Passing H=nothing with non-empty c_ops initializes a pure dissipator.\n\nWith convention=:TDSE, the Liouvillian will be constructed for the equation of motion i hbar fracddt vecrho(t) = ℒ vecrho(t) to match exactly the form of the time-dependent Schrödinger equation. While this notation is not standard in the literature of open quantum systems, it has the benefit that the resulting ℒ can be used in a numerical propagator for a (non-Hermitian) Schrödinger equation without any change. Thus, for numerical applications, convention=:TDSE is generally preferred. The returned ℒ between the two conventions differs only by a factor of i, since we generally assume hbar=1.\n\nThe convention keyword argument is mandatory, to force a conscious choice.\n\nSee Goerz et. al. \"Optimal control theory for a unitary operation under dissipative evolution\", arXiv 1312.0111v2, Appendix B.2 for the explicit construction of the Liouvillian superoperator as a sparse matrix.\n\nPassing check=false, suppresses warnings and errors about unexpected types or the structure of the arguments, cf. hamiltonian.\n\n\n\n\n\n","category":"function"},{"location":"api/quantumpropagators/#Private-members-2","page":"API","title":"Private members","text":"","category":"section"},{"location":"api/quantumpropagators/","page":"API","title":"API","text":"QuantumPropagators.Generators.check_amplitude\nQuantumPropagators.Generators.check_generator\nQuantumPropagators.Generators.check_operator","category":"page"},{"location":"api/quantumpropagators/#QuantumPropagators.Generators.check_amplitude","page":"API","title":"QuantumPropagators.Generators.check_amplitude","text":"Run a check on the given control amplitude.\n\ncheck_amplitude(ampl; throw_error=true)\n\nchecks that ampl fulfills the requirements of a control amplitude in a Generator.\n\nReturn true if the ampl passes all checks. Otherwise, throws an error if throw_error=true (default) or return false.\n\nUse this to check a custom type for an amplitude.\n\n\n\n\n\n","category":"function"},{"location":"api/quantumpropagators/#QuantumPropagators.Generators.check_generator","page":"API","title":"QuantumPropagators.Generators.check_generator","text":"Run a check on the given generator relative to state.\n\ncheck_generator(generator, state; throw_error=true)\n\nperforms a thorough check that all required methods are defined for the type of the given generator under the assumption that generator describes the dynamics of the given state.\n\nReturns true if the generator type passes all checks. Otherwise, throws an error if throw_error=true (default) or return false.\n\nUse this to check a custom type for a dynamic generator.\n\n\n\n\n\n","category":"function"},{"location":"api/quantumpropagators/#QuantumPropagators.Generators.check_operator","page":"API","title":"QuantumPropagators.Generators.check_operator","text":"Run a check on the given operator relative to state.\n\ncheck_operator(operator, state; throw_error=true)\n\nperforms a thorough check that all required methods are defined for the type of the given operator. Most importantly, check that mul! is implemented to multiply the operator to the given state. Note that copy(state) must be implemented.\n\nReturn true if the operator passes all checks. Otherwise, throws an error if throw_error=true (default) or return false.\n\nUse this to check a custom type for an operator.\n\n\n\n\n\n","category":"function"},{"location":"api/quantumpropagators/#QuantumPropagatorsShapesAPI","page":"API","title":"QuantumPropagators.Shapes","text":"","category":"section"},{"location":"api/quantumpropagators/","page":"API","title":"API","text":"The following routines define useful functin S(t) that can be used for control functions or amplitudes.","category":"page"},{"location":"api/quantumpropagators/#Reference-3","page":"API","title":"Reference","text":"","category":"section"},{"location":"api/quantumpropagators/","page":"API","title":"API","text":"Public Members:","category":"page"},{"location":"api/quantumpropagators/","page":"API","title":"API","text":"blackman\nbox\nflattop","category":"page"},{"location":"api/quantumpropagators/#Public-members-3","page":"API","title":"Public members","text":"","category":"section"},{"location":"api/quantumpropagators/","page":"API","title":"API","text":"QuantumPropagators.Shapes.blackman\nQuantumPropagators.Shapes.box\nQuantumPropagators.Shapes.flattop","category":"page"},{"location":"api/quantumpropagators/#QuantumPropagators.Shapes.blackman","page":"API","title":"QuantumPropagators.Shapes.blackman","text":"Blackman window shape.\n\nblackman(t, t₀, T; a=0.16)\n\ncalculates\n\nB(t t_0 T) =\n    frac12left(\n        1 - a - cosleft(2π fract - t_0T - t_0right)\n        + a cosleft(4π fract - t_0T - t_0right)\n    right)\n\nfor a scalar t, with a = 0.16.\n\nSee http://en.wikipedia.org/wiki/Window_function#Blackman_windows\n\nA Blackman shape looks nearly identical to a Gaussian with a 6-sigma interval between t₀ and T.  Unlike the Gaussian, however, it will go exactly to zero at the edges. Thus, Blackman pulses are often preferable to Gaussians.\n\n\n\n\n\n","category":"function"},{"location":"api/quantumpropagators/#QuantumPropagators.Shapes.box","page":"API","title":"QuantumPropagators.Shapes.box","text":"Box shape (Theta-function).\n\nbox(t, t₀, T)\n\nevaluates the Heaviside (Theta-) function Theta(t) = 1 for t_0 le t le T; and Theta(t) = 0 otherwise.\n\n\n\n\n\n","category":"function"},{"location":"api/quantumpropagators/#QuantumPropagators.Shapes.flattop","page":"API","title":"QuantumPropagators.Shapes.flattop","text":"Flat shape (amplitude 1.0) with a switch-on/switch-off from zero.\n\nflattop(t; T, t_rise, t₀=0.0, t_fall=t_rise, func=:blackman)\n\nevaluates a shape function that starts at 0 at t=t₀, and ramps to to 1 during the t_rise interval. The function then remains at value 1, before ramping down to 0 again during the interval t_fall before T. For t  t₀ and t  T, the shape is zero.\n\nThe default switch-on/-off shape is half of a Blackman window (see blackman).\n\nFor func=:sinsq, the switch-on/-off shape is a sine-squared curve.\n\n\n\n\n\n","category":"function"},{"location":"api/quantumpropagators/#QuantumPropagatorsControlsAPI","page":"API","title":"QuantumPropagators.Controls","text":"","category":"section"},{"location":"api/quantumpropagators/","page":"API","title":"API","text":"The following routines define method that must be defined for any control function, or for generators with respect to control functions.","category":"page"},{"location":"api/quantumpropagators/#Reference-4","page":"API","title":"Reference","text":"","category":"section"},{"location":"api/quantumpropagators/","page":"API","title":"API","text":"Public Members:","category":"page"},{"location":"api/quantumpropagators/","page":"API","title":"API","text":"discretize\ndiscretize_on_midpoints\nevalcontrols\nevalcontrols!\nget_tlist_midpoints\ngetcontrols\nsubstitute_controls","category":"page"},{"location":"api/quantumpropagators/#Public-members-4","page":"API","title":"Public members","text":"","category":"section"},{"location":"api/quantumpropagators/","page":"API","title":"API","text":"QuantumPropagators.Controls.discretize\nQuantumPropagators.Controls.discretize_on_midpoints\nQuantumPropagators.Controls.evalcontrols\nQuantumPropagators.Controls.evalcontrols!\nQuantumPropagators.Controls.get_tlist_midpoints\nQuantumPropagators.Controls.getcontrols\nQuantumPropagators.Controls.substitute_controls","category":"page"},{"location":"api/quantumpropagators/#QuantumPropagators.Controls.discretize","page":"API","title":"QuantumPropagators.Controls.discretize","text":"Evaluate control at every point of tlist.\n\nvalues = discretize(control, tlist; via_midpoints=true)\n\ndiscretizes the given control to a Vector of values defined on the points of tlist.\n\nIf control is a function, it will will first be evaluated at the midpoint of tlist, see discretize_on_midpoints, and then the values on the midpoints are converted to values on tlist. This discretization is more stable than directly evaluationg the control function at the values of tlist, and ensures that repeated round-trips between discretize and discretize_on_midpoints can be done safely, see the note in the documentation of discretize_on_midpoints.\n\nThe latter can still be achieved by passing via_midpoints=false. While such a direct discretization is suitable e.g. for plotting, but it is unsuitable for round-trips between discretize and discretize_on_midpoints  (constant controls on tlist may result in a zig-zag on the intervals of tlist).\n\nIf control is a vector, it will be returned un-modified if it is of the same length as tlist. Otherwise, control must have one less value than tlist, and is assumed to be defined on the midpoins of tlist. In that case, discretize acts as the inverse of discretize_on_midpoints. See discretize_on_midpoints for how control values on tlist and control values on the intervals of tlist are related.\n\n\n\n\n\n","category":"function"},{"location":"api/quantumpropagators/#QuantumPropagators.Controls.discretize_on_midpoints","page":"API","title":"QuantumPropagators.Controls.discretize_on_midpoints","text":"Evaluate control at the midpoints of tlist.\n\nvalues = discretize_on_midpoints(control, tlist)\n\ndiscretizes the given control to a Vector of values on the midpoints of tlist. Hence, the resulting values will contain one less value than tlist.\n\nIf control is a vector of values defined on tlist (i.e., of the same length as tlist), it will be converted to a vector of values on the intervals of tlist. The value for the first and last \"midpoint\" will remain the original values at the beginning and end of tlist, in order to ensure exact bounary conditions. For all other midpoints, the value for that midpoint will be calculated by \"un-averaging\".\n\nFor example, for a control and tlist of length 5, consider the following diagram:\n\ntlist index:       1   2   3   4   5\ntlist:             ⋅   ⋅   ⋅   ⋅   ⋅   input values cᵢ (i ∈ 1..5)\n                   |̂/ ̄ ̄ ̂\\ / ̂\\ / ̂ ̄ ̄\\|̂\nmidpoints:         x     x   x     x   output values pᵢ (i ∈ 1..4)\nmidpoints index:   1     2   3     4\n\nWe will have p₁=c₁ for the first value, p₄=c₅ for the last value. For all other points, the control values cᵢ = fracp_i-1 + p_i2 are the average of the values on the midpoints. This implies the \"un-averaging\" for the midpoint values pᵢ = 2 c_i - p_i-1.\n\nnote: Note\nAn arbitrary input control array may not be compatible with the above averaging formula. In this case, the conversion will be \"lossy\" (discretize will not recover the original control array; the difference should be considered a \"discretization error\"). However, any further round-trip conversions between points and intervals are bijective and preserve the boundary conditions. In this case, the discretize_on_midpoints and discretize methods are each other's inverse. This also implies that for an optimal control procedure, it is safe to modify midpoint values. Modifying the the values on the time grid directly on the other hand may accumulate discretization errors.\n\nIf control is a vector of one less length than tlist, it will be returned unchanged, under the assumption that the input is already properly discretized.\n\nIf control is a function, the function will be directly evaluated at the midpoints marked as x in the above diagram..\n\n\n\n\n\n","category":"function"},{"location":"api/quantumpropagators/#QuantumPropagators.Controls.evalcontrols","page":"API","title":"QuantumPropagators.Controls.evalcontrols","text":"Replace the controls in generator with static values.\n\nop = evalcontrols(generator, vals_dict)\n\nreplaces the time-dependent controls in generator with the values in vals_dict and returns the static operator op.\n\nThe vals_dict is a dictionary (IdDict) mapping controls as returned by getcontrols(generator) to values.\n\nop = evalcontrols(generator, vals_dict, tlist, n)\nop = evalcontrols(generator, vals_dict, t)\n\nacts similarly for generators that have explicit time dependencies (apart for the controls). The additional parameters indicate that generator has explicit time dependencies that are well-defined on the intervals of a time grid tlist, and that vals_dict should be assumed to relate to the n'th interval of that time grid. Respectively, an additional parameter t indicates the generator is a time-continuous explicit dependency and that vals_dict contains values defined at time t.\n\nSee also:\n\nevalcontrols! to update op with new vals_dict.\n\n\n\n\n\naₙ = evalcontrols(ampl, vals_dict)\n\nevaluates a general control amplitude by replacing each control with the values in vals_dict. Returns a number.\n\nNote that for \"trivial\" amplitudes (where the amplitude is identical to the control), this simply looks up the control in vals_dict.\n\nFor amplitudes with explicit time dependencies (outside of the controls), additional parameters tlist, n or t should be given to indicate the time at which the amplitude is to be evaluated.\n\n\n\n\n\n","category":"function"},{"location":"api/quantumpropagators/#QuantumPropagators.Controls.evalcontrols!","page":"API","title":"QuantumPropagators.Controls.evalcontrols!","text":"Update an existing evaluation of a generator.\n\nevalcontrols!(op, generator, vals_dict, args...)\n\nperforms an in-place update on an op the was obtained from a previous call to evalcontrols with the same generator, but a different val_dict.\n\n\n\n\n\n","category":"function"},{"location":"api/quantumpropagators/#QuantumPropagators.Controls.get_tlist_midpoints","page":"API","title":"QuantumPropagators.Controls.get_tlist_midpoints","text":"Shift time grid values the interval midpoints\n\ntlist_midpoints = get_tlist_midpoints(tlist)\n\ntakes a vector tlist of length n and returns a vector of length n-1 containing the midpoint values of each interval. The intervals in tlist are not required to be uniform.\n\n\n\n\n\n","category":"function"},{"location":"api/quantumpropagators/#QuantumPropagators.Controls.getcontrols","page":"API","title":"QuantumPropagators.Controls.getcontrols","text":"Extract a Tuple of controls.\n\ncontrols = getcontrols(generator)\n\nextracts the controls from a single dynamical generator.\n\nFor example, if generator = hamiltonian(H0, (H1, ϵ1), (H2, ϵ2)), extracts (ϵ1, ϵ2).\n\n\n\n\n\ngetcontrols(operator)\n\nfor a static operator (matrix) returns an empty tuple.\n\n\n\n\n\n","category":"function"},{"location":"api/quantumpropagators/#QuantumPropagators.Controls.substitute_controls","page":"API","title":"QuantumPropagators.Controls.substitute_controls","text":"Substitute the controls inside a generator with different controls.\n\nnew_generator = substitute_controls(generator, controls_map)\n\nCreates a new generator from generator by replacing any control that is in the dict controls_map with controls_map[control]. Controls that are not in controls_map are kept unchanged.\n\nThe substituted controls must be time-dependent; to substitute static values for the controls, converting the time-dependent generator into a static operator, use evalcontrols.\n\nCalling substitute_controls on a static operator will return it unchanged.\n\n\n\n\n\nampl = substitute_controls(ampl, controls_map)\n\nreturns a new amplitude by replacing the original controls that the amplitude might depend on by the controls in controls_map.\n\nNote that for \"trivial\" amplitudes (where the amplitude is identical to the control), this simply looks up the control in controls_map.\n\n\n\n\n\n","category":"function"},{"location":"api/quantumpropagators/#QuantumPropagatorsAmplitudesAPI","page":"API","title":"QuantumPropagators.Amplitudes","text":"","category":"section"},{"location":"api/quantumpropagators/","page":"API","title":"API","text":"The following types define control amplitudes a(ϵ_l(t) t) that depend on one or more control functions ϵ_l(t).","category":"page"},{"location":"api/quantumpropagators/#Reference-5","page":"API","title":"Reference","text":"","category":"section"},{"location":"api/quantumpropagators/","page":"API","title":"API","text":"Public Members:","category":"page"},{"location":"api/quantumpropagators/","page":"API","title":"API","text":"LockedAmplitude\nShapedAmplitude","category":"page"},{"location":"api/quantumpropagators/#Public-members-5","page":"API","title":"Public members","text":"","category":"section"},{"location":"api/quantumpropagators/","page":"API","title":"API","text":"QuantumPropagators.Amplitudes.LockedAmplitude\nQuantumPropagators.Amplitudes.ShapedAmplitude","category":"page"},{"location":"api/quantumpropagators/#QuantumPropagators.Amplitudes.LockedAmplitude","page":"API","title":"QuantumPropagators.Amplitudes.LockedAmplitude","text":"A time-dependent amplitude that is not a control.\n\nampl = LockedAmplitude(shape)\n\nwraps around shape, which must be either a vector of values defined on the midpoints of a time grid or a callable shape(t).\n\nampl = LockedAmplitude(shape, tlist)\n\ndiscretizes shape to the midpoints of tlist.\n\n\n\n\n\n","category":"type"},{"location":"api/quantumpropagators/#QuantumPropagators.Amplitudes.ShapedAmplitude","page":"API","title":"QuantumPropagators.Amplitudes.ShapedAmplitude","text":"Product of a fixed shape and a control.\n\nampl = ShapedAmplitude(control; shape=shape)\n\nproduces an amplitude a(t) = S(t) ϵ(t), where S(t) corresponds to shape and ϵ(t) corresponds to control. Both control and shape should be either a vector of values defined on the midpoints of a time grid or a callable control(t), respectively shape(t). In the latter case, ampl will also be callable.\n\nampl = ShapedAmplitude(control, tlist; shape=shape)\n\ndiscretizes control and shape to the midpoints of tlist.\n\n\n\n\n\n","category":"type"},{"location":"api/quantumpropagators/#QuantumPropagatorsStorageAPI","page":"API","title":"QuantumPropagators.Storage","text":"","category":"section"},{"location":"api/quantumpropagators/","page":"API","title":"API","text":"The following routines allow to manage and extend storage arrays storage parameter in propagate. See Storage of states or expectation values for more details. Note that the high-level routines init_storage, write_to_storage!, and get_from_storage! are also re-exported in the top-level QuantumPropagators directly.","category":"page"},{"location":"api/quantumpropagators/#Reference-6","page":"API","title":"Reference","text":"","category":"section"},{"location":"api/quantumpropagators/","page":"API","title":"API","text":"Public Members:","category":"page"},{"location":"api/quantumpropagators/","page":"API","title":"API","text":"get_from_storage!\ninit_storage\nmap_observable\nmap_observables\nwrite_to_storage!","category":"page"},{"location":"api/quantumpropagators/#Public-members-6","page":"API","title":"Public members","text":"","category":"section"},{"location":"api/quantumpropagators/","page":"API","title":"API","text":"QuantumPropagators.Storage.get_from_storage!\nQuantumPropagators.Storage.init_storage\nQuantumPropagators.Storage.map_observable\nQuantumPropagators.Storage.map_observables\nQuantumPropagators.Storage.write_to_storage!","category":"page"},{"location":"api/quantumpropagators/#QuantumPropagators.Storage.get_from_storage!","page":"API","title":"QuantumPropagators.Storage.get_from_storage!","text":"Obtain data from storage.\n\nget_from_storage!(state, storage, i)\n\nextracts data from the storage for the i'th time slot. Invese of write_to_storage!\n\n\n\n\n\n","category":"function"},{"location":"api/quantumpropagators/#QuantumPropagators.Storage.init_storage","page":"API","title":"QuantumPropagators.Storage.init_storage","text":"Create a storage array for propagation.\n\nstorage = init_storage(state, tlist)\n\ncreates a storage array suitable for storing a state for each point in tlist.\n\nstorage = init_storage(state, tlist, observables))\n\ncreates a storage array suitable for the data generated by the observables applied to state, see map_observables, for each point in tlist.\n\nstorage = init_storage(data, nt))\n\ncreates a storage arrays suitable for storing data nt times, where nt=length(tlist). By default, this will be a vector of typeof(data) and length nt, or a n × nt Matrix with the same eltype as data if data is a Vector of length n.\n\n\n\n\n\n","category":"function"},{"location":"api/quantumpropagators/#QuantumPropagators.Storage.map_observable","page":"API","title":"QuantumPropagators.Storage.map_observable","text":"Apply a single observable to state.\n\ndata = map_observable(observable, state)\n\nBy default, observable is assumed to be callable, and the above is equivalent to data = observable(state).\n\nIf observable is a matrix and state is a vector evaluate the expectation value of the observable as dot(state, observable, state).\n\n\n\n\n\n","category":"function"},{"location":"api/quantumpropagators/#QuantumPropagators.Storage.map_observables","page":"API","title":"QuantumPropagators.Storage.map_observables","text":"Obtain \"observable\" data from state.\n\ndata = map_observables(observables, state)\n\ncalculates the data for a tuple of observables applied to state. For a single observable (tuple of length 1), simply return the result of map_observable.\n\nFor multiple observables, return the tuple resulting from applying map_observable for each observable. If the tuple is \"uniform\" (all elements are of the same type, e.g. if each observable calculates the expectation value of a Hermitian operator), it is converted to a Vector. This allows for compact storage in a storage array, see init_storage.\n\n\n\n\n\n","category":"function"},{"location":"api/quantumpropagators/#QuantumPropagators.Storage.write_to_storage!","page":"API","title":"QuantumPropagators.Storage.write_to_storage!","text":"Place data into storage for time slot i.\n\nwrite_to_storage!(storage, i, state, observables)\n\nFor a storage array created by init_storage, store the data obtains from map_observables into the storage for time slot i. This delegates to the more general\n\nwrite_to_storage!(storage, i, data)\n\nConceptually, this corresponds roughly to storage[i] = data, but storage may have its own idea on how to store data for a specific time slot. For example, with the default init_storage Vector data will be stored in a matrix, and write_to_storage! will in this case write data to the i'th column of the matrix.\n\nFor a given type of storage and data, it is the developer's responsibility that init_storage and write_to_storage! are compatible.\n\n\n\n\n\n","category":"function"},{"location":"api/quantumpropagators/#QuantumPropagatorsChebyAPI","page":"API","title":"QuantumPropagators.Cheby","text":"","category":"section"},{"location":"api/quantumpropagators/","page":"API","title":"API","text":"The following routines implement time propagation via expansion in Chebychev polynomials.","category":"page"},{"location":"api/quantumpropagators/#Reference-7","page":"API","title":"Reference","text":"","category":"section"},{"location":"api/quantumpropagators/","page":"API","title":"API","text":"Public Members:","category":"page"},{"location":"api/quantumpropagators/","page":"API","title":"API","text":"ChebyWrk\ncheby\ncheby!\ncheby_coeffs\ncheby_coeffs!","category":"page"},{"location":"api/quantumpropagators/#Public-members-7","page":"API","title":"Public members","text":"","category":"section"},{"location":"api/quantumpropagators/","page":"API","title":"API","text":"QuantumPropagators.Cheby.ChebyWrk\nQuantumPropagators.Cheby.cheby\nQuantumPropagators.Cheby.cheby!\nQuantumPropagators.Cheby.cheby_coeffs\nQuantumPropagators.Cheby.cheby_coeffs!","category":"page"},{"location":"api/quantumpropagators/#QuantumPropagators.Cheby.ChebyWrk","page":"API","title":"QuantumPropagators.Cheby.ChebyWrk","text":"Workspace for the Chebychev propagation routine.\n\nChebyWrk(Ψ, Δ, E_min, dt; limit=1e-12)\n\ninitializes the workspace for the propagation of a state similar to Ψ under a Hamiltonian with eigenvalues between E_min and E_min + Δ, and a time step dt. Chebychev coefficients smaller than the given limit are discarded.\n\n\n\n\n\n","category":"type"},{"location":"api/quantumpropagators/#QuantumPropagators.Cheby.cheby","page":"API","title":"QuantumPropagators.Cheby.cheby","text":"Evaluate Ψ = exp(i- H dt) Ψ.\n\nΨ_out = cheby(Ψ, H, dt, wrk; E_min=nothing, check_normalization=false)\n\nacts like cheby! but does not modify Ψ in-place.\n\n\n\n\n\n","category":"function"},{"location":"api/quantumpropagators/#QuantumPropagators.Cheby.cheby!","page":"API","title":"QuantumPropagators.Cheby.cheby!","text":"Evaluate Ψ = exp(-i H dt) Ψ in-place.\n\ncheby!(Ψ, H, dt, wrk; E_min=nothing, check_normalization=false)\n\nArguments\n\nΨ: on input, initial vector. Will be overwritten with result.\nH: Hermitian operator\ndt: time step\nwrk: internal workspace\nE_min: minimum eigenvalue of H, to be used instead of the E_min from the  initialization of wrk. The same wrk may be used for different values  E_min, as long as the spectra radius Δ and the time step dt are the  same as those used for the initialization of wrk.\ncheck_normalizataion: perform checks that the H does not exceed the spectral radius for which the the workspace was initialized.\n\nThe routine will not allocate any internal storage. This implementation requires copyto! lmul!, and axpy! to be implemented for Ψ, and the three-argument mul! for Ψ and H.\n\n\n\n\n\n","category":"function"},{"location":"api/quantumpropagators/#QuantumPropagators.Cheby.cheby_coeffs","page":"API","title":"QuantumPropagators.Cheby.cheby_coeffs","text":"Calculate Chebychev coefficients.\n\na::Vector{Float64} = cheby_coeffs(Δ, dt; limit=1e-12)\n\nreturn an array of coefficiencts larger than limit.\n\nArguments\n\nΔ: the spectral radius of the underlying operator\ndt: the time step\n\nSee also cheby_coeffs! for an in-place version.\n\n\n\n\n\n","category":"function"},{"location":"api/quantumpropagators/#QuantumPropagators.Cheby.cheby_coeffs!","page":"API","title":"QuantumPropagators.Cheby.cheby_coeffs!","text":"Calculate Chebychev coefficients in-place.\n\nn::Int = cheby_coeffs!(coeffs, Δ, dt, limit=1e-12)\n\noverwrites the first n values in coeffs with new coefficients larger than limit for the given new spectral radius Δ and time step dt. The coeffs array will be resized if necessary, and may have a length > n on exit.\n\nSee also cheby_coeffs for an non-in-place version.\n\n\n\n\n\n","category":"function"},{"location":"api/quantumpropagators/#QuantumPropagatorsNewtonAPI","page":"API","title":"QuantumPropagators.Newton","text":"","category":"section"},{"location":"api/quantumpropagators/","page":"API","title":"API","text":"The following routines implement time propagation via expansion in Newton polynomials using a restarted Arnoldi scheme to determine evaluation points.","category":"page"},{"location":"api/quantumpropagators/#Reference-8","page":"API","title":"Reference","text":"","category":"section"},{"location":"api/quantumpropagators/","page":"API","title":"API","text":"Public Members:","category":"page"},{"location":"api/quantumpropagators/","page":"API","title":"API","text":"NewtonWrk\nnewton!","category":"page"},{"location":"api/quantumpropagators/","page":"API","title":"API","text":"Private Members:","category":"page"},{"location":"api/quantumpropagators/","page":"API","title":"API","text":"extend_leja!\nextend_newton_coeffs!","category":"page"},{"location":"api/quantumpropagators/#Public-members-8","page":"API","title":"Public members","text":"","category":"section"},{"location":"api/quantumpropagators/","page":"API","title":"API","text":"QuantumPropagators.Newton.NewtonWrk\nQuantumPropagators.Newton.newton!","category":"page"},{"location":"api/quantumpropagators/#QuantumPropagators.Newton.NewtonWrk","page":"API","title":"QuantumPropagators.Newton.NewtonWrk","text":"NewtonWrk(v0, m_max=10)\n\nWorkspace for the Newton-with-restarted-Arnoldi propagation routine.\n\nInitializes the workspace for the propagation of a vector v0, using a maximum Krylov dimension of m_max in each restart iteration. Note that m_max should be smaller than the length of v0.\n\n\n\n\n\n","category":"type"},{"location":"api/quantumpropagators/#QuantumPropagators.Newton.newton!","page":"API","title":"QuantumPropagators.Newton.newton!","text":"newton!(Ψ, H, dt, wrk; func=(z -> exp(-1im*z)), norm_min=1e-14, relerr=1e-12,\n        max_restarts=50, _...)\n\nEvaluate Ψ = func(H*dt) Ψ using a Newton-with-restarted-Arnoldi scheme.\n\nArguments\n\nΨ: The state to propagate, will be overwritten in-place with the propagated state\nH: Operator acting on Ψ. Together with dt, this is the argument to func\ndt: Implicit time step. Together with H, this is the argument to func\nwkr: Work array, initialized with NewtonWrk\nfunc: The function to apply to H dt, taking a single (scalar) complex-valued argument z in place of H dt. The default func is to evaluate the time evoluation operator for the Schrödinger equation\nnorm_min: the minium norm at which to consider a state similar to Ψ as zero\nrelerr: The relative error defining the convergence condition for the restart iteration. Propagation stops when the norm of the accumulated Ψ is stable up to the given relative error\nmax_restarts: The maximum number of restart iterations. Exceeding max_restarts will throw an AssertionError.\n\nAll other keyword arguments are ignored.\n\n\n\n\n\n","category":"function"},{"location":"api/quantumpropagators/#Private-members-3","page":"API","title":"Private members","text":"","category":"section"},{"location":"api/quantumpropagators/","page":"API","title":"API","text":"QuantumPropagators.Newton.extend_leja!\nQuantumPropagators.Newton.extend_newton_coeffs!","category":"page"},{"location":"api/quantumpropagators/#QuantumPropagators.Newton.extend_leja!","page":"API","title":"QuantumPropagators.Newton.extend_leja!","text":"extend_leja!(leja, n, newpoints, n_use)\n\nGiven an array of n (ordered) Leja points, extract n_use points from newpoints, and append them to the existing Leja points. The array leja should be sufficiently large to hold the new Leja points, which are appended after index n_old. It will be re-allocated if necessary and may have a size of up to 2*(n+n_use).\n\nArguments\n\nleja: Array of leja values. Must contain the \"old\" leja values to be kept  in leja(0:n-1). On output, n_use new leja points will be in  leja(n+:n+n_use-1), for the original value of n.  The leja array must  use zero-based indexing.\nn: On input, number of \"old\" leja points in leja. On output, total number of leja points (i.e. n=n+n_use)\nnewpoints: On input, candidate points for new leja points.  The n_use best values will be chosen and added to leja. On output, the values of new_points are undefined.\nn_use: Number of points that should be added to leja\n\n\n\n\n\n","category":"function"},{"location":"api/quantumpropagators/#QuantumPropagators.Newton.extend_newton_coeffs!","page":"API","title":"QuantumPropagators.Newton.extend_newton_coeffs!","text":"extend_newton_coeffs!(a, n_a, leja, func, n_leja, radius)\n\nExtend the array a of existing Newton coefficients for the expansion of the func from n_a coefficients to n_leja coefficients. Return a new value n_a=n_a+n_leja with the total number of Newton coefficients in the updated a.\n\nArguments\n\na: On input, a zero-based array of length n_a or greater, containing Newton coefficients. On output, array containing a total n_leja coefficients. The array a will be resized if necessary, and may have a length greater than n_leja on output\nn_a:  The number of Newton coefficients in a, on input. Elements of a  beyond the first n_a elements will be overwritten.\nleja: Array of normalized Leja points, containing at least n_leja elements.\nfunc: Function for which to calcluate Newton coeffiecients\nn_leja: The number of elements in leja to use for calculating new coefficients, and the total number of Newton coefficients on output\nradius: Normalization radius for divided differences\n\n\n\n\n\n","category":"function"},{"location":"api/quantumpropagators/#QuantumPropagatorsExpPropAPI","page":"API","title":"QuantumPropagators.ExpProp","text":"","category":"section"},{"location":"api/quantumpropagators/","page":"API","title":"API","text":"The following routines implement time propagation via explicit exponentiation of the dynamical generator.","category":"page"},{"location":"api/quantumpropagators/#Reference-9","page":"API","title":"Reference","text":"","category":"section"},{"location":"api/quantumpropagators/","page":"API","title":"API","text":"Public Members:","category":"page"},{"location":"api/quantumpropagators/","page":"API","title":"API","text":"ExpPropWrk\nexpprop!","category":"page"},{"location":"api/quantumpropagators/","page":"API","title":"API","text":"Private Members:","category":"page"},{"location":"api/quantumpropagators/","page":"API","title":"API","text":"expprop","category":"page"},{"location":"api/quantumpropagators/#Public-members-9","page":"API","title":"Public members","text":"","category":"section"},{"location":"api/quantumpropagators/","page":"API","title":"API","text":"QuantumPropagators.ExpProp.ExpPropWrk\nQuantumPropagators.ExpProp.expprop!","category":"page"},{"location":"api/quantumpropagators/#QuantumPropagators.ExpProp.ExpPropWrk","page":"API","title":"QuantumPropagators.ExpProp.ExpPropWrk","text":"ExpPropWrk(v0)\n\nWorkspace for propagation via direct matrix exponentiation.\n\nInitializes the workspace for the propagation of a vector v0\n\n\n\n\n\n","category":"type"},{"location":"api/quantumpropagators/#QuantumPropagators.ExpProp.expprop!","page":"API","title":"QuantumPropagators.ExpProp.expprop!","text":"expprop!(Ψ, H, dt, wrk; func=(H_dt -> exp(-1im * H_dt)), _...)\n\nEvaluate Ψ = func(H*dt) Ψ by directly evaluating U = func(H*dt), i.e. by matrix exponentiation for the default func, and then multiplying U and Ψ in-place with mul!.\n\nThe workspace wrk must be initialized with ExpPropWrk to provide storage for a temporary state.\n\nKeyword arguments besides func are ignored.\n\n\n\n\n\n","category":"function"},{"location":"api/quantumpropagators/#Private-members-4","page":"API","title":"Private members","text":"","category":"section"},{"location":"api/quantumpropagators/","page":"API","title":"API","text":"QuantumPropagators.ExpProp.expprop","category":"page"},{"location":"api/quantumpropagators/#QuantumPropagators.ExpProp.expprop","page":"API","title":"QuantumPropagators.ExpProp.expprop","text":"Ψ_out = expprop(Ψ, H, dt, wrk; func=(H_dt -> exp(-1im * H_dt)), _...)\n\nevaluates Ψ_out = func(H*dt) Ψ as in expprop!, but not acting in-place.\n\n\n\n\n\n","category":"function"},{"location":"api/quantumpropagators/#QuantumPropagatorsSpectralRangeAPI","page":"API","title":"QuantumPropagators.SpectralRange","text":"","category":"section"},{"location":"api/quantumpropagators/","page":"API","title":"API","text":"Chebychev propagation relies on estimating the spectral range of the Hamiltonian, which in turn may be done via Arnoldi iteration.","category":"page"},{"location":"api/quantumpropagators/#Reference-10","page":"API","title":"Reference","text":"","category":"section"},{"location":"api/quantumpropagators/","page":"API","title":"API","text":"Public Members:","category":"page"},{"location":"api/quantumpropagators/","page":"API","title":"API","text":"specrange","category":"page"},{"location":"api/quantumpropagators/","page":"API","title":"API","text":"Private Members:","category":"page"},{"location":"api/quantumpropagators/","page":"API","title":"API","text":"ritzvals\nrandom_state","category":"page"},{"location":"api/quantumpropagators/#Public-members-10","page":"API","title":"Public members","text":"","category":"section"},{"location":"api/quantumpropagators/","page":"API","title":"API","text":"QuantumPropagators.SpectralRange.specrange","category":"page"},{"location":"api/quantumpropagators/#QuantumPropagators.SpectralRange.specrange","page":"API","title":"QuantumPropagators.SpectralRange.specrange","text":"Calculate the spectral range of a Hamiltonian H on the real axis.\n\nE_min, E_max = specrange(H; method=:auto, kwargs...)\n\ncalculates the approximate lowest and highest eigenvalues of H. Any imaginary part in the eigenvalues is ignored: the routine is intended for (although not strictly limited to) a Hermitian H.\n\nThis delegates to\n\nspecrange(H, method; kwargs...)\n\nfor the different methods.\n\nThe default method=:auto chooses the best method for the given H. This is :diag for small matrices, and :arnoldi otherwise. Keyword arguments not relevant to the underlying implementation will be ignored.\n\n\n\n\n\nE_min, E_max = specrange(H, :arnoldi; state=random_state(H), m_min=20,\n                         m_max=60, prec=1e-3, norm_min=1e-15, enlarge=true)\n\nuses Arnoldi iteration with state as the starting vector. It approximates the eigenvalues of H with between m_min and m_max Ritz values, until the lowest and highest eigenvalue are stable to a releative precision of prec. The norm_min parameter is passed to the underlying arnoldi!.\n\nIf enlarge=true (default) the returned E_min and E_max will be enlarged via a heuristic to slightly over-estimate the spectral radius instead of under-estimating it.\n\n\n\n\n\nE_min, E_max = specrange(H, :diag)\n\nuses exact diagonization via the standard eigvals function to obtain the smallest and largest eigenvalue. This should only be used for relatively small matrices.\n\n\n\n\n\n","category":"function"},{"location":"api/quantumpropagators/#Private-members-5","page":"API","title":"Private members","text":"","category":"section"},{"location":"api/quantumpropagators/","page":"API","title":"API","text":"QuantumPropagators.SpectralRange.ritzvals\nQuantumPropagators.SpectralRange.random_state","category":"page"},{"location":"api/quantumpropagators/#QuantumPropagators.SpectralRange.ritzvals","page":"API","title":"QuantumPropagators.SpectralRange.ritzvals","text":"Calculate a vector for Ritz values converged to a given precision.\n\nR = ritzvals(G, state, m_min, m_max=2*m_min; prec=1e-5, norm_min=1e-15)\n\ncalculates a complex vector R of at least m_min and at most m_max Ritz values.\n\n\n\n\n\n","category":"function"},{"location":"api/quantumpropagators/#QuantumPropagators.SpectralRange.random_state","page":"API","title":"QuantumPropagators.SpectralRange.random_state","text":"Random normalized quantum state.\n\n    Ψ = random_state(H)\n\nreturns a random normalized state compatible with the Hamiltonian H. This is intended to provide a starting vector for estimating the spectral radius of H via an Arnoldi method.\n\n\n\n\n\n","category":"function"},{"location":"api/quantumpropagators/#QuantumPropagatorsArnoldiAPI","page":"API","title":"QuantumPropagators.Arnoldi","text":"","category":"section"},{"location":"api/quantumpropagators/","page":"API","title":"API","text":"Arnoldi iteration is an approximate method to find extremal eigenvalues of a dynamical generator by projecting it into a Krylov subspace. It is used to estimate spectral ranges for Chebychev Propagation and to find appropriate Leja points to support Newton Propagation","category":"page"},{"location":"api/quantumpropagators/#Reference-11","page":"API","title":"Reference","text":"","category":"section"},{"location":"api/quantumpropagators/","page":"API","title":"API","text":"Private Members:","category":"page"},{"location":"api/quantumpropagators/","page":"API","title":"API","text":"diagonalize_hessenberg_matrix\narnoldi!\nextend_arnoldi!","category":"page"},{"location":"api/quantumpropagators/#Private-members-6","page":"API","title":"Private members","text":"","category":"section"},{"location":"api/quantumpropagators/","page":"API","title":"API","text":"QuantumPropagators.Arnoldi.diagonalize_hessenberg_matrix\nQuantumPropagators.Arnoldi.arnoldi!\nQuantumPropagators.Arnoldi.extend_arnoldi!","category":"page"},{"location":"api/quantumpropagators/#QuantumPropagators.Arnoldi.diagonalize_hessenberg_matrix","page":"API","title":"QuantumPropagators.Arnoldi.diagonalize_hessenberg_matrix","text":"diagonalize_hessenberg_matrix(Hess, m; accumulate=false)\n\nDiagonalize the m × m top left submatrix of the given Hessenberg matrix.\n\nIf accumulate is true, return the concatenated eigenvalues for Hess[1:1,1:1] to Hess[1:m,1:m], that is, all sumatrices of size 1 through m.\n\n\n\n\n\n","category":"function"},{"location":"api/quantumpropagators/#QuantumPropagators.Arnoldi.arnoldi!","page":"API","title":"QuantumPropagators.Arnoldi.arnoldi!","text":"m = arnoldi!(Hess, q, m, Ψ, H, dt=1.0; extended=true, norm_min=1e-15)\n\nCalculate the Hessenberg matrix and Arnoldi vectors of H dt, from Ψ.\n\nFor a given order m, the m×m Hessemberg matrix is calculated and stored in in the pre-allocated Hess. Further  an array of m normalized Arnoldi vectors is stored in in the pre-allocated q, plus one additional unnormalized Arnoldi vector.  The unnormalized m+1st vector could be used to easily extend a given m×m Hessenberg matrix to a (m+1)×(m+1) matrix.\n\nIf the extended Hessenberg matrix is requested (extended=true, default), the m+1st Arnoldi vector is also normalized, and it's norm will be stored in m+1, m entry of the (extended) Hessenberg matrix, which is an (m+1)×(m+1) matrix.\n\nReturn the size m of the calculated Hessenberg matrix. This will usually be the input m, except when the Krylov dimension of H starting from Ψ is less then m. E.g., if Ψ is an eigenstate of H, the returned m will be 1.\n\nSee http://en.wikipedia.org/wiki/Arnoldi_iteration for a description of the algorithm.\n\nArguments\n\nHess::Matrix{ComplexF64}: Pre-allocated storage for the Hessemberg matrix.  Can be uninitialized on input. The matrix must be at least of size m×m, or  (m+1)×(m+1) if extended=true. On output, the m×m sub-matrix of Hess  (with the returned output m) will contain the Hessenberg matrix, and all  other elements of Hess be be set to zero.\nq: Pre-allocated array of states similar to Ψ, as storage for the calculated Arnoldi vectors. These may be un-initialized on input. Must be at least of length m+1\nm: The requested dimensions of the output Hessenberg matrix.\nΨ: The starting vector for the Arnoldi procedure. This can be of any type,  as long as Φ = H * Ψ results in a vector similar to Ψ, there is an inner  products of Φ and Ψ (Ψ⋅Φ is defined), and norm(Ψ) is defined.\nH: The operator (up to dt) for which to calculate the Arnoldi procedure. Can be of any type, as long as H * Ψ is defined.\ndt: The implicit time step; the total operator for which to calculate the Arnoldi procedure is H * dt\nextended: If true (default), calculate the extended Hessenberg matrix, and normalized the final Arnoldi vector\nnorm_min: the minimum value of the norm of Ψ at which Ψ should be  considered the zero vector\n\n\n\n\n\n","category":"function"},{"location":"api/quantumpropagators/#QuantumPropagators.Arnoldi.extend_arnoldi!","page":"API","title":"QuantumPropagators.Arnoldi.extend_arnoldi!","text":"Extend dimension of Hessenberg matrix by one.\n\nextend_arnoldi!(Hess, q, m, H, dt; norm_min=1e-15)\n\nextends the entries in Hess from size (m-1)×(m-1) to size m×m, and the list q of Arnoldi vectors from m to (m+1). It is assumed that the input Hess was created by a call to arnoldi! with extended=false or a previous call to extend_arnoldi!. Note that Hess itself is not resized, so it must be allocated to size m×m or greater on input.\n\n\n\n\n\n","category":"function"},{"location":"api/quantumpropagators/#Index","page":"API","title":"Index","text":"","category":"section"},{"location":"api/quantumpropagators/","page":"API","title":"API","text":"","category":"page"},{"location":"generators/#Dynamic-Generators","page":"Dynamical Generators","title":"Dynamic Generators","text":"","category":"section"},{"location":"generators/","page":"Dynamical Generators","title":"Dynamical Generators","text":"The propagate routine simulates the dynamics of a state Ψ or ρ under the assumption that that time derivative of the state is described by a generator. The exact equation of motion is implicit in the Propagator, but all propagators implemented in the QuantumPropagators package assume that the generator is the time-dependent Hamiltonian H(t) in the Schrödinger equation (ħ=1)","category":"page"},{"location":"generators/","page":"Dynamical Generators","title":"Dynamical Generators","text":"i fract Ψ = H(t) Ψ","category":"page"},{"location":"generators/","page":"Dynamical Generators","title":"Dynamical Generators","text":"The exact same form is also assumed in open quantum systems,","category":"page"},{"location":"generators/","page":"Dynamical Generators","title":"Dynamical Generators","text":"i fract ρ = L(t) ρ","category":"page"},{"location":"generators/","page":"Dynamical Generators","title":"Dynamical Generators","text":"where L is the Liouvillian up to a factor of i, see liouvillian with convention=:TDSE.","category":"page"},{"location":"generators/#Control-Functions","page":"Dynamical Generators","title":"Control Functions","text":"","category":"section"},{"location":"generators/","page":"Dynamical Generators","title":"Dynamical Generators","text":"While the generator may have an explicit time dependency, in the context of optimal control the time dependency will usually be implicit in a dependency of the generator on one or more control functions. That is, H(t) = H(ϵ_l(t) t). Any object passed to propagate as a generator must implement the following methods:","category":"page"},{"location":"generators/","page":"Dynamical Generators","title":"Dynamical Generators","text":"QuantumPropagators.Controls.getcontrols — extract the controls ϵ_l(t) from H(ϵ_l(t) t)\nQuantumPropagators.Controls.evalcontrols, QuantumPropagators.Controls.evalcontrols! — plug in values for the controls as well as any explicit time dependency to produce a static operator from the time-dependent generator\nQuantumPropagators.Controls.substitute_controls  — replace the controls with different (e.g., optimized) controls, producing a new time-dependent generator","category":"page"},{"location":"generators/","page":"Dynamical Generators","title":"Dynamical Generators","text":"* [`QuantumPropagators.Controls.getcontrolderiv`](@ref) — return ``\\frac{∂ Ĥ(\\{ϵ_{l'}(t)\\}, t)}{∂ ϵ_l(t)}``. The result may be `nothing` if ``Ĥ(t)`` does not depend on the particular ``ϵ_l(t)``, a static operator if ``Ĥ(t)`` is linear in the control ``ϵ_l(t)`` and has no explicit time dependency, or a new time-dependent generator to be evaluated via [`evalcontrols`](@ref QuantumPropagators.Generators.evalcontrols) otherwise.","category":"page"},{"location":"generators/","page":"Dynamical Generators","title":"Dynamical Generators","text":"When writing a custom generator type, the QuantumPropagators.Generators.check_generator routine should be used to check that all of these methods are implemented.","category":"page"},{"location":"generators/#Built-in-[hamiltonian](@ref)-and-[liouvillian](@ref)-Generators.","page":"Dynamical Generators","title":"Built-in hamiltonian and liouvillian Generators.","text":"","category":"section"},{"location":"generators/","page":"Dynamical Generators","title":"Dynamical Generators","text":"While any generator H(t) = H(ϵ_l(t) t) can be implemented via a custom type, the built-in hamiltonian and liouvillian initialize a Generator object encapsulating a generator of the form","category":"page"},{"location":"generators/","page":"Dynamical Generators","title":"Dynamical Generators","text":"H(t) = H_0 + sum_l a_l(ϵ_l(t) t)  H_l","category":"page"},{"location":"generators/","page":"Dynamical Generators","title":"Dynamical Generators","text":"that is, an (optional) drift term H₀ and an arbitrary number of control terms that separate into a scalar control amplitude a_l(ϵ_l(t) t) and a static control operator  H_l.","category":"page"},{"location":"generators/#Control-Amplitudes","page":"Dynamical Generators","title":"Control Amplitudes","text":"","category":"section"},{"location":"generators/","page":"Dynamical Generators","title":"Dynamical Generators","text":"In the form represented by a Generator, the time-dependence of the control terms is via control amplitudes a_l(ϵ_l(t) t), which may depend on one or more control function ϵ_l(t). In most cases, a_l(t)  ϵ_l(t). Any other dependency of the control amplitudes on the control functions must be implemented via a custom type, for which the following methods must be defined:","category":"page"},{"location":"generators/","page":"Dynamical Generators","title":"Dynamical Generators","text":"QuantumPropagators.Controls.getcontrols\nQuantumPropagators.Controls.evalcontrols\nQuantumPropagators.Controls.substitute_controls","category":"page"},{"location":"generators/","page":"Dynamical Generators","title":"Dynamical Generators","text":"These are similar to the equivalent methods for a custom generator. However, QuantumPropagators.Controls.evalcontrols for an amplitude returns a number, not an operator.","category":"page"},{"location":"generators/","page":"Dynamical Generators","title":"Dynamical Generators","text":"Also, [`QuantumPropagators.Controls.getcontrolderiv`](@ref) returns `0.0` if the control amplitude does not depend on a particular control function, instead of `nothing`.","category":"page"},{"location":"generators/","page":"Dynamical Generators","title":"Dynamical Generators","text":"Any custom amplitude implementation should be checked with QuantumPropagators.Generators.check_amplitude","category":"page"},{"location":"generators/#Operators","page":"Dynamical Generators","title":"Operators","text":"","category":"section"},{"location":"generators/","page":"Dynamical Generators","title":"Dynamical Generators","text":"The QuantumPropagators.Controls.evalcontrols method applied to a generator returns a static operator. For any operator object the 5-argument LinearAlgebra.mul! must be implemented to apply the operator to a state.","category":"page"},{"location":"generators/","page":"Dynamical Generators","title":"Dynamical Generators","text":"For a Generator instance obtained from hamiltonian or liouvillian, the resulting operator will be an Operator instance. Any custom type intended as an operator should use QuantumPropagators.Generators.check_operator to verify the implementation.","category":"page"},{"location":"generators/","page":"Dynamical Generators","title":"Dynamical Generators","text":"In practice, an operator might also be used as a generator (for a propagation without any time dependency). For any custom operator type that should support this, the implementation should also be checked with QuantumPropagators.Generators.check_generator.","category":"page"},{"location":"methods/#Propagation-Methods","page":"Propagation Methods","title":"Propagation Methods","text":"","category":"section"},{"location":"methods/#Chebychev-Propagation","page":"Propagation Methods","title":"Chebychev Propagation","text":"","category":"section"},{"location":"methods/","page":"Propagation Methods","title":"Propagation Methods","text":"TODO","category":"page"},{"location":"methods/#Newton-Propagation","page":"Propagation Methods","title":"Newton Propagation","text":"","category":"section"},{"location":"methods/","page":"Propagation Methods","title":"Propagation Methods","text":"TODO","category":"page"},{"location":"methods/#Propagation-with-Explicit-Matrix-Exponentiation","page":"Propagation Methods","title":"Propagation with Explicit Matrix Exponentiation","text":"","category":"section"},{"location":"methods/","page":"Propagation Methods","title":"Propagation Methods","text":"TODO","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"CurrentModule = QuantumPropagators","category":"page"},{"location":"overview/#Overview","page":"Overview","title":"Overview","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"gdefop1hat1\ngdefket1vert1rangle\ngdefLiouvillianmathcalL\ngdefReoperatornameRe\ngdefImoperatornameIm","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"The QuantumPropagators packages provides solvers for the dynamic equations of quantum mechanics, most importantly the Schrödinger and Liouville equations.","category":"page"},{"location":"overview/#Getting-started","page":"Overview","title":"Getting started","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"As a simple \"Hello World\" example, we use the propagate function to simulate a π/2 Rabi flip in a two level system:","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"In a two-level system with ground state ket0 and excited state ket1, a constant driving field between the two levels with a pulse area of π/2 results in a population inversion, transforming the initial state ket0 into -i ket1,","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"using QuantumPropagators: propagate\n\nΨ₀ = ComplexF64[1, 0]  #  = |0⟩\nH = ComplexF64[0 1; 1 0]\ntlist = collect(range(0, π/2, length=101))\n\nΨ = propagate(Ψ₀, H, tlist)\n\nprint(\"Ψ = $(round.(Ψ; digits=3))\\n\")\n\n# output\n\nΨ = ComplexF64[0.0 + 0.0im, 0.0 - 1.0im]","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"Instead of just returning the final state, we can use storage=true to return an array with all the states at every point in the time grid (tlist). This allows us to plot the Rabi oscillation over time:","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"using Plots\ngr() # hide\nusing QuantumPropagators: propagate # hide\nΨ₀ = ComplexF64[1, 0] # hide\nH = ComplexF64[0 1; 1 0] # hide\ntlist = collect(range(0, π/2, length=101)) # hide\nstates = propagate(Ψ₀, H, tlist; storage=true)\nplot(tlist./π, abs.(states').^2; label=[\"ground\" \"excited\"],\n     xlabel=\"pulse area / π\", ylabel=\"population\", legend=:right)","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"The storage parameter provides a powerful way to obtain arbitrary dynamic quantities from the propagation:","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"If given as true, return a storage array with the propagated states at each point in time instead of just the final state.\nIf given a pre-allocated storage array, fill it with the propagated states at each point in time, and return the final state.\nIf given in combination with observables, put arbitrary \"observable\" data derived from the propagated states in the storage array.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"See Storage of states or expectation values for details.","category":"page"},{"location":"overview/#Propagation-methods","page":"Overview","title":"Propagation methods","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"When propagate is called without keyword arguments (or with method=:auto), an appropriate propagation method is determined automatically based on the properties of the state and generator. In the above example of a two-level system, this is method=:expprop which solves the Schrödinger equation by exponentiating generator to construct the time evolution operator opU = exp-i opH dt in each time step explicitly, and applying it to the state. This is the most appropriate method for very small systems, especially a two-level system.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"A specific propagation method can be forced by passing the method keyword argument to propagate. The following methods are built-in:","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"method=:expprop: Solve the piecewise-constant Schrödinger or Liouville equation by explicity matrix exponentiation\nmethod=:cheby: Solve the piecewise-constant Schrödinger equation (Hermitian operators)\nmethod=:newton: Solve the piecewise constant Liouville equation or non-Hermitian Schrödinger equation","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"The Schrödinger equation is (ħ = 1)","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"i fracpartialpartial t ketPsi(t) = opH(t) ketPsi(t)","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"For open quantum systems, we assume the Liouville equation","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"i fracpartialpartial t hatrho(t) = Liouvillian(t) hatrho(t)","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"which differs from most textbooks by a factor of i, but has the benefit that it is structurally identical to the Schrödinger equation, so that the propagation methods do not actually need to know whether they are propagating a Hilbert space vector or a (vectorized) density matrix. See QuantumControl.liouvillian with convention=:LvN for how to construct an appropriate Liouvillian.","category":"page"},{"location":"overview/#Dynamic-generators","page":"Overview","title":"Dynamic generators","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"In the above example, the \"generator\" H that is the second argument to propagate was a simple static operator. In general, we will want time-dependent Hamiltonians or Liouvillians. The standard way to initialize a time-dependent Hamiltonian is via the hamiltonian function, e.g., as  hamiltonian(Ĥ₀, (Ĥ₁, ϵ₁), (Ĥ₂, ϵ₂)). The Ĥ₀, Ĥ₁, and Ĥ₂ are static operators, and ϵ₁ and ϵ₂ are control fields, typically functions of time t. For piecewise-constant propagators, ϵ₁ nad ϵ₂ may also be an array of amplitude values appropriate to the time grid tlist. The tuple-syntax for the time-dependent terms is inspired by QuTiP.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"Generally, the generator, or the operators/controls inside the tuples can be a arbitrary objects, as long as some relevant methods are implemented for these objects, see the full section on Dynamic Generators.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"Open quantum systems are handled identically to closed quantum system, except that Hamiltonian operator are replaced by Liouvillian super-operators. For any system of non-trivial Hilbert space dimension, all (super-)operators should be sparse matrices.","category":"page"},{"location":"overview/#The-Propagator-interface","page":"Overview","title":"The Propagator interface","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"As a lower-level interface than propagate, the QuantumPropagators package defines an interface for \"propagator\" objects. These are initialized via initprop as, e.g.,","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"using QuantumPropagators: initprop\n\npropagator = initprop(Ψ₀, H, tlist)","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"The propagator is a propagation-method-dependent object with the interface described by AbstractPropagator.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"The  propstep! function can then be used to advance the propagator:","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"DocTestSetup = quote\n    using QuantumPropagators: initprop\n    propagator = initprop(Ψ₀, H, tlist)\nend","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"using QuantumPropagators: propstep!\n\nΨ = propstep!(propagator)  # single step\n\nwhile !isnothing(propstep!(propagator)); end  # go to end\nΨ = propagator.state\n\nprint(\"Ψ = $(round.(Ψ; digits=3)))\\n\")\nprint(\"t = $(round(propagator.t / π; digits=3))π\\n\")\n\n# output\n\nΨ = ComplexF64[0.0 + 0.0im, 0.0 - 1.0im])\nt = 0.5π","category":"page"},{"location":"overview/#Backward-propagation","page":"Overview","title":"Backward propagation","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"When propagate or initprop are called with backward=true, the propagation is initialized to run backward. The initial state is then defined at propagator.t == tlist[end] and each propstep! moves to the previous point in tlist. The equation of motion is the Schrödinger or Liouville equation with a negative dt. Note that the propagation uses the generator as it is defined: no automatic adjoint will be taken.","category":"page"},{"location":"overview/#Connection-to-DifferentialEquations.jl","page":"Overview","title":"Connection to DifferentialEquations.jl","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"The QuantumPropagators API is structured similarly to the DifferentialEquations.jl","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"The propagate function is similar to DifferentialEquations.solve\nThe initprop function is similar to DifferentialEquations.init\nThe reinitprop! function is similar to DifferentialEquations.reinit!\nThe Propagator interface is similar to DifferentialEquations' Integrator Interface\npropstep! corresponds to DifferentialEquations.step!\nset_state! corresponds to DifferentialEquations.set_u!\nset_t! corresponds to DifferentialEquations.set_t!","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"Note that the equation of motion for QuantumPropagators is implicit in the propagation method (usually the Schrödinger/Liouville equation), so the initialization of a Propagator via the initial state and the \"generator\" is more specialized than DifferentialEquations' Problem Interface.","category":"page"},{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Pages=[\n    \"1.md\",  # driven harmonic oscillator in energy basis (ground state, apply force, let oscillate)\n    \"2.md\",  # driven harmonic oscillator with wave packages\n    # driven harmonic oscillator with dissipation\n]\nDepth = 1","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = QuantumPropagators","category":"page"},{"location":"#QuantumPropagators","page":"Home","title":"QuantumPropagators","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The QuantumPropagators package implements methods for simulating the time dynamics of a quantum system. It is the numerical backend for all packages implementing methods of optimal control within the JuliaQuantumControl organization.","category":"page"},{"location":"#Contents","page":"Home","title":"Contents","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages=[\n \"overview.md\",\n \"generators.md\",\n \"methods.md\",\n \"storage.md\",\n \"examples/index.md\",\n \"howto.md\",\n \"benchmarks.md\",\n \"api/quantumpropagators.md\",\n]\nDepth = 2","category":"page"},{"location":"#History","page":"Home","title":"History","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"See the Releases on Github.","category":"page"}]
}
