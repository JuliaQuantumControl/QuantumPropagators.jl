var documenterSearchIndex = {"docs":
[{"location":"benchmarks/#Benchmarks","page":"Benchmarks","title":"Benchmarks","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"Pages=[\n \"benchmarks/profiling.md\",\n]\nDepth = 2","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"<iframe src=\"fig.html\" style=\"height:500px;width:100%;\"></iframe>","category":"page"},{"location":"howto/#Howtos","page":"Howtos","title":"Howtos","text":"","category":"section"},{"location":"howto/","page":"Howtos","title":"Howtos","text":"gdefop1hat1\ngdefLiouvillianmathcalL\ngdefReoperatornameRe\ngdefImoperatornameIm","category":"page"},{"location":"howto/#How-to-implement-a-new-propagation-method","page":"Howtos","title":"How to implement a new propagation method","text":"","category":"section"},{"location":"howto/","page":"Howtos","title":"Howtos","text":"Define a new sub-type of AbstractPropagator type that is unique to the propagation method, e.g. MyNewMethodPropagator. If appropriate, sub-type PiecewisePropagator or PWCPropagator.\nThe high-level propagate and init_prop functions have a mandatory method keyword argument. That argument should receive a Module object for the module implementing a propagation method (e.g., using QuantumPropagators: Cheby; method=Cheby). This ensures that the module or package implementing the method is fully loaded. Internally, init_prop delegates method=module to a positional argument method = Val(nameof(module))\nThus, if MyNewMethodPropagator is implemented in a module MyNewMethod, or if it wraps a registered package MyNewMethod, implement a new init_prop method with the following signature:\nfunction init_prop(\n    state,\n    generator,\n    tlist,\n    method::Val{:MyNewMethod};\n    inplace=true,\n    backward=false,\n    verbose=false,\n    parameters=nothing,\n    # ... method-specific keyword arguments\n    _...  # ignore other keyword arguments\n)\nNote the method::Val{:MyNewMethod} as the fourth positional (!) parameter. While the public interface for init_prop takes method as a keyword argument, privately init_prop dispatches for different methods as above.\nIf the propagation method is not associated with a module or package, it is also possible to implement a method init_prop with a fourth positional argument with a type of, e.g., ::Val{:my_new_method}. This would allow to call the high-level propagate/init_prop with the keyword argument method=:my_new_method, i.e., passing a name (Symbol) instead of a Module.\nImplement the remaining methods in The Propagator interface.\nTest the implementation by instantiating a propagator and calling QuantumPropagators.Interfaces.check_propagator on it.","category":"page"},{"location":"howto/#How-to-specify-the-spectral-range-for-a-Chebychev-propagation","page":"Howtos","title":"How to specify the spectral range for a Chebychev propagation","text":"","category":"section"},{"location":"howto/","page":"Howtos","title":"Howtos","text":"A propagation with method=Cheby requires that the dynamic generator opH(t) be normalized to a spectral range of [-1, 1]. That is, the method needs a (pessimistic) estimate of the \"spectral envelope\": the minimum and maximum eigenvalue of opH(t) for any point t on the interval of the propagation time grid tlist.","category":"page"},{"location":"howto/","page":"Howtos","title":"Howtos","text":"By default, the Chebychev propagator uses heuristics to estimate  this spectral envelope. If the spectral envelope is known (either analytically of via a separate numerical exploration of the eigenvalues over the full range of possible controls), the minimum and maximum eigenvalues of opH(t) can be passed as keyword arguments E_min and E_max to propagate or init_prop. Since the Chebychev method is only defined for Hermitian generators, E_min and E_max must be real values. Both values must be given.","category":"page"},{"location":"howto/","page":"Howtos","title":"Howtos","text":"Manually specifying E_min and E_max works with the default specrange_method=:auto as well as with the explicit specrange_method=:manual. When calculating the Chebychev coefficients, the given values may still be enlarged by the default specrange_buffer keyword argument in init_prop. If E_min and E_max should be used exactly, pass specrange_buffer=0.","category":"page"},{"location":"howto/#howto_parameterized","page":"Howtos","title":"How to define a parameterized control","text":"","category":"section"},{"location":"howto/","page":"Howtos","title":"Howtos","text":"Parameterized controls are function-like objects with an associated vector of parameter values that must be accessible via QuantumPropagators.Controls.get_parameters.","category":"page"},{"location":"howto/","page":"Howtos","title":"Howtos","text":"It is recommended to define a parameterized control as a subtype of QuantumPropagators.Controls.ParameterizedFunction. The packages ComponentArrays and UnPack might be useful in the implementing of a suitable type . For example,","category":"page"},{"location":"howto/","page":"Howtos","title":"Howtos","text":"using ComponentArrays\nusing UnPack: @unpack\nusing QuantumPropagators.Controls: ParameterizedFunction, get_parameters\n\nstruct GaussianControl <: ParameterizedFunction\n    parameters::ComponentVector{Float64,Vector{Float64},Tuple{Axis{(A=1, t0=2, sigma=3)}}}\nend\n\nfunction GaussianControl(; A=1.0, t0=0.0, sigma=1.0)\n    return GaussianControl(ComponentVector(; A, t0, sigma))\nend\n\nfunction (control::GaussianControl)(t)\n    @unpack A, t0, sigma = control.parameters\n    return A * exp(- (t - t0)^2 / (2 * sigma^2))\nend\n\n# usage\n\ngaussian = GaussianControl(A=2.0, sigma=0.5)\ngaussian.parameters.t0 = 5  # shift center from original 0.0\n\n@show get_parameters(gaussian)\nprintln(\"gaussian(4.5) = $(round(gaussian(4.5); digits=3))\")\n\n# output\n\nget_parameters(gaussian) = (A = 2.0, t0 = 5.0, sigma = 0.5)\ngaussian(4.5) = 1.213","category":"page"},{"location":"howto/","page":"Howtos","title":"Howtos","text":"We could put some extra effort into giving direct property access to all parameters and to provide unicode-aliases for all parameters:","category":"page"},{"location":"howto/","page":"Howtos","title":"Howtos","text":"using ComponentArrays\nusing QuantumPropagators.Controls: ParameterizedFunction, get_parameters\n\nstruct GaussianControl <: ParameterizedFunction\n    parameters::ComponentVector{Float64,Vector{Float64},Tuple{Axis{(A=1, t0=2, sigma=3)}}}\nend\n\nfunction GaussianControl(; A=1.0, t0=0.0, t₀=t0, sigma=1.0, σ=sigma)\n    return GaussianControl(ComponentVector(; A, t0=t₀, sigma=σ))\nend\n\nfunction Base.propertynames(g::GaussianControl, private::Bool=false)\n    names = (:A, :t0, :t₀, :sigma, :σ)\n    return private ? Tuple(union(names, fieldnames(GaussianControl))) : names\nend\n\nfunction Base.getproperty(g::GaussianControl, name::Symbol)\n    unicode_aliases = Dict(:σ => :sigma, :t₀ => :t0)\n    getproperty(get_parameters(g), get(unicode_aliases, name, name))\nend\n\nfunction Base.setproperty!(g::GaussianControl, name::Symbol, value)\n    unicode_aliases = Dict(:σ => :sigma, :t₀ => :t0)\n    setproperty!(\n        get_parameters(g),\n        get(unicode_aliases, name, name),\n        value\n    )\nend\n\nfunction (control::GaussianControl)(t)\n    A, t₀, σ = get_parameters(control)\n    return A * exp(- (t - t₀)^2 / (2 * σ^2))\nend\n\n# usage\n\ngaussian = GaussianControl(A=2.0, σ=0.5)\ngaussian.t₀ = 5  # shift center from original 0.0\n\n@show get_parameters(gaussian)\nprintln(\"gaussian(4.5) = $(round(gaussian(4.5); digits=3))\")\n\n# output\n\nget_parameters(gaussian) = (A = 2.0, t0 = 5.0, sigma = 0.5)\ngaussian(4.5) = 1.213","category":"page"},{"location":"howto/","page":"Howtos","title":"Howtos","text":"The QuantumPropagators.Interfaces.check_parameterized_function can be used to verify the implementation of a ParameterizedFunction.","category":"page"},{"location":"references/#References","page":"References","title":"References","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"H. Tal-Ezer and R. Kosloff. An Accurate and Efficient Scheme for Propagating the Time Dependent Schrödinger Equation. J. Chem. Phys. 81, 3967 (1984).\n\n\n\nR. Kosloff. Time-Dependent Quantum-Mechanical Methods for Molecular Dynamics. J. Chem. Phys. 92, 2087 (1988).\n\n\n\nM. Berman, R. Kosloff and H. Tal-Ezer. Solution of the time-dependent Liouville-von Neumann equation: dissipative evolution. J. Phys. A 25, 1283 (1992).\n\n\n\nR. Kosloff. Propagation Methods for Quantum Molecular Dynamics. Annu. Rev. Phys. Chem. 45, 145 (1994).\n\n\n\nG. Ashkenazi, R. Kosloff, S. Ruhman and H. Tal-Ezer. Newtonian propagation methods applied to the photodissociation dynamics of I_3^-. J. Chem. Phys. 103, 10005–10014 (1995).\n\n\n\nD. Lucarelli. Quantum optimal control via gradient ascent in function space and the time-bandwidth quantum speed limit. Phys. Rev. A 97, 062346 (2018).\n\n\n\nS. Machnes, E. Assémat, D. Tannor and F. K. Wilhelm. Tunable, Flexible, and Efficient Optimization of Control Pulses for Practical Qubits. Phys. Rev. Lett. 120, 150401 (2018).\n\n\n\nJ. J. Sørensen, M. O. Aranburu, T. Heinzel and J. F. Sherson. Quantum optimal control in a chopped basis: Applications in control of Bose-Einstein condensates. Phys. Rev. A 98, 022119 (2018).\n\n\n\nM. H. Goerz. Optimizing Robust Quantum Gates in Open Quantum Systems. Ph.D. Thesis, Universität Kassel (2015).\n\n\n\nH. Tal-Ezer. On Restart and Error Estimation for Krylov Approximation of w=f(A)v. SIAM J. Sci. Comput. 29, 2426 (2007).\n\n\n\nT. Caneva, T. Calarco and S. Montangero. Chopped random-basis quantum optimization. Phys. Rev. A 84, 022326 (2011).\n\n\n\n","category":"page"},{"location":"storage/#Expectation-Values","page":"Expectation Values","title":"Expectation Values","text":"","category":"section"},{"location":"storage/","page":"Expectation Values","title":"Expectation Values","text":"The propagate routine allows the storage of data for every point of the time grid.  This is done by passing it a storage object created with QuantumPropagators.Storage.init_storage, or simply storage=true in order to create the appropriate storage automatically.","category":"page"},{"location":"storage/","page":"Expectation Values","title":"Expectation Values","text":"By default, the storage will be used to store the propagated states at each point in time. However, more generally, what goes into storage can be customized via the observables parameter of propagate. This allows to obtain arbitrary expectation values from the propagation. In short, the following options are available:","category":"page"},{"location":"storage/","page":"Expectation Values","title":"Expectation Values","text":"Pass observables as a tuple of functions that each take the propagated state Ψ and return some expectation value.\nFor time-dependent expectation values, the functions may take positional parameters tlist and i in addition to Ψ, that is, (Ψ, tlist, i) -> value, for an expectation value at time tlist[i].\nPass observables as a tuple of matrices for which to calculate expectation values via the three-argument dot function. This assumes the propagated state to be a vector.\nFor maximum flexibility, pass observables as a tuple of arbitrary objects for which a custom map_observable method has been defined, or pass observables as a single object for which a custom map_observables method has been defined.","category":"page"},{"location":"storage/#Details","page":"Expectation Values","title":"Details","text":"","category":"section"},{"location":"storage/","page":"Expectation Values","title":"Expectation Values","text":"After each propagation step, with a propagated state at time slot i,","category":"page"},{"location":"storage/","page":"Expectation Values","title":"Expectation Values","text":"data = QuantumPropagators.Storage.map_observables(observables, tlist, i, state) generates data from the propagated state\nQuantumPropagators.Storage.write_to_storage!(storage, i, data) places that data into storage for time slot i","category":"page"},{"location":"storage/","page":"Expectation Values","title":"Expectation Values","text":"After propagate returns, the QuantumPropagators.Storage.get_from_storage! routine can be used to extract data from any time slot. This interface hides the internal memory organization of storage, which is set up by init_storage based on the type of state and the given observables. This system can be extended with multiple dispatch, allowing to optimize the storage for custom data types. Obviously, init_storage, map_observables, write_to_storage!, and get_from_storage! must all be consistent.","category":"page"},{"location":"storage/","page":"Expectation Values","title":"Expectation Values","text":"The default implementation of these routine uses either a standard Vector or a Matrix as storage.","category":"page"},{"location":"storage/","page":"Expectation Values","title":"Expectation Values","text":"Roughly speaking, when storing states, if the state of some arbitrary type, the storage will be a Vector where the i'th entry points to a copy of the propagated state at the i'th time slot. If the state is a Vector, the storage will be a Matrix containing the state for the i'th time slot in the i'th column.","category":"page"},{"location":"storage/","page":"Expectation Values","title":"Expectation Values","text":"When a tuple of observables is passed to propagate, if map_observables returns data of the same type for each observable, storage will be a Matrix containing the values from the different observables for the i'th time slot in the i'th column. This would be typical for the storage of expectation values, e.g. with","category":"page"},{"location":"storage/","page":"Expectation Values","title":"Expectation Values","text":"observables=(state->dot(state, Ô₁, state), state->dot(state, Ô₂, state))","category":"page"},{"location":"storage/","page":"Expectation Values","title":"Expectation Values","text":"where Ô₁, Ô₂ are two Hermitian operators. In this case, storage would be a 2 × nt Float64 array. Calling get_from_storage!(data, storage, i) would be equivalent to copyto!(data, storage[:,i]) and extract the i'th column of storage, i.e. the vector [⟨Ô₁⟩, ⟨Ô₂A]⟩] at time slot i. Alternatively, storage[1,:] would return the values of ⟨Ô₁⟩ over time. This would be useful for plotting, and illustrates the benefits of using a Matrix as storage.","category":"page"},{"location":"storage/","page":"Expectation Values","title":"Expectation Values","text":"Usually, the observables should be functions acting on the state, but map_observables can be extended to other types of observables as well. For example, the situation were state is a vector and the observables are matrices is also supported; if  Ô₁, Ô₂ are matrices,","category":"page"},{"location":"storage/","page":"Expectation Values","title":"Expectation Values","text":"observables=(Ô₁, Ô₂)","category":"page"},{"location":"storage/","page":"Expectation Values","title":"Expectation Values","text":"would have the same result of storing the expectation values of those two operators.","category":"page"},{"location":"storage/","page":"Expectation Values","title":"Expectation Values","text":"The observables are not required to yield real values: the term \"observable\" is used very loosely here. We could directly calculate, e.g., the complex amplitude α of a coherent state in quantum optics, or the number of levels with non-zero population (as an integer).","category":"page"},{"location":"storage/","page":"Expectation Values","title":"Expectation Values","text":"It is possible to have time-dependent \"observables\", for example, to store \"lab-frame\" states from a propagation in a (time-dependent) rotating frame. This is supported by default by passing a function with the three arguments state, tlist, i as an observable, where state is defined to be at time tlist[i].","category":"page"},{"location":"storage/","page":"Expectation Values","title":"Expectation Values","text":"If there are multiple observables that return data of different types, by default storage will be a Vector that contains tuples with the result for each observable. For example, with","category":"page"},{"location":"storage/","page":"Expectation Values","title":"Expectation Values","text":"observables=(state->dot(state, Ô₁, state), state->count_poplevels(state))","category":"page"},{"location":"storage/","page":"Expectation Values","title":"Expectation Values","text":"where count_poplevels is a function that counts the number of levels with non-zero population, the resulting storage would be a Vector{Tuple{Float64, Int64}}.","category":"page"},{"location":"storage/","page":"Expectation Values","title":"Expectation Values","text":"If there is a single observable that yields a vector, that vector is stored in the i'th column of a storage matrix. This is in fact what happens when storing the propagated states (observables=(Ψ->copy(Ψ), )) if Ψ is a Vector, but there are other use cases, such as calculating the population in all levels in one go, with observables=(Ψ -> abs.(Ψ).^2, ).","category":"page"},{"location":"storage/","page":"Expectation Values","title":"Expectation Values","text":"If there is a single variable that yields a non-vector object, storage will be a Vector where the i'th entry points to the object. This is in fact what happens by default when storing states  that are e.g. instances of QuantumOptics.Ket. In such a case, it might be advisable to add new methods for QuantumPropagators.Storage.init_storage and QuantumPropagators.Storage.write_to_storage! that implement a more efficient in-place storage.","category":"page"},{"location":"api/quantumpropagators/","page":"API","title":"API","text":"EditURL = \"../../generate_api.jl\"","category":"page"},{"location":"api/quantumpropagators/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/quantumpropagators/#QuantumPropagatorsAPI","page":"API","title":"QuantumPropagators","text":"","category":"section"},{"location":"api/quantumpropagators/","page":"API","title":"API","text":"The highest-level API of the QuantumPropagators.jl package (apart from some convenience functions) consists of a single function:","category":"page"},{"location":"api/quantumpropagators/","page":"API","title":"API","text":"propagate — Propagate a quantum state over an entire time grid under a given generator","category":"page"},{"location":"api/quantumpropagators/","page":"API","title":"API","text":"At a slightly lower level, propagation of quantum states in encapsulated by The Propagator interface:","category":"page"},{"location":"api/quantumpropagators/","page":"API","title":"API","text":"init_prop — Initialize a propagator object, which is of some concrete (method-dependent) sub-type of AbstractPropagator\nreinit_prop! — Re-initialize the propagator\nprop_step! — Advance the propagator  by a single time step forward or backward","category":"page"},{"location":"api/quantumpropagators/","page":"API","title":"API","text":"In some cases, the ability to mutate the propagator after each propagation step can be useful. This can be achieved with the following private methods:","category":"page"},{"location":"api/quantumpropagators/","page":"API","title":"API","text":"set_state! — Mutate the current quantum state of the propagator (not exported)\nset_t! — Mutate the current time of the propagator (not exported)","category":"page"},{"location":"api/quantumpropagators/","page":"API","title":"API","text":"The dynamics of a quantum state are determined by a time-dependent dynamical generator (a Hamiltonian or Liouvillian). The QuantumPropagators package re-exports the two main initialization routines for generators from QuantumPropagators.Generators:","category":"page"},{"location":"api/quantumpropagators/","page":"API","title":"API","text":"hamiltonian — Construct a time-dependent generator for a propagation in Hilbert space under the Schrödinger equation\nliouvillian — Construct a time-dependent generator for a propagation in Liouville space under the master equation in Lindblad form","category":"page"},{"location":"api/quantumpropagators/","page":"API","title":"API","text":"To set up the time-dependent control fields in a Hamiltonian, methods from the submodules QuantumPropagators.Controls, QuantumPropagators.Shapes, and QuantumPropagators.Amplitudes can be used.","category":"page"},{"location":"api/quantumpropagators/","page":"API","title":"API","text":"The above constitutes the main interface of QuantumPropagators. At the lowest level, further functionality is provided by sub-modules like QuantumPropagators.Cheby, which defines a standalone API specifically for the Chebychev propagation method. The full list of sub-modules and their public members is:","category":"page"},{"location":"api/quantumpropagators/","page":"API","title":"API","text":"QuantumPropagators.Amplitudes\nLockedAmplitude\nShapedAmplitude\nQuantumPropagators.Arnoldi\nQuantumPropagators.Cheby\nChebyWrk\ncheby\ncheby!\ncheby_coeffs\ncheby_coeffs!\nQuantumPropagators.Controls\nParameterizedFunction\ndiscretize\ndiscretize_on_midpoints\nevaluate\nevaluate!\nget_controls\nget_parameters\nget_tlist_midpoints\nsubstitute\nt_mid\nQuantumPropagators.ExpProp\nExpPropWrk\nexpprop!\nQuantumPropagators.Generators\nGenerator\nOperator\nScaledOperator\nhamiltonian\nliouvillian\nQuantumPropagators.Interfaces\ncheck_amplitude\ncheck_control\ncheck_generator\ncheck_operator\ncheck_parameterized\ncheck_parameterized_function\ncheck_propagator\ncheck_state\ncheck_tlist\nsupports_inplace\nQuantumPropagators.Newton\nNewtonWrk\nnewton!\nQuantumPropagators.Shapes\nblackman\nbox\nflattop\nQuantumPropagators.SpectralRange\nspecrange\nQuantumPropagators.Storage\nget_from_storage\nget_from_storage!\ninit_storage\nmap_observable\nmap_observables\nwrite_to_storage!","category":"page"},{"location":"api/quantumpropagators/#Convenience-functions","page":"API","title":"Convenience functions","text":"","category":"section"},{"location":"api/quantumpropagators/","page":"API","title":"API","text":"There are some \"convenience functions\" that wrap around propagate for common tasks:","category":"page"},{"location":"api/quantumpropagators/","page":"API","title":"API","text":"propagate_sequence","category":"page"},{"location":"api/quantumpropagators/#Reference-for-top-level-QuantumPropagators-module","page":"API","title":"Reference for top-level QuantumPropagators module","text":"","category":"section"},{"location":"api/quantumpropagators/","page":"API","title":"API","text":"Public Members:","category":"page"},{"location":"api/quantumpropagators/","page":"API","title":"API","text":"Propagation\ninit_prop\nprop_step!\npropagate\npropagate_sequence\nreinit_prop!","category":"page"},{"location":"api/quantumpropagators/","page":"API","title":"API","text":"Re-exported Members:","category":"page"},{"location":"api/quantumpropagators/","page":"API","title":"API","text":"hamiltonian\nliouvillian","category":"page"},{"location":"api/quantumpropagators/","page":"API","title":"API","text":"Private Members:","category":"page"},{"location":"api/quantumpropagators/","page":"API","title":"API","text":"PWCPropagator\nNewtonPropagator\nenable_timings\ntimings_enabled\ndisable_timings\nChebyPropagator\nExpPropagator\ncheby_get_spectral_envelope\nPiecewisePropagator\nset_state!\node_function\nset_t!\nAbstractPropagator","category":"page"},{"location":"api/quantumpropagators/#Public-members","page":"API","title":"Public members","text":"","category":"section"},{"location":"api/quantumpropagators/","page":"API","title":"API","text":"QuantumPropagators.Propagation\nQuantumPropagators.init_prop\nQuantumPropagators.prop_step!\nQuantumPropagators.propagate\nQuantumPropagators.propagate_sequence\nQuantumPropagators.reinit_prop!","category":"page"},{"location":"api/quantumpropagators/#QuantumPropagators.Propagation","page":"API","title":"QuantumPropagators.Propagation","text":"Wrapper around the parameters of a call to propagate.\n\nPropagation(\n    generator, tlist;\n    pre_propagation=nothing, post_propagation=nothing,\n    kwargs...\n)\n\nPropagation(\n    propagator;\n    pre_propagation=nothing, post_propagation=nothing,\n    kwargs...\n)\n\nis a wrapper around the arguments for propagate / init_prop, for use within propagate_sequence.\n\nThe positional and keyword arguments are those accepted by the above propagation routines, excluding the initial state. A Propagation may in addition include the pre_propagation and post_propagation keyword arguments recognized by propagate_sequence.\n\n\n\n\n\n","category":"type"},{"location":"api/quantumpropagators/#QuantumPropagators.init_prop","page":"API","title":"QuantumPropagators.init_prop","text":"Initialize a Propagator.\n\npropagator = init_prop(\n    state, generator, tlist;\n    method,  # mandatory keyword argument\n    backward=false,\n    inplace=QuantumPropagators.Interfaces.supports_inplace(state),\n    piecewise=nothing,\n    pwc=nothing,\n    kwargs...\n)\n\ninitializes a propagator for the time propagation of the given state over a time grid tlist under the time-dependent generator (Hamiltonian/Liouvillian) generator.\n\nArguments\n\nstate: The \"initial\" state for the propagation. For backward=false, this state is taken to be at initial time (tlist[begin]); and for backward=true, at the final time (tlist[end])\ngenerator: The time-dependent generator of the dynamics\ntlist: The time grid over which which the propagation is defined. This may or may not be equidistant.\n\nMandatory keyword arguments\n\nmethod: The propagation method to use. May be given as a name (Symbol), but the recommended usage is to pass a module implementing the propagation method, e.g., using QuantumPropagators: Cheby; method = Cheby. Passing a module ensures that the code implementing the method is correctly loaded. This is particularly important for propagators using third-party backends, like with method=OrdinaryDiffEq.\n\nOptional keyword arguments\n\nbackward: If true, initialize the propagator for a backward propagation. The resulting propagator.t will be tlist[end], and subsequent calls to prop_step! will move backward on tlist.\ninplace: If true, the state property of the resulting propagator will be changed in-place by any call to prop_step!. If false, each call to prop_step! changes the reference for propagator.state, and the propagation will not use any in-place operations. Not all propagation methods may support both in-place and not-in-place propagation. In-place propagation is generally more efficient for larger Hilbert space dimensions, but may not be compatible, e.g., with automatic differentiation.\npiecewise: If given as a boolean, true enforces that the resulting propagator is a PiecewisePropagator, and false enforces that it not a PiecewisePropagator. For the default piecewise=nothing, whatever type of propagation is the default for the given method will be used. Throw an error if the given method does not support the required type of propagation.\npwc: Like piecewise, but for the stronger PWCPropagator.\n\nAll other kwargs are method-dependent and are ignored for methods that do not support them.\n\nThe type of the returned propagator is a sub-type of AbstractPropagator, respectively a sub-type of PiecewisePropagator if piecewise=true or a sub-type of PWCPropagator if pwc=true.\n\nInternals\n\nInternally, the (mandatory) keyword method is converted into a fourth positional argument. This allows propagation methods to define their own implementation of init_prop via multiple dispatch. However, when calling init_prop in high-level code, method must always be given as a keyword argument.\n\nSee also\n\nreinit_prop! — Re-initialize a propagator\npropagate — Higher-level propagation interface\n`check_propagator — a function to verify the interface described above.\n\n\n\n\n\nusing QuantumPropagators: Cheby\n\ncheby_propagator = init_prop(\n    state,\n    generator,\n    tlist;\n    method=Cheby,\n    inplace=QuantumPropagators.Interfaces.supports_inplace(state),\n    backward=false,\n    verbose=false,\n    parameters=nothing,\n    control_ranges=nothing,\n    specrange_method=:auto,\n    specrange_buffer=0.01,\n    cheby_coeffs_limit=1e-12,\n    check_normalization=false,\n    specrange_kwargs...\n)\n\ninitializes a ChebyPropagator.\n\nMethod-specific keyword arguments\n\ncontrol_ranges: a dict the maps the controls in generator (see get_controls) to a tuple of min/max values. The Chebychev coefficients will be calculated based on a spectral envelope that assumes that each control can take arbitrary values within the min/max range. If not given, the ranges are determined automatically. Specifying manual control ranges can be useful when the the control amplitudes (parameters) may change during the propagation, e.g. in a sequential-update control scheme.\nspecrange_method: Method to pass to the specrange function\nspecrange_buffer: An additional factor by which to enlarge the estimated  spectral range returned by specrange, in order to ensure that Chebychev coefficients are based on an overestimation of the spectral range.\ncheby_coeffs_limit: The maximum magnitude of Chebychev coefficients that should be treated as non-zero\ncheck_normalization: Check whether the Hamiltonian has been properly normalized, i.e., that the spectral range of generator has not been underestimated. This slowes down the propagation, but is advisable for novel generators.\nuniform_dt_tolerance=1e-12: How much the intervals of tlist are allowed to vary while still being considered constant.\nspecrange_kwargs: All further keyword arguments are passed to the specrange function. Most notably, with the default specrange_method=:auto (or specrange_method=:manual), passing E_min and E_max allows to manually specify the spectral range of generator.\n\n\n\n\n\nusing QuantumPropagators: Newton\n\nnewton_propagator = init_prop(\n    state,\n    generator,\n    tlist;\n    method=Newton,\n    inplace=QuantumPropagators.Interfaces.supports_inplace(state),\n    backward=false,\n    verbose=false,\n    parameters=nothing,\n    m_max=10,\n    func=(z -> exp(-1im * z)),\n    norm_min=1e-14,\n    relerr=1e-12,\n    max_restarts=50,\n    _...\n)\n\ninitializes a NewtonPropagator.\n\nMethod-specific keyword arguments\n\nm_max: maximum Krylov dimension, cf. NewtonWrk\nfunc, norm_min, relerr, max_restarts: parameter to pass to newton!\n\n\n\n\n\nusing QuantumPropagators: ExpProp\n\nexp_propagator = init_prop(\n    state,\n    generator,\n    tlist;\n    method=ExpProp,\n    inplace=QuantumPropagators.Interfaces.supports_inplace(state),\n    backward=false,\n    verbose=false,\n    parameters=nothing,\n    func=(H_dt -> exp(-1im * H_dt))\n    convert_state=_exp_prop_convert_state(state),\n    convert_operator=_exp_prop_convert_operator(generator),\n    _...\n)\n\ninitializes an ExpPropagator.\n\nMethod-specific keyword arguments\n\nfunc: The function to evaluate. The argument H_dt is obtained by constructing an operator H from generator via the evaluate function and the multiplied with the time step dt for the current time interval. The propagation then simply multiplies the return value of func with the current state\nconvert_state:  Type to which to temporarily convert states before multiplying the return value of func.\nconvert_operator: Type to which to convert the operator H before multiplying it with dt and plugging the result into func\n\nThe convert_state and convert_operator parameters are useful for when the generator and or state are unusual data structures for which the relevant methods to calculate func are not defined. Often, it is easier to temporarily convert them to standard complex matrices and vectors than to implement the missing methods.\n\n\n\n\n\nusing OrdinaryDiffEq  # or: `using DifferentialEquations`\n\node_propagator = init_prop(\n    state,\n    generator,\n    tlist;\n    method=OrdinaryDiffEq,  # or: `method=DifferentialEquations`\n    inplace=QuantumPropagators.Interfaces.supports_inplace(state),\n    backward=false,\n    verbose=false,\n    parameters=nothing,\n    piecewise=false,\n    pwc=false,\n    alg=OrdinaryDiffEq.Tsit5(),\n    solver_options...\n)\n\ninitializes a propagator that uses an ODE solver from the OrdinaryDiffEq.jl package as a backend.\n\nBy default, the resulting propagator is for time-continuous controls that can be evaluated with evaluate(control, t) for any t in the range of tlist[begin] to tlist[end]. The controls may be parametrized, see get_parameters. Any parameters will be available in the parameters attribute of the resulting ode_propagator, as a dictionary mapping controls to a vector of parameter values. Mutating ode_propagator.parameters[control] will be reflected in any subsequent call to prop_step!.\n\nIf pwc=true (or, equivalently piecewise=true), all controls will be discretized with discretize_on_midpoints and the propagation will be for piecewise constant dynamics. The resulting ode_propagator will be an instance of PWCPropagator, with the corresponding semantics. In particular, the ode_propatator.parameters will be a mapping of controls to discretized pulse values, not the analytical parameters obtained with get_parameters(control) as in the default case.\n\nInternally, the generator will be wrapped with QuantumPropagators.ode_function. The resulting function f will be called internally as f(ϕ, Ψ, vals_dict, t) or f(Ψ, vals_dict, t) depending on the inplace keyword argument.\n\nMethod-specific keyword arguments\n\npwc: Whether to propagate for piecewise-constant controls or, with the default pwc=false, for time-continuous controls.\npiecewise: Currently equivalent to pwc, but future version may change  this to allow for other piecewise (e.g., piecewise-linear) controls.\nparameters: If given, a mapping of controls to parameter values (pwc=false) or pulse values on the intervals of the time grid (pwc=true). By default, the parameters are determined automatically using get_parameters, respectively discretize_on_midpoints if pwc=true. If they are given manually, they must follow the exact same semantics. In particular, for pwc=false, any parameters must alias the parameters in the controls, such that mutating parameters is automatically reflected in evaluate. The parameters will be available as an attribute of the ode_propagator.\nalg: The algorithm to use for the ODE Solver, see the list of solvers in the DifferentialEquations manual. The default Tsit5() method is the recommended choice for non-stiff problems.\nsolver_options: All other keyword arguments are passed to the ODE solver, see the list of Solve Keyword Arguments in the DifferentialEquations manual. Note that the options for \"Default Algorithm Hinting\" do not apply, since alg must be specified manually. Also, the \"Output Control\" is managed by the ode_propagator, so these options should not be used.\n\n\n\n\n\n","category":"function"},{"location":"api/quantumpropagators/#QuantumPropagators.prop_step!","page":"API","title":"QuantumPropagators.prop_step!","text":"Advance the propagator by a single time step.\n\nstate = prop_step!(propagator)\n\nreturns the state obtained from propagating to the next point on the time grid from propagator.t, respectively the previous point if propagator.backward is true.\n\nWhen the propagation would lead out of the time grid, prop_step! leaves propagator unchanged and returns nothing. Thus, a return value of nothing may be used to signal that a propagation has completed.\n\n\n\n\n\n","category":"function"},{"location":"api/quantumpropagators/#QuantumPropagators.propagate","page":"API","title":"QuantumPropagators.propagate","text":"Propagate a state over an entire time grid.\n\nstate = propagate(\n    state,\n    generator,\n    tlist;\n    method,  # mandatory keyword argument\n    check=true,\n    backward=false,\n    inplace=QuantumPropagators.Interfaces.supports_inplace(state),\n    verbose=false,\n    piecewise=nothing,\n    pwc=nothing,\n    storage=nothing,\n    observables=<store state>,\n    callback=nothing,\n    show_progress=false,\n    init_prop_kwargs...)\n\npropagates state of the entire time grid and returns the propagated states, or a storage array of data collected during the propagation. This high-level routine performs the following three steps:\n\nIf check=true (default), check that state, generator, and tlist are  consistent with the required interface.\nInitialize a propagator via init_prop:\ninit_prop(state, generator, tlist; method, inplace, init_prop_kwargs...)\nCall and return the result of\npropagate(propagator; storage, observables, show_progress, callback)\n\nArguments\n\nstate: The \"initial\" state for the propagation. For backward=false, this state is taken to be at initial time (tlist[begin]); and for backward=true, at the final time (tlist[end])\ngenerator: The time-dependent generator of the dynamics\ntlist: The time grid over which which the propagation is defined. This may or may not be equidistant.\n\nMandatory keyword arguments\n\nmethod: The propagation method to use. May be given as a name (Symbol), but the recommended usage is to pass a module implementing the propagation method, cf. init_prop.\n\nOptional keyword arguments\n\ncheck: if true, check that state, generator, and tlist pass check_state, check_generator and check_tlist, respectively.\nbackward: If true, propagate backward in time\ninplace: If true, propagate using in-place operations. If false, avoid in-place operations. Not all propagation methods support both in-place and not-in-place propagation. Note that inplace=true requires that QuantumPropagators.Interfaces.supports_inplace for state is true.\npiecewise: If given as a boolean, ensure that the internal propagator is an instance of PiecewisePropagator, cf. init_prop.\npwc: If given a a boolean, do a piecewise constant propagation where the generator in each interval is constant (the internal propagator is a PWCPropagator, cf. init_prop)\nstorage: Flag whether to store and return the propagated states / observables, or pre-allocated storage array. See Notes below.\nobservables: Converters for data to be stored in storage. See Notes below.\ncallback: Function to call after each propagation step. See Notes below.\nshow_progress: Whether to show a progress bar. See Notes below.\n\nAll remaining keyword arguments are passed to init_prop to initialize the Propagator that is used internally to drive the optimization. Unknown keyword arguments will be ignored.\n\nNotes\n\nIn general, there is no requirement that tlist has a constant time step, although some propagation methods (most notably Cheby) only support a uniform time grid.\n\nIf storage is given as a container pre-allocated via init_storage, it will be filled with data determined by the observables. Specifically, after each propagation step,\n\ndata = map_observables(observables, tlist, i, state)\nwrite_to_storage!(storage, i, data)\n\nis executed, where state is defined at time tlist[i]. See map_observables and write_to_storage! for details. The default values for observables results simply in the propagated states at every point in time being stored.\n\nThe storage parameter may also be given as true, and a new storage array will be created internally with init_storage and returned instead of the propagated state:\n\ndata = propagate(\n    state, generator, tlist; method,\n    backward=false; storage=true, observables=observables,\n    callback=nothing, show_progress=false, init_prop_kwargs...)\n\nIf backward is true, the input state is assumed to be at time tlist[end], and the propagation progresses backward in time (with a negative time step dt). If storage is given, it will be filled back-to-front during the backward propagation.\n\nIf callback is given as a callable, it will be called after each propagation step, as callback(propagator, observables) where propagator is Propagator object driving the propagation. The callback is called before calculating any observables. Example usage includes writing data to file, or modifying state via set_state!, e.g., removing amplitude from the lowest and highest level to mitigate \"truncation error\".\n\nIf show_progress is given as true, a progress bar will be shown for long-running propagation. In order to customize the progress bar, show_progress may also be a function that receives length(tlist) and returns a ProgressMeter.Progress instance.\n\nIf in_place=false is given, the propagation avoids in-place operations. This is slower than inplace=true, but is often required in the context of automatic differentiation (AD), e.g., with Zygote. That is, use in_place=false if propagate is called inside a function to be passed to Zygote.gradient, Zygote.pullback, or a similar function. In an AD context, storage and show_progress should not be used.\n\nThe propagate routine returns the propagated state at tlist[end], respectively tlist[1] if backward=true, or a storage array with the stored states / observable data if storage=true.\n\n\n\n\n\nstate = propagate(\n    state,\n    propagator;\n    storage=nothing,\n    observables=<store state>,\n    show_progress=false,\n    callback=nothing,\n    reinit_prop_kwargs...\n)\n\nre-initializes the given propagator with state (see reinit_prop!) and then calls the lower-level propagate(propagator; ...).\n\n\n\n\n\nstate = propagate(\n    propagator;\n    storage=nothing,\n    observables=<store state>,\n    show_progress=false,\n    callback=nothing,\n)\n\npropagates a freshly initialized propagator (immediately after init_prop). Used in the higher-level propagate(state, generator, tlist; kwargs...).\n\n\n\n\n\n","category":"function"},{"location":"api/quantumpropagators/#QuantumPropagators.propagate_sequence","page":"API","title":"QuantumPropagators.propagate_sequence","text":"Propagate a state through a sequence of generators.\n\nstates = propagate_sequence(\n    state,\n    propagations;\n    storage=nothing,\n    pre_propagation=nothing,\n    post_propagation=nothing,\n    kwargs...\n)\n\ntakes an initial state and performs a sequence of propagate calls using the parameters in propagations. The initial state for each step in the sequence is the state resulting from the previous step. Optionally, before and after each step, a pre_propagation and post_propagation function may modify the state instantaneously, e.g., to perform a frame transformation. Return the vector of states at the end of each step (after any post_propagation, before any next pre_propagation of the next step).\n\nArguments\n\nstate: The initial state\npropagations: A vector of Propagation instances, one per step in the sequence, each containing the arguments for the call to propagate for that step. The Propagation contains the generator and time grid for each step as positional parameters, or alternatively a pre-initialized Propagator, and any keyword arguments for propagate that are specific to that step. Note that propagate keyword arguments that are common to all steps can be given directly to propagate_sequence.\nstorage: If storage=true, return a vector of storage objects as returned by propagate(…, storage=true) for each propagation step, instead of the state after each step. To use a pre-initialized storage, each Propagation in propagations should have a storage keyword argument instead.\npre_propagation: If not nothing, must be a function that receives the same arguments as propagate and returns a state. Called immediately before the propagate of each step, and the state returned by pre_propagation will become the initial state for the subsequent call to propagate. Generally, pre_propagation would be different in each step of the sequence, and should be given as a keyword argument in a particular Propagation.\npost_propagation: If not nothing, a function that receives the same arguments as propagate and returns a state, see pre_propagation. The returned state becomes the initial state for the next step in the sequence (and may be further processed by the following pre_propagation). Like pre_propagation, this will generally be set as a keyword argument for a particular Propagation, not as a global keyword argument to propagate_sequence.\n\nAll other keyword arguments are forwarded to propagate. Thus, keyword arguments that are common to all steps in the sequence should be given as keyword arguments to propagate_sequence directly.\n\n\n\n\n\n","category":"function"},{"location":"api/quantumpropagators/#QuantumPropagators.reinit_prop!","page":"API","title":"QuantumPropagators.reinit_prop!","text":"Re-initialize a propagator.\n\nreinit_prop!(propagator, state; kwargs...)\n\nresets the propagator to state at the beginning of the time grid, respectively the end of the time grid if propagator.backward is true.\n\nAt a minimum, this is equivalent to a call to set_state! follow by a call to set_t!, but some propagators may have additional requirements on re-initialization, such as refreshing expansion coefficients for ChebyPropagator. In this case, the kwargs may be additional keyword arguments specific to the concrete type of propagator.\n\n\n\n\n\nreinit_prop!(\n    propagator::ChebyPropagator,\n    state;\n    transform_control_ranges=((c, ϵ_min, ϵ_max, check) => (ϵ_min, ϵ_max)),\n    kwargs...\n)\n\nre-initializes an existing ChebyPropagator. This may or may not involve recalculating the Chebychev coefficients based on the current control amplitudes in propagator.parameters.\n\nMethod-specific keyword arguments\n\ntransform_control_ranges: a function (c, ϵ_min, ϵ_max, check) => (ϵ_min′, ϵ_max′). For each control c, the function is called with check=true and ϵ_min (ϵ_max) the current minimum (maximum) values for the control from propagator.parameters). The Chebychev coefficients will be recalculated if the existing coefficients were obtained assuming a range for c outside the returned ϵ_min′, ϵ_max′.\nIf the coefficients do need to be recalculated, transform_control_ranges is called a second time with check=false, and the returned (ϵ_min′, ϵ_max′) are used for estimating the new spectral range.\nFor example,\nfunction transform_control_ranges(c, ϵ_min, ϵ_max, check)\n    if check\n        return (min(ϵ_min, 2 * ϵ_min), max(ϵ_max, 2 * ϵ_max))\n    else\n        return (min(ϵ_min, 5 * ϵ_min), max(ϵ_max, 5 * ϵ_max))\n    end\nend\nwill re-calculate the Chebychev coefficients only if the current amplitudes differ by more than a factor of two from the ranges that were used when initializing the propagator (control_ranges parameter in init_prop, which would have had to overestimate the actual amplitudes by at least a factor of two).  When re-calculating, the control_ranges will overestimate the amplitudes by a factor of five. With this transform_control_ranges, the propagation will be stable as long as the amplitudes do not change dynamically by more than a factor of 2.5 from their original range, while also not re-calculating coefficients unnecessarily in each pass because of modest changes in the amplitudes.\nThe transform_control_ranges argument is only relevant in the context of optimal control, where the same propagator will be used for many iterations with changing control field amplitudes.\n\nAll other keyword arguments are ignored.\n\n\n\n\n\n","category":"function"},{"location":"api/quantumpropagators/#Private-members","page":"API","title":"Private members","text":"","category":"section"},{"location":"api/quantumpropagators/","page":"API","title":"API","text":"QuantumPropagators.PWCPropagator\nQuantumPropagators.NewtonPropagator\nQuantumPropagators.enable_timings\nQuantumPropagators.timings_enabled\nQuantumPropagators.disable_timings\nQuantumPropagators.ChebyPropagator\nQuantumPropagators.ExpPropagator\nQuantumPropagators.cheby_get_spectral_envelope\nQuantumPropagators.PiecewisePropagator\nQuantumPropagators.set_state!\nQuantumPropagators.ode_function\nQuantumPropagators.set_t!\nQuantumPropagators.AbstractPropagator","category":"page"},{"location":"api/quantumpropagators/#QuantumPropagators.PWCPropagator","page":"API","title":"QuantumPropagators.PWCPropagator","text":"PiecewisePropagator sub-type for piecewise-constant propagators.\n\nLike the more general PiecewisePropagator, this is characterized by propagator.parameters mapping the controls in the generator to a vector of amplitude value on the midpoints of the time grid intervals.\n\nThe propagation will use these values as constant within each interval.\n\n\n\n\n\n","category":"type"},{"location":"api/quantumpropagators/#QuantumPropagators.NewtonPropagator","page":"API","title":"QuantumPropagators.NewtonPropagator","text":"Propagator for Newton propagation (method=QuantumPropagators.Newton).\n\nThis is a PWCPropagator.\n\n\n\n\n\n","category":"type"},{"location":"api/quantumpropagators/#QuantumPropagators.enable_timings","page":"API","title":"QuantumPropagators.enable_timings","text":"Enable the collection of TimerOutputs data.\n\nQuantumPropagators.enable_timings()\n\nenables certain portions of the package to collect TimerOutputs internally. This aids in profiling and benchmarking propagation methods.\n\nSpecifically, after enable_timings(), for any ChebyPropagator or NewtonPropagator, timing data will become available in propagator.wrk.timing_data (as a TimerOutput instance). This data is reset when the propagator is re-instantiated with init_prop or re-initialized with reinit_prop!. This makes the data local to any call of propagate.\n\nNote that enable_timings() triggers recompilation, so propagate should be called at least twice to avoid compilation overhead in the timing data. There is still a small overhead for collecting the timing data.\n\nThe collection of timing data can be disabled again with disable_timings.\n\nReturns QuantumPropagators.timings_enabled(), i.e., true if successful.\n\n\n\n\n\n","category":"function"},{"location":"api/quantumpropagators/#QuantumPropagators.timings_enabled","page":"API","title":"QuantumPropagators.timings_enabled","text":"Check whether the collection of TimerOutputs data is active.\n\nQuantumPropagators.timings_enabled()\n\nreturns true if QuantumPropagators.enable_timings() was called, and false otherwise or after QuantumPropagators.disable_timings().\n\n\n\n\n\n","category":"function"},{"location":"api/quantumpropagators/#QuantumPropagators.disable_timings","page":"API","title":"QuantumPropagators.disable_timings","text":"Disable the collection of TimerOutputs data.\n\nQuantumPropagators.disable_timings()\n\ndisables the collection of timing data previously enabled with enable_timings. This triggers recompilation to completely remove profiling from the code. That is, there is zero cost when the collection of timing data is disabled.\n\nReturns QuantumPropagators.timings_enabled(), i.e., false if successful.\n\n\n\n\n\n","category":"function"},{"location":"api/quantumpropagators/#QuantumPropagators.ChebyPropagator","page":"API","title":"QuantumPropagators.ChebyPropagator","text":"Propagator for Chebychev propagation (method=QuantumPropagators.Cheby).\n\nThis is a PWCPropagator.\n\n\n\n\n\n","category":"type"},{"location":"api/quantumpropagators/#QuantumPropagators.ExpPropagator","page":"API","title":"QuantumPropagators.ExpPropagator","text":"Propagator for propagation via direct exponentiation (method=QuantumPropagators.ExpProp)\n\nThis is a PWCPropagator.\n\n\n\n\n\n","category":"type"},{"location":"api/quantumpropagators/#QuantumPropagators.cheby_get_spectral_envelope","page":"API","title":"QuantumPropagators.cheby_get_spectral_envelope","text":"Determine the spectral envelope of a generator.\n\nE_min, E_max = cheby_get_spectral_envelope(\n    generator, tlist, control_ranges, method; kwargs...\n)\n\nestimates a lower bound E_min the lowest eigenvalue of the generator for any values of the controls specified by control_ranges, and an upper bound E_max for the highest eigenvalue.\n\nThis is done by constructing operators from the extremal values for the controls as specified in control_ranges and taking the smallest/largest return values from specrange for those operators.\n\nArguments\n\ngenerator: dynamical generator, e.g. a time-dependent\ntlist: The time grid for the propagation\ncontrol_ranges: a dict that maps controls that occur in generator (cf. get_controls to a tuple of minimum and maximum amplitude for that control\nmethod: method name to pass to  specrange\nkwargs: Any remaining keyword arguments are passed to specrange\n\n\n\n\n\n","category":"function"},{"location":"api/quantumpropagators/#QuantumPropagators.PiecewisePropagator","page":"API","title":"QuantumPropagators.PiecewisePropagator","text":"AbstractPropagator sub-type for piecewise propagators.\n\nA piecewise propagator is determined by a single parameter per control and time grid interval. Consequently, the propagator.parameters are a dictionary mapping the controls found in the generator via get_controls to a vector of values defined on the intervals of the time grid, see discretize_on_midpoints. This does not necessarily imply that these values are the piecewise-constant amplitudes for the intervals. A general piecewise propagator might use interpolation to obtain actual amplitudes within any given time interval.\n\nWhen the amplitudes are piecewise-constant, the propagator should be a concrete instantiation of a PWCPropagator.\n\n\n\n\n\n","category":"type"},{"location":"api/quantumpropagators/#QuantumPropagators.set_state!","page":"API","title":"QuantumPropagators.set_state!","text":"Set the current state of the propagator.\n\nset_state!(propagator, state)\n\nsets the propagator.state property and returns propagator.state. In order to mutate the current state after a call to prop_step!, the following pattern is recommended:\n\nΨ = propagator.state\nfoo_mutate!(Ψ)\nset_state!(propagator, Ψ)\n\nwhere foo_mutate! is some function that mutates Ψ.  This is guaranteed to work efficiently both for in-place and not-in-place propagators, without incurring unnecessary copies.\n\nwarning: Warning\nfoo_mutate!(propagator.state)by itself is not a safe operation. Always follow it byset_state!(propagator, propagator.state)\n\nSee also\n\nset_t! — set propagator.t.\n\n\n\n\n\n","category":"function"},{"location":"api/quantumpropagators/#QuantumPropagators.ode_function","page":"API","title":"QuantumPropagators.ode_function","text":"Wrap around a Generator, for use as an ODE function.\n\nf = ode_function(generator, tlist; c=-1im)\n\ncreates a function suitable to be passed to ODEProblem.\n\ngdefop1hat1\ngdefket1vert1rangle\n\nWith generator corresponding to opH(t), this implicitly encodes the ODE\n\nfracpartialpartial t ketPsi(t) = c opH(t) ketPsi(t)\n\nfor the state ketPsi(t). With the default c = -i, this corresponds to the Schrödinger equation, or the Liouville equation with convention=:LvN.\n\nThe resulting f works both in-place and not-in-place, as\n\nf(ϕ, Ψ, vals_dict, t)   # in-place `f(du, u, p, t)`\nϕ = f(Ψ, vals_dict, t)  # not-in-place `f(u, p, t)`\n\nCalling f as above is functionally equivalent to calling evaluate to obtain an operator H from the original time-dependent generator, and then applying H to the current quantum state Ψ:\n\nH = evaluate(f.generator, t; vals_dict=vals_dict)\nϕ = c * H * Ψ\n\nwhere vals_dict may be a dictionary mapping controls to values (set as the parameters p of the underlying ODE solver).\n\nIf QuantumPropagators.enable_timings() has been called, profiling data is collected in f.timing_data.\n\n\n\n\n\n","category":"function"},{"location":"api/quantumpropagators/#QuantumPropagators.set_t!","page":"API","title":"QuantumPropagators.set_t!","text":"Set the current time for the propagation.\n\nset_t!(propagator, t)\n\nSets propagator.t to the given value of t, where t must be an element of propagator.tlist.\n\nSee also\n\nset_state! — set propagator.state\n\n\n\n\n\n","category":"function"},{"location":"api/quantumpropagators/#QuantumPropagators.AbstractPropagator","page":"API","title":"QuantumPropagators.AbstractPropagator","text":"Abstract base type for all Propagator objects.\n\nAll Propagator objects must be instantiated via init_prop and implement the following interface.\n\nProperties\n\nstate (read-only): The current quantum state in the propagation\ntlist (read-only): The time grid for the propagation\nt (read-only): The time at which state is defined. An element of tlist.\nparameters: parameters that determine the dynamics. The structure of the parameters depends on the concrete Propagator type (i.e., the propagation method). Mutating the parameters affects subsequent propagation steps.\nbackward: Boolean flag to indicate whether the propagation moves forward or backward in time\ninplace: Boolean flag to indicate whether propagator.state is modified in-place or is recreated by every call of prop_step! or set_state!. With inplace=false, the propagator should generally avoid in-place operations, such as calls to QuantumPropagators.Controls.evaluate!.\n\nConcrete Propagator types may have additional properties or fields, but these should be considered private.\n\nMethods\n\nreinit_prop! — reset the propagator to a new initial state at the beginning of the time grid (or the end, for backward propagation)\nprop_step! – advance the propagator by one step forward (or backward) on the time grid.\nset_state! — safely mutate the current quantum state of the propagation. Note that directly mutating the state property is not safe. However, Ψ = propagator.state; foo_mutate!(Ψ), set_state!(propagator, Ψ) for some mutating function foo_mutate! is guaranteed to be safe and efficient for both in-place and not-in-place propagators.\nset_t! — safely mutate the current time (propagator.t), snapping to the values of tlist.\n\nSee also\n\nPiecewisePropagator — specialization of AbstractPropagator for piecewise propagation methods.\nPWCPropagator — specialization of PiecewisePropagator for piecewise-constant propagation methods.\n\n\n\n\n\n","category":"type"},{"location":"api/quantumpropagators/#QuantumPropagatorsGeneratorsAPI","page":"API","title":"QuantumPropagators.Generators","text":"","category":"section"},{"location":"api/quantumpropagators/","page":"API","title":"API","text":"The following routines define dynamical generators (Hamiltonians, Liouvillians). This includes the initialization of generators and the methods that define how these generators contain controls and control amplitudes. These methods must be defined for any custom generator or control amplitude.","category":"page"},{"location":"api/quantumpropagators/#Reference","page":"API","title":"Reference","text":"","category":"section"},{"location":"api/quantumpropagators/","page":"API","title":"API","text":"Public Members:","category":"page"},{"location":"api/quantumpropagators/","page":"API","title":"API","text":"Generator\nOperator\nScaledOperator\nhamiltonian\nliouvillian","category":"page"},{"location":"api/quantumpropagators/#Public-members-2","page":"API","title":"Public members","text":"","category":"section"},{"location":"api/quantumpropagators/","page":"API","title":"API","text":"QuantumPropagators.Generators.Generator\nQuantumPropagators.Generators.Operator\nQuantumPropagators.Generators.ScaledOperator\nQuantumPropagators.Generators.hamiltonian\nQuantumPropagators.Generators.liouvillian","category":"page"},{"location":"api/quantumpropagators/#QuantumPropagators.Generators.Generator","page":"API","title":"QuantumPropagators.Generators.Generator","text":"A time-dependent generator.\n\nGenerator(ops::Vector{OT}, amplitudes::Vector{AT})\n\nproduces an object of type Generator{OT,AT} that represents\n\nH(t)= H_0 + sum_l a_l(ϵ_l(t) t)  H_l\n\nwhere H_l are the ops and a_l(t) are the amplitudes. H(t) and H_l may represent operators in Hilbert space or super-operators in Liouville space. If the number of amplitudes is less than the number of ops, the first ops are considered as drift terms (H_0, respectively subsequent terms with a_l  1). At least one time-dependent amplitude is required. Each amplitude may depend on one or more control functions ϵ_l(t), although most typically a_l(t)  ϵ_l(t), that is, the amplitudes are simply a vector of the controls. See hamiltonian for details.\n\nA Generator object should generally not be instantiated directly, but via hamiltonian or liouvillian.\n\nThe list of ops and amplitudes are properties of the Generator. They should not be mutated.\n\nSee also\n\nOperator for static generators, which may be obtained from a Generator via evaluate.\n\n\n\n\n\n","category":"type"},{"location":"api/quantumpropagators/#QuantumPropagators.Generators.Operator","page":"API","title":"QuantumPropagators.Generators.Operator","text":"A static operator in Hilbert or Liouville space.\n\nOperator(ops::Vector{OT}, coeffs::Vector{CT})\n\nproduces an object of type Operator{OT,CT} that encapsulates the \"lazy\" sum\n\nH = sum_l c_l H_l\n\nwhere H_l are the ops and c_l are the coeffs, which each must be a constant Number. If the number of coefficients is less than the number of operators, the first ops are considered to have c_l = 1.\n\nAn Operator object would generally not be instantiated directly, but be obtained from a Generator via evaluate.\n\nThe H_l in the sum are considered immutable. This implies that an Operator can be updated in-place with evaluate! by only changing the coeffs.\n\n\n\n\n\n","category":"type"},{"location":"api/quantumpropagators/#QuantumPropagators.Generators.ScaledOperator","page":"API","title":"QuantumPropagators.Generators.ScaledOperator","text":"A static operator with a scalar pre-factor.\n\nop = ScaledOperator(α, Ĥ)\n\nrepresents the \"lazy\" product α H where H is an operator (typically an Operator instance) and α is a scalar.\n\n\n\n\n\n","category":"type"},{"location":"api/quantumpropagators/#QuantumPropagators.Generators.hamiltonian","page":"API","title":"QuantumPropagators.Generators.hamiltonian","text":"Initialize a (usually time-dependent) Hamiltonian.\n\nThe most common usage is, e.g.,\n\nusing QuantumPropagators\n\nH₀ = ComplexF64[0 0; 0 1];\nH₁ = ComplexF64[0 1; 1 0];\nϵ₁(t) = 1.0;\n\nhamiltonian(H₀, (H₀, ϵ₁))\n\n# output\n\nGenerator with 2 ops and 1 amplitudes\n ops::Vector{Matrix{ComplexF64}}:\n  ComplexF64[0.0 + 0.0im 0.0 + 0.0im; 0.0 + 0.0im 1.0 + 0.0im]\n  ComplexF64[0.0 + 0.0im 0.0 + 0.0im; 0.0 + 0.0im 1.0 + 0.0im]\n amplitudes::Vector{typeof(ϵ₁)}:\n  ϵ₁\n\nIn general,\n\nH = hamiltonian(terms...; check=true)\n\nconstructs a Hamiltonian based on the given terms. Each term must be an operator or a tuple (op, ampl) of an operator and a control amplitude. Single operators are considered \"drift\" terms.\n\nIn most cases, each control amplitude will simply be a control function or vector of pulse values. In general, ampl can be an arbitrary object that depends on one or more controls, which must be obtainable via get_controls(ampl). See QuantumPropagators.Interfaces.check_amplitude for the required interface.\n\nThe hamiltonian function will generally return a Generator instance. However, if none of the given terms are time-dependent, it may return a static operator (e.g., an AbstractMatrix or Operator):\n\nhamiltonian(H₀)\n# output\n2×2 Matrix{ComplexF64}:\n 0.0+0.0im  0.0+0.0im\n 0.0+0.0im  1.0+0.0im\n\nhamiltonian(H₀, (H₁, 2.0))\n# output\nOperator with 2 ops and 1 coeffs\n ops::Vector{Matrix{ComplexF64}}:\n  ComplexF64[0.0 + 0.0im 0.0 + 0.0im; 0.0 + 0.0im 1.0 + 0.0im]\n  ComplexF64[0.0 + 0.0im 1.0 + 0.0im; 1.0 + 0.0im 0.0 + 0.0im]\n coeffs: [2.0]\n\nThe hamiltonian function may generate warnings if the terms are of an unexpected type or structure.  These can be suppressed with check=false.\n\n\n\n\n\n","category":"function"},{"location":"api/quantumpropagators/#QuantumPropagators.Generators.liouvillian","page":"API","title":"QuantumPropagators.Generators.liouvillian","text":"Construct a Liouvillian Generator.\n\nℒ = liouvillian(Ĥ, c_ops=(); convention=:LvN, check=true)\n\ncalculates the sparse Liouvillian super-operator ℒ from the Hamiltonian Ĥ and a list c_ops of Lindblad operators.\n\nWith convention=:LvN, applying the resulting ℒ to a vectorized density matrix ρ⃗ calculates fracddt vecrho(t) = ℒ vecrho(t) equivalent to the Liouville-von-Neumann equation for the density matrix ρ,\n\nfracddt ρ(t)\n= -i H ρ(t) + sum_kleft(\n    A_k ρ A_k^dagger\n    - frac12 A_k^dagger A_k ρ\n    - frac12 ρ A_k^dagger A_k\n  right)\n\nwhere the Lindblad operators A_k are the elements of c_ops.\n\nThe Hamiltonian H will generally be time-dependent. For example, it may be a Generator as returned by hamiltonian. For example, for a Hamiltonian with the terms (Ĥ₀, (Ĥ₁, ϵ₁), (Ĥ₂, ϵ₂)), where Ĥ₀, Ĥ₁, Ĥ₂ are matrices, and ϵ₁ and ϵ₂ are functions of time, the resulting ℒ will be a Generator corresponding to terms (ℒ₀, (ℒ₁, ϵ₁), (ℒ₂, ϵ₂)), where the initial terms is the superoperator ℒ₀ for the static component of the Liouvillian, i.e., the commutator with the drift Hamiltonian Ĥ₀, plus the dissipator (sum over k), as a sparse matrix. Time-dependent Lindblad operators are not currently supported. The remaining elements are tuples (ℒ₁, ϵ₁) and (ℒ₂, ϵ₂) corresponding to the commutators with the two control Hamiltonians, where ℒ₁ and ℒ₂ again are sparse matrices.\n\nIf H is not time-dependent, the resulting ℒ will likewise be a static operator. Passing H=nothing with non-empty c_ops initializes a pure dissipator.\n\nWith convention=:TDSE, the Liouvillian will be constructed for the equation of motion i hbar fracddt vecrho(t) = ℒ vecrho(t) to match exactly the form of the time-dependent Schrödinger equation. While this notation is not standard in the literature of open quantum systems, it has the benefit that the resulting ℒ can be used in a numerical propagator for a (non-Hermitian) Schrödinger equation without any change. Thus, for numerical applications, convention=:TDSE is generally preferred. The returned ℒ between the two conventions differs only by a factor of i, since we generally assume hbar=1.\n\nThe convention keyword argument is mandatory, to force a conscious choice.\n\nSee Goerz et. al. \"Optimal control theory for a unitary operation under dissipative evolution\", arXiv 1312.0111v2, Appendix B.2 for the explicit construction of the Liouvillian superoperator as a sparse matrix.\n\nPassing check=false, suppresses warnings and errors about unexpected types or the structure of the arguments, cf. hamiltonian.\n\n\n\n\n\n","category":"function"},{"location":"api/quantumpropagators/#QuantumPropagatorsShapesAPI","page":"API","title":"QuantumPropagators.Shapes","text":"","category":"section"},{"location":"api/quantumpropagators/","page":"API","title":"API","text":"The following routines define useful function S(t) that can be used for control functions or amplitudes.","category":"page"},{"location":"api/quantumpropagators/#Reference-2","page":"API","title":"Reference","text":"","category":"section"},{"location":"api/quantumpropagators/","page":"API","title":"API","text":"Public Members:","category":"page"},{"location":"api/quantumpropagators/","page":"API","title":"API","text":"blackman\nbox\nflattop","category":"page"},{"location":"api/quantumpropagators/#Public-members-3","page":"API","title":"Public members","text":"","category":"section"},{"location":"api/quantumpropagators/","page":"API","title":"API","text":"QuantumPropagators.Shapes.blackman\nQuantumPropagators.Shapes.box\nQuantumPropagators.Shapes.flattop","category":"page"},{"location":"api/quantumpropagators/#QuantumPropagators.Shapes.blackman","page":"API","title":"QuantumPropagators.Shapes.blackman","text":"Blackman window shape.\n\nblackman(t, t₀, T; a=0.16)\n\ncalculates\n\nB(t t_0 T) =\n    frac12left(\n        1 - a - cosleft(2π fract - t_0T - t_0right)\n        + a cosleft(4π fract - t_0T - t_0right)\n    right)\n\nfor a scalar t, with a = 0.16.\n\nSee https://en.wikipedia.org/wiki/Window_function#Blackman_windows\n\nA Blackman shape looks nearly identical to a Gaussian with a 6-sigma interval between t₀ and T.  Unlike the Gaussian, however, it will go exactly to zero at the edges. Thus, Blackman pulses are often preferable to Gaussians.\n\n\n\n\n\n","category":"function"},{"location":"api/quantumpropagators/#QuantumPropagators.Shapes.box","page":"API","title":"QuantumPropagators.Shapes.box","text":"Box shape (Theta-function).\n\nbox(t, t₀, T)\n\nevaluates the Heaviside (Theta-) function Theta(t) = 1 for t_0 le t le T; and Theta(t) = 0 otherwise.\n\n\n\n\n\n","category":"function"},{"location":"api/quantumpropagators/#QuantumPropagators.Shapes.flattop","page":"API","title":"QuantumPropagators.Shapes.flattop","text":"Flat shape (amplitude 1.0) with a switch-on/switch-off from zero.\n\nflattop(t; T, t_rise, t₀=0.0, t_fall=t_rise, func=:blackman)\n\nevaluates a shape function that starts at 0 at t=t₀, and ramps to to 1 during the t_rise interval. The function then remains at value 1, before ramping down to 0 again during the interval t_fall before T. For t  t₀ and t  T, the shape is zero.\n\nThe default switch-on/-off shape is half of a Blackman window (see blackman).\n\nFor func=:sinsq, the switch-on/-off shape is a sine-squared curve.\n\n\n\n\n\n","category":"function"},{"location":"api/quantumpropagators/#QuantumPropagatorsControlsAPI","page":"API","title":"QuantumPropagators.Controls","text":"","category":"section"},{"location":"api/quantumpropagators/","page":"API","title":"API","text":"The following routines define method that must be defined for any control function, or for generators with respect to control functions.","category":"page"},{"location":"api/quantumpropagators/#Reference-3","page":"API","title":"Reference","text":"","category":"section"},{"location":"api/quantumpropagators/","page":"API","title":"API","text":"Public Members:","category":"page"},{"location":"api/quantumpropagators/","page":"API","title":"API","text":"ParameterizedFunction\ndiscretize\ndiscretize_on_midpoints\nevaluate\nevaluate!\nget_controls\nget_parameters\nget_tlist_midpoints\nsubstitute\nt_mid","category":"page"},{"location":"api/quantumpropagators/#Public-members-4","page":"API","title":"Public members","text":"","category":"section"},{"location":"api/quantumpropagators/","page":"API","title":"API","text":"QuantumPropagators.Controls.ParameterizedFunction\nQuantumPropagators.Controls.discretize\nQuantumPropagators.Controls.discretize_on_midpoints\nQuantumPropagators.Controls.evaluate\nQuantumPropagators.Controls.evaluate!\nQuantumPropagators.Controls.get_controls\nQuantumPropagators.Controls.get_parameters\nQuantumPropagators.Controls.get_tlist_midpoints\nQuantumPropagators.Controls.substitute\nQuantumPropagators.Controls.t_mid","category":"page"},{"location":"api/quantumpropagators/#QuantumPropagators.Controls.ParameterizedFunction","page":"API","title":"QuantumPropagators.Controls.ParameterizedFunction","text":"Abstract type for function-like objects with parameters.\n\nA struct that is an implementation of a ParameterizedFunction:\n\nmust have a parameters field that is an AbstractVector of floats (e.g., a ComponentArrays.ComponentVector)\nmust be callable with a single float argument t,\nmay define getters and setters for referencing the values in parameters with convenient names.\n\nThe parameters field of any ParameterizedFunction can be accessed via get_parameters.\n\nSee How to define a parameterized control for an example. You may use the QuantumPropagators.Interfaces.check_parameterized_function to check the implementation of a ParameterizedFunction subtype.\n\n\n\n\n\n","category":"type"},{"location":"api/quantumpropagators/#QuantumPropagators.Controls.discretize","page":"API","title":"QuantumPropagators.Controls.discretize","text":"Evaluate control at every point of tlist.\n\nvalues = discretize(control, tlist; via_midpoints=true)\n\ndiscretizes the given control to a Vector of values defined on the points of tlist.\n\nIf control is a function, it is first evaluated at the midpoint of tlist, see discretize_on_midpoints, and then the values on the midpoints are converted to values on tlist. This discretization is more stable than directly evaluating the control function at the values of tlist, and ensures that repeated round-trips between discretize and discretize_on_midpoints can be done safely, see the note in the documentation of discretize_on_midpoints.\n\nThe latter can still be achieved by passing via_midpoints=false. While such a direct discretization is suitable e.g. for plotting, but it is unsuitable for round-trips between discretize and discretize_on_midpoints  (constant controls on tlist may result in a zig-zag on the intervals of tlist).\n\nIf control is a vector, a copy of control will be returned if it is of the same length as tlist. Otherwise, control must have one less value than tlist, and is assumed to be defined on the midpoints of tlist. In that case, discretize acts as the inverse of discretize_on_midpoints. See discretize_on_midpoints for how control values on tlist and control values on the intervals of tlist are related.\n\n\n\n\n\n","category":"function"},{"location":"api/quantumpropagators/#QuantumPropagators.Controls.discretize_on_midpoints","page":"API","title":"QuantumPropagators.Controls.discretize_on_midpoints","text":"Evaluate control at the midpoints of tlist.\n\nvalues = discretize_on_midpoints(control, tlist)\n\ndiscretizes the given control to a Vector of values on the midpoints of tlist. Hence, the resulting values will contain one less value than tlist.\n\nIf control is a vector of values defined on tlist (i.e., of the same length as tlist), it will be converted to a vector of values on the intervals of tlist. The value for the first and last \"midpoint\" will remain the original values at the beginning and end of tlist, in order to ensure exact boundary conditions. For all other midpoints, the value for that midpoint will be calculated by \"un-averaging\".\n\nFor example, for a control and tlist of length 5, consider the following diagram:\n\ntlist index:       1   2   3   4   5\ntlist:             ⋅   ⋅   ⋅   ⋅   ⋅   input values cᵢ (i ∈ 1..5)\n                   |̂/ ̄ ̄ ̂\\ / ̂\\ / ̂ ̄ ̄\\|̂\nmidpoints:         x     x   x     x   output values pᵢ (i ∈ 1..4)\nmidpoints index:   1     2   3     4\n\nWe will have p₁=c₁ for the first value, p₄=c₅ for the last value. For all other points, the control values cᵢ = fracp_i-1 + p_i2 are the average of the values on the midpoints. This implies the \"un-averaging\" for the midpoint values pᵢ = 2 c_i - p_i-1.\n\nnote: Note\nAn arbitrary input control array may not be compatible with the above averaging formula. In this case, the conversion will be \"lossy\" (discretize will not recover the original control array; the difference should be considered a \"discretization error\"). However, any further round-trip conversions between points and intervals are bijective and preserve the boundary conditions. In this case, the discretize_on_midpoints and discretize methods are each other's inverse. This also implies that for an optimal control procedure, it is safe to modify midpoint values. Modifying the the values on the time grid directly on the other hand may accumulate discretization errors.\n\nIf control is a vector of one less length than tlist, a copy of control will be returned, under the assumption that the input is already properly discretized.\n\nIf control is a function, the function will be directly evaluated at the midpoints marked as x in the above diagram..\n\nSee also\n\nget_tlist_midpoints – get all the midpoints on which the control will be discretized.\nt_mid – get a particular midpoint.\ndiscretize – discretize directly on tlist instead of on the midpoints\n\n\n\n\n\n","category":"function"},{"location":"api/quantumpropagators/#QuantumPropagators.Controls.evaluate","page":"API","title":"QuantumPropagators.Controls.evaluate","text":"Evaluate all controls.\n\nIn general, evaluate(object, args...; vals_dict=IdDict()) evaluates the object for a specific point in time indicated by the positional args. Any control in object is evaluated at the specified point in time. Alternatively, the vals_dict maps a controls to value (\"plug in this value for the given control\")\n\nFor example,\n\nop = evaluate(generator, t)\n\nevaluates generator at time t. This requires that any control in generator is a callable that takes t as a single argument.\n\nop = evaluate(generator, tlist, n)\n\nevaluates generator for the n'th interval of tlist. This uses the definitions for the midpoints in discretize_on_midpoints. The controls in generator may be vectors (see discretize, discretize_on_midpoints) or callables of t.\n\nop = evaluate(generator, t; vals_dict)\nop = evaluate(generator, tlist, n; vals_dict)\n\nresolves any explicit time dependencies in generator at the specified point in time, but uses the value in the given vals_dict for any control in vals_dict.\n\na = evaluate(ampl, tlist, n; vals_dict=IdDict())\na = evaluate(ampl, t; vals_dict=IdDict())\n\nevaluates a control amplitude to a scalar by evaluating any explicit time dependency, and by replacing each control with the corresponding value in vals_dict.\n\nCalling evaluate for an object with no implicit or explicit time dependence should return the object unchanged.\n\nFor generators without any explicit time dependence,\n\nop = evaluate(generator; vals_dict)\n\ncan be used. The vals_dict in this case must contain values for all controls in generator.\n\nSee also:\n\nevaluate! — update an existing operator with a re-evaluation of a\n\ngenerator at a different point in time.\n\n\n\n\n\n","category":"function"},{"location":"api/quantumpropagators/#QuantumPropagators.Controls.evaluate!","page":"API","title":"QuantumPropagators.Controls.evaluate!","text":"Update an existing evaluation of a generator.\n\nevaluate!(op, generator, args..; vals_dict=IdDict())\n\nperforms an in-place update on an op the was obtained from a previous call to evaluate with the same generator, but for a different point in time and/or different values in vals_dict.\n\n\n\n\n\n","category":"function"},{"location":"api/quantumpropagators/#QuantumPropagators.Controls.get_controls","page":"API","title":"QuantumPropagators.Controls.get_controls","text":"Extract a Tuple of controls.\n\ncontrols = get_controls(generator)\n\nextracts the controls from a single dynamical generator.\n\nFor example, if generator = hamiltonian(H0, (H1, ϵ1), (H2, ϵ2)), extracts (ϵ1, ϵ2).\n\n\n\n\n\nget_controls(operator)\n\nfor a static operator (matrix) returns an empty tuple.\n\n\n\n\n\n","category":"function"},{"location":"api/quantumpropagators/#QuantumPropagators.Controls.get_parameters","page":"API","title":"QuantumPropagators.Controls.get_parameters","text":"Obtain analytic parameters of the given control.\n\nparameters = get_parameters(control)\n\nobtains parameters as an AbstractVector{Float64} containing any tunable analytic parameters associated with the control. The specific type of parameters depends on how control is defined, but a ComponentArrays.ComponentVector should be a common array type.\n\nMutating the resulting vector must directly affect the control in any subsequent call to evaluate. That is, the values in parameters must alias values inside the control.\n\nNote that the control must be an object specifically designed to have analytic parameters. Typically, it should be implemented as a subtype of ParameterizedFunction. For a simple function ϵ(t) or a vector of pulse values, which are the default types of controls discussed in the documentation of hamiltonian, the get_parameters function will return an empty vector.\n\nMore generally,\n\nparameters = get_parameters(object)\n\ncollects and combines all unique parameter arrays from the controls inside the object. The object may be a Generator, Trajectory, ControlProblem, or any other object for which get_controls(object) is defined. If there are multiple controls with different parameter arrays, these are combined in a RecursiveArrayTools.ArrayPartition. This requires the RecursiveArrayTools package to be loaded. Again, mutating parameters directly affects the underlying controls.\n\nThe parameters may be used as part of the parameters attribute of a propagator for time-continuous dynamics, like a general ODE solver, or in an optimization that tunes analytic control parameters, e.g., with a Nelder-Mead method. Examples might include the widths, peak amplitudes, and times of a superposition of Gaussians [7], cf. the example of a ParameterizedFunction, or the amplitudes associated with spectral components in a random truncated basis [11].\n\nThe parameters are not intended for optimization methods such as GRAPE or Krotov that fundamentally use a piecewise-constant control ansatz. In the context of such methods, the \"control parameters\" are always the amplitudes of the control at the mid-points of the time grid, as obtained by discretize_on_midpoints, and get_parameters is ignored.\n\n\n\n\n\n","category":"function"},{"location":"api/quantumpropagators/#QuantumPropagators.Controls.get_tlist_midpoints","page":"API","title":"QuantumPropagators.Controls.get_tlist_midpoints","text":"Shift time grid values to the interval midpoints\n\ntlist_midpoints = get_tlist_midpoints(\n    tlist; preserve_start=true, preserve_end=true\n)\n\ntakes a vector tlist of length n and returns a Vector{Float64} of length n-1 containing the midpoint values of each interval. The intervals in tlist are not required to be uniform.\n\nBy default, the first and last point of tlist is preserved, see discretize_on_midpoints. This behavior can be disabled by passing preserve_start and preserve_end as false in order to use the midpoints of the first and last interval, respectively.\n\nSee also\n\nt_mid – get a particular midpoint.\n\n\n\n\n\n","category":"function"},{"location":"api/quantumpropagators/#QuantumPropagators.Controls.substitute","page":"API","title":"QuantumPropagators.Controls.substitute","text":"Substitute inside the given object.\n\nobject = substitute(object, replacements)\n\nreturns a modified object with the replacements defined in the given replacements dictionary. Things that can be replaced include operators, controls, and amplitudes. For example,\n\ngenerator = substitute(generator::Generator, replacements)\noperator = substitute(operator::Operator, replacements)\namplitude = substitute(amplitude, controls_replacements)\n\nNote that substitute cannot be used to replace dynamic quantities, e.g. controls, with static value. Use evaluate instead for that purpose.\n\n\n\n\n\n","category":"function"},{"location":"api/quantumpropagators/#QuantumPropagators.Controls.t_mid","page":"API","title":"QuantumPropagators.Controls.t_mid","text":"Midpoint of n'th interval of tlist.\n\nt = t_mid(tlist, n)\n\nreturns the t that is the midpoint between points tlist[n+1] and tlist[n], but snapping to the beginning/end to follow the convention explained in discretize_on_midpoints (to preserve exact boundary conditions at the edges of the time grid.)\n\nSee also\n\nget_tlist_midpoints – get all the midpoints in one go.\n\n\n\n\n\n","category":"function"},{"location":"api/quantumpropagators/#QuantumPropagatorsAmplitudesAPI","page":"API","title":"QuantumPropagators.Amplitudes","text":"","category":"section"},{"location":"api/quantumpropagators/","page":"API","title":"API","text":"The following types define control amplitudes a(ϵ_l(t) t) that depend on one or more control functions ϵ_l(t).","category":"page"},{"location":"api/quantumpropagators/#Reference-4","page":"API","title":"Reference","text":"","category":"section"},{"location":"api/quantumpropagators/","page":"API","title":"API","text":"Public Members:","category":"page"},{"location":"api/quantumpropagators/","page":"API","title":"API","text":"LockedAmplitude\nShapedAmplitude","category":"page"},{"location":"api/quantumpropagators/#Public-members-5","page":"API","title":"Public members","text":"","category":"section"},{"location":"api/quantumpropagators/","page":"API","title":"API","text":"QuantumPropagators.Amplitudes.LockedAmplitude\nQuantumPropagators.Amplitudes.ShapedAmplitude","category":"page"},{"location":"api/quantumpropagators/#QuantumPropagators.Amplitudes.LockedAmplitude","page":"API","title":"QuantumPropagators.Amplitudes.LockedAmplitude","text":"A time-dependent amplitude that is not a control.\n\nampl = LockedAmplitude(shape)\n\nwraps around shape, which must be either a vector of values defined on the midpoints of a time grid or a callable shape(t).\n\nampl = LockedAmplitude(shape, tlist)\n\ndiscretizes shape to the midpoints of tlist.\n\n\n\n\n\n","category":"type"},{"location":"api/quantumpropagators/#QuantumPropagators.Amplitudes.ShapedAmplitude","page":"API","title":"QuantumPropagators.Amplitudes.ShapedAmplitude","text":"Product of a fixed shape and a control.\n\nampl = ShapedAmplitude(control; shape=shape)\n\nproduces an amplitude a(t) = S(t) ϵ(t), where S(t) corresponds to shape and ϵ(t) corresponds to control. Both control and shape should be either a vector of values defined on the midpoints of a time grid or a callable control(t), respectively shape(t). In the latter case, ampl will also be callable.\n\nampl = ShapedAmplitude(control, tlist; shape=shape)\n\ndiscretizes control and shape to the midpoints of tlist.\n\n\n\n\n\n","category":"type"},{"location":"api/quantumpropagators/#QuantumPropagatorsStorageAPI","page":"API","title":"QuantumPropagators.Storage","text":"","category":"section"},{"location":"api/quantumpropagators/","page":"API","title":"API","text":"The following routines allow to manage and extend storage arrays storage parameter in propagate. See the discussion of Expectation Values for more details.","category":"page"},{"location":"api/quantumpropagators/#Reference-5","page":"API","title":"Reference","text":"","category":"section"},{"location":"api/quantumpropagators/","page":"API","title":"API","text":"Public Members:","category":"page"},{"location":"api/quantumpropagators/","page":"API","title":"API","text":"get_from_storage\nget_from_storage!\ninit_storage\nmap_observable\nmap_observables\nwrite_to_storage!","category":"page"},{"location":"api/quantumpropagators/#Public-members-6","page":"API","title":"Public members","text":"","category":"section"},{"location":"api/quantumpropagators/","page":"API","title":"API","text":"QuantumPropagators.Storage.get_from_storage\nQuantumPropagators.Storage.get_from_storage!\nQuantumPropagators.Storage.init_storage\nQuantumPropagators.Storage.map_observable\nQuantumPropagators.Storage.map_observables\nQuantumPropagators.Storage.write_to_storage!","category":"page"},{"location":"api/quantumpropagators/#QuantumPropagators.Storage.get_from_storage","page":"API","title":"QuantumPropagators.Storage.get_from_storage","text":"Obtain immutable data from storage.\n\ndata = get_from_storage(storage, i)\n\nSee get_from_storage!.\n\n\n\n\n\n","category":"function"},{"location":"api/quantumpropagators/#QuantumPropagators.Storage.get_from_storage!","page":"API","title":"QuantumPropagators.Storage.get_from_storage!","text":"Obtain data from storage.\n\nget_from_storage!(data, storage, i)\n\nextracts data from the storage for the i'th time slot. Inverse of write_to_storage!. This modifies data in-place. If get_from_storage! is implemented for arbitrary observables, it is the developer's responsibility that init_storage,  write_to_storage!, and get_from_storage! are compatible.\n\nTo extract immutable data, the non-in-place version\n\ndata = get_from_storage(storage, i)\n\ncan be used.\n\n\n\n\n\n","category":"function"},{"location":"api/quantumpropagators/#QuantumPropagators.Storage.init_storage","page":"API","title":"QuantumPropagators.Storage.init_storage","text":"Create a storage array for propagation.\n\nstorage = init_storage(state, tlist)\n\ncreates a storage array suitable for storing a state for each point in tlist.\n\nstorage = init_storage(state, tlist, observables)\n\ncreates a storage array suitable for the data generated by the observables applied to state, see map_observables, for each point in tlist.\n\nstorage = init_storage(data, nt)\n\ncreates a storage arrays suitable for storing data nt times, where nt=length(tlist). By default, this will be a vector of typeof(data) and length nt, or a n × nt Matrix with the same eltype as data if data is a Vector of length n.\n\n\n\n\n\n","category":"function"},{"location":"api/quantumpropagators/#QuantumPropagators.Storage.map_observable","page":"API","title":"QuantumPropagators.Storage.map_observable","text":"Apply a single observable to state.\n\ndata = map_observable(observable, tlist, i, state)\n\nBy default, observable can be one of the following:\n\nA function taking the three arguments state, tlist, i, where state is defined at time tlist[i].\nA function taking a single argument state, under the assumption that the observable is time-independent\nA matrix for which to calculate the expectation value with respect to the vector state.\n\nThe default map_observables delegates to this function.\n\n\n\n\n\n","category":"function"},{"location":"api/quantumpropagators/#QuantumPropagators.Storage.map_observables","page":"API","title":"QuantumPropagators.Storage.map_observables","text":"Obtain \"observable\" data from state.\n\ndata = map_observables(observables, tlist, i, state)\n\ncalculates the data for a tuple of observables applied to state defined at time tlist[i]. For a single observable (tuple of length 1), simply return the result of map_observable.\n\nFor multiple observables, return the tuple resulting from applying map_observable for each observable. If the tuple is \"uniform\" (all elements are of the same type, e.g. if each observable calculates the expectation value of a Hermitian operator), it is converted to a Vector. This allows for compact storage in a storage array, see init_storage.\n\n\n\n\n\n","category":"function"},{"location":"api/quantumpropagators/#QuantumPropagators.Storage.write_to_storage!","page":"API","title":"QuantumPropagators.Storage.write_to_storage!","text":"Place data into storage for time slot i.\n\nwrite_to_storage!(storage, i, data)\n\nfor a storage array created by init_storage stores the data obtained from map_observables at time slot i.\n\nConceptually, this corresponds roughly to storage[i] = data, but storage may have its own idea on how to store data for a specific time slot. For example, with the default init_storage Vector data will be stored in a matrix, and write_to_storage! will in this case write data to the i'th column of the matrix.\n\nFor a given type of storage and data, it is the developer's responsibility that init_storage and write_to_storage! are compatible.\n\n\n\n\n\n","category":"function"},{"location":"api/quantumpropagators/#QuantumPropagatorsChebyAPI","page":"API","title":"QuantumPropagators.Cheby","text":"","category":"section"},{"location":"api/quantumpropagators/","page":"API","title":"API","text":"The following routines implement time propagation via expansion in Chebychev polynomials.","category":"page"},{"location":"api/quantumpropagators/#Reference-6","page":"API","title":"Reference","text":"","category":"section"},{"location":"api/quantumpropagators/","page":"API","title":"API","text":"Public Members:","category":"page"},{"location":"api/quantumpropagators/","page":"API","title":"API","text":"ChebyWrk\ncheby\ncheby!\ncheby_coeffs\ncheby_coeffs!","category":"page"},{"location":"api/quantumpropagators/#Public-members-7","page":"API","title":"Public members","text":"","category":"section"},{"location":"api/quantumpropagators/","page":"API","title":"API","text":"QuantumPropagators.Cheby.ChebyWrk\nQuantumPropagators.Cheby.cheby\nQuantumPropagators.Cheby.cheby!\nQuantumPropagators.Cheby.cheby_coeffs\nQuantumPropagators.Cheby.cheby_coeffs!","category":"page"},{"location":"api/quantumpropagators/#QuantumPropagators.Cheby.ChebyWrk","page":"API","title":"QuantumPropagators.Cheby.ChebyWrk","text":"Workspace for the Chebychev propagation routine.\n\nChebyWrk(Ψ, Δ, E_min, dt; limit=1e-12)\n\ninitializes the workspace for the propagation of a state similar to Ψ under a Hamiltonian with eigenvalues between E_min and E_min + Δ, and a time step dt. Chebychev coefficients smaller than the given limit are discarded.\n\n\n\n\n\n","category":"type"},{"location":"api/quantumpropagators/#QuantumPropagators.Cheby.cheby","page":"API","title":"QuantumPropagators.Cheby.cheby","text":"Evaluate Ψ = exp(-𝕚 * H * dt) Ψ.\n\nΨ_out = cheby(Ψ, H, dt, wrk; E_min=nothing, check_normalization=false)\n\nacts like cheby! but does not modify Ψ in-place.\n\n\n\n\n\n","category":"function"},{"location":"api/quantumpropagators/#QuantumPropagators.Cheby.cheby!","page":"API","title":"QuantumPropagators.Cheby.cheby!","text":"Evaluate Ψ = exp(-𝕚 * H * dt) Ψ in-place.\n\ncheby!(Ψ, H, dt, wrk; E_min=nothing, check_normalization=false)\n\nArguments\n\nΨ: on input, initial vector. Will be overwritten with result.\nH: Hermitian operator\ndt: time step\nwrk: internal workspace\nE_min: minimum eigenvalue of H, to be used instead of the E_min from the  initialization of wrk. The same wrk may be used for different values  E_min, as long as the spectra radius Δ and the time step dt are the  same as those used for the initialization of wrk.\ncheck_normalizataion: perform checks that the H does not exceed the spectral radius for which the workspace was initialized.\n\nThe routine will not allocate any internal storage. This implementation requires copyto! lmul!, and axpy! to be implemented for Ψ, and the three-argument mul! for Ψ and H.\n\n\n\n\n\n","category":"function"},{"location":"api/quantumpropagators/#QuantumPropagators.Cheby.cheby_coeffs","page":"API","title":"QuantumPropagators.Cheby.cheby_coeffs","text":"Calculate Chebychev coefficients.\n\na::Vector{Float64} = cheby_coeffs(Δ, dt; limit=1e-12)\n\nreturn an array of coefficients larger than limit.\n\nArguments\n\nΔ: the spectral radius of the underlying operator\ndt: the time step\n\nSee also cheby_coeffs! for an in-place version.\n\n\n\n\n\n","category":"function"},{"location":"api/quantumpropagators/#QuantumPropagators.Cheby.cheby_coeffs!","page":"API","title":"QuantumPropagators.Cheby.cheby_coeffs!","text":"Calculate Chebychev coefficients in-place.\n\nn::Int = cheby_coeffs!(coeffs, Δ, dt, limit=1e-12)\n\noverwrites the first n values in coeffs with new coefficients larger than limit for the given new spectral radius Δ and time step dt. The coeffs array will be resized if necessary, and may have a length > n on exit.\n\nSee also cheby_coeffs for an non-in-place version.\n\n\n\n\n\n","category":"function"},{"location":"api/quantumpropagators/#QuantumPropagatorsNewtonAPI","page":"API","title":"QuantumPropagators.Newton","text":"","category":"section"},{"location":"api/quantumpropagators/","page":"API","title":"API","text":"The following routines implement time propagation via expansion in Newton polynomials using a restarted Arnoldi scheme to determine evaluation points.","category":"page"},{"location":"api/quantumpropagators/#Reference-7","page":"API","title":"Reference","text":"","category":"section"},{"location":"api/quantumpropagators/","page":"API","title":"API","text":"Public Members:","category":"page"},{"location":"api/quantumpropagators/","page":"API","title":"API","text":"NewtonWrk\nnewton!","category":"page"},{"location":"api/quantumpropagators/","page":"API","title":"API","text":"Private Members:","category":"page"},{"location":"api/quantumpropagators/","page":"API","title":"API","text":"extend_newton_coeffs!\nextend_leja!","category":"page"},{"location":"api/quantumpropagators/#Public-members-8","page":"API","title":"Public members","text":"","category":"section"},{"location":"api/quantumpropagators/","page":"API","title":"API","text":"QuantumPropagators.Newton.NewtonWrk\nQuantumPropagators.Newton.newton!","category":"page"},{"location":"api/quantumpropagators/#QuantumPropagators.Newton.NewtonWrk","page":"API","title":"QuantumPropagators.Newton.NewtonWrk","text":"NewtonWrk(v0, m_max=10)\n\nWorkspace for the Newton-with-restarted-Arnoldi propagation routine.\n\nInitializes the workspace for the propagation of a vector v0, using a maximum Krylov dimension of m_max in each restart iteration. Note that m_max should be smaller than the length of v0.\n\n\n\n\n\n","category":"type"},{"location":"api/quantumpropagators/#QuantumPropagators.Newton.newton!","page":"API","title":"QuantumPropagators.Newton.newton!","text":"newton!(Ψ, H, dt, wrk; func=(z -> exp(-1im*z)), norm_min=1e-14, relerr=1e-12,\n        max_restarts=50, _...)\n\nEvaluate Ψ = func(H*dt) Ψ using a Newton-with-restarted-Arnoldi scheme.\n\nArguments\n\nΨ: The state to propagate, will be overwritten in-place with the propagated state\nH: Operator acting on Ψ. Together with dt, this is the argument to func\ndt: Implicit time step. Together with H, this is the argument to func\nwkr: Work array, initialized with NewtonWrk\nfunc: The function to apply to H dt, taking a single (scalar) complex-valued argument z in place of H dt. The default func is to evaluate the time evaluations operator for the Schrödinger equation\nnorm_min: the minimum norm at which to consider a state similar to Ψ as zero\nrelerr: The relative error defining the convergence condition for the restart iteration. Propagation stops when the norm of the accumulated Ψ is stable up to the given relative error\nmax_restarts: The maximum number of restart iterations. Exceeding max_restarts will throw an AssertionError.\n\nAll other keyword arguments are ignored.\n\n\n\n\n\n","category":"function"},{"location":"api/quantumpropagators/#Private-members-2","page":"API","title":"Private members","text":"","category":"section"},{"location":"api/quantumpropagators/","page":"API","title":"API","text":"QuantumPropagators.Newton.extend_newton_coeffs!\nQuantumPropagators.Newton.extend_leja!","category":"page"},{"location":"api/quantumpropagators/#QuantumPropagators.Newton.extend_newton_coeffs!","page":"API","title":"QuantumPropagators.Newton.extend_newton_coeffs!","text":"extend_newton_coeffs!(a, n_a, leja, func, n_leja, radius)\n\nExtend the array a of existing Newton coefficients for the expansion of the func from n_a coefficients to n_leja coefficients. Return a new value n_a=n_a+n_leja with the total number of Newton coefficients in the updated a.\n\nArguments\n\na: On input, a zero-based array of length n_a or greater, containing Newton coefficients. On output, array containing a total n_leja coefficients. The array a will be resized if necessary, and may have a length greater than n_leja on output\nn_a:  The number of Newton coefficients in a, on input. Elements of a  beyond the first n_a elements will be overwritten.\nleja: Array of normalized Leja points, containing at least n_leja elements.\nfunc: Function for which to calculate Newton coefficients\nn_leja: The number of elements in leja to use for calculating new coefficients, and the total number of Newton coefficients on output\nradius: Normalization radius for divided differences\n\n\n\n\n\n","category":"function"},{"location":"api/quantumpropagators/#QuantumPropagators.Newton.extend_leja!","page":"API","title":"QuantumPropagators.Newton.extend_leja!","text":"extend_leja!(leja, n, newpoints, n_use)\n\nGiven an array of n (ordered) Leja points, extract n_use points from newpoints, and append them to the existing Leja points. The array leja should be sufficiently large to hold the new Leja points, which are appended after index n_old. It will be re-allocated if necessary and may have a size of up to 2*(n+n_use).\n\nArguments\n\nleja: Array of leja values. Must contain the \"old\" leja values to be kept  in leja(0:n-1). On output, n_use new leja points will be in  leja(n+:n+n_use-1), for the original value of n.  The leja array must  use zero-based indexing.\nn: On input, number of \"old\" leja points in leja. On output, total number of leja points (i.e. n=n+n_use)\nnewpoints: On input, candidate points for new leja points.  The n_use best values will be chosen and added to leja. On output, the values of new_points are undefined.\nn_use: Number of points that should be added to leja\n\n\n\n\n\n","category":"function"},{"location":"api/quantumpropagators/#QuantumPropagatorsExpPropAPI","page":"API","title":"QuantumPropagators.ExpProp","text":"","category":"section"},{"location":"api/quantumpropagators/","page":"API","title":"API","text":"The following routines implement time propagation via explicit exponentiation of the dynamical generator.","category":"page"},{"location":"api/quantumpropagators/#Reference-8","page":"API","title":"Reference","text":"","category":"section"},{"location":"api/quantumpropagators/","page":"API","title":"API","text":"Public Members:","category":"page"},{"location":"api/quantumpropagators/","page":"API","title":"API","text":"ExpPropWrk\nexpprop!","category":"page"},{"location":"api/quantumpropagators/","page":"API","title":"API","text":"Private Members:","category":"page"},{"location":"api/quantumpropagators/","page":"API","title":"API","text":"expprop","category":"page"},{"location":"api/quantumpropagators/#Public-members-9","page":"API","title":"Public members","text":"","category":"section"},{"location":"api/quantumpropagators/","page":"API","title":"API","text":"QuantumPropagators.ExpProp.ExpPropWrk\nQuantumPropagators.ExpProp.expprop!","category":"page"},{"location":"api/quantumpropagators/#QuantumPropagators.ExpProp.ExpPropWrk","page":"API","title":"QuantumPropagators.ExpProp.ExpPropWrk","text":"ExpPropWrk(v0)\n\nWorkspace for propagation via direct matrix exponentiation.\n\nInitializes the workspace for the propagation of a vector v0\n\n\n\n\n\n","category":"type"},{"location":"api/quantumpropagators/#QuantumPropagators.ExpProp.expprop!","page":"API","title":"QuantumPropagators.ExpProp.expprop!","text":"expprop!(Ψ, H, dt, wrk; func=(H_dt -> exp(-1im * H_dt)), _...)\n\nEvaluate Ψ = func(H*dt) Ψ by directly evaluating U = func(H*dt), i.e. by matrix exponentiation for the default func, and then multiplying U and Ψ in-place with mul!.\n\nThe workspace wrk must be initialized with ExpPropWrk to provide storage for a temporary state.\n\nKeyword arguments besides func are ignored.\n\n\n\n\n\n","category":"function"},{"location":"api/quantumpropagators/#Private-members-3","page":"API","title":"Private members","text":"","category":"section"},{"location":"api/quantumpropagators/","page":"API","title":"API","text":"QuantumPropagators.ExpProp.expprop","category":"page"},{"location":"api/quantumpropagators/#QuantumPropagators.ExpProp.expprop","page":"API","title":"QuantumPropagators.ExpProp.expprop","text":"Ψ_out = expprop(Ψ, H, dt, wrk; func=(H_dt -> exp(-1im * H_dt)), _...)\n\nevaluates Ψ_out = func(H*dt) Ψ as in expprop!, but not acting in-place.\n\n\n\n\n\n","category":"function"},{"location":"api/quantumpropagators/#QuantumPropagatorsSpectralRangeAPI","page":"API","title":"QuantumPropagators.SpectralRange","text":"","category":"section"},{"location":"api/quantumpropagators/","page":"API","title":"API","text":"Chebychev propagation relies on estimating the spectral range of the Hamiltonian, which in turn may be done via Arnoldi iteration.","category":"page"},{"location":"api/quantumpropagators/#Reference-9","page":"API","title":"Reference","text":"","category":"section"},{"location":"api/quantumpropagators/","page":"API","title":"API","text":"Public Members:","category":"page"},{"location":"api/quantumpropagators/","page":"API","title":"API","text":"specrange","category":"page"},{"location":"api/quantumpropagators/","page":"API","title":"API","text":"Private Members:","category":"page"},{"location":"api/quantumpropagators/","page":"API","title":"API","text":"random_state\nritzvals","category":"page"},{"location":"api/quantumpropagators/#Public-members-10","page":"API","title":"Public members","text":"","category":"section"},{"location":"api/quantumpropagators/","page":"API","title":"API","text":"QuantumPropagators.SpectralRange.specrange","category":"page"},{"location":"api/quantumpropagators/#QuantumPropagators.SpectralRange.specrange","page":"API","title":"QuantumPropagators.SpectralRange.specrange","text":"Calculate the spectral range of a Hamiltonian H on the real axis.\n\nE_min, E_max = specrange(H; method=:auto, kwargs...)\n\ncalculates the approximate lowest and highest eigenvalues of H. Any imaginary part in the eigenvalues is ignored: the routine is intended for (although not strictly limited to) a Hermitian H.\n\nThis delegates to\n\nspecrange(H, method; kwargs...)\n\nfor the different methods.\n\nThe default method=:auto chooses the best method for the given H. This is :diag for small matrices, and :arnoldi otherwise. If both E_min and E_max are given in the kwargs, those will be returned directly (method=:manual).\n\nKeyword arguments not relevant to the underlying implementation will be ignored.\n\n\n\n\n\nE_min, E_max = specrange(\n    H, :arnoldi;\n    rng=Random.GLOBAL_RNG,\n    state=random_state(H; rng),\n    m_min=20,\n    m_max=60,\n    prec=1e-3,\n    norm_min=1e-15,\n    enlarge=true\n)\n\nuses Arnoldi iteration with state as the starting vector. It approximates the eigenvalues of H with between m_min and m_max Ritz values, until the lowest and highest eigenvalue are stable to a relative precision of prec. The norm_min parameter is passed to the underlying arnoldi!.\n\nIf enlarge=true (default) the returned E_min and E_max will be enlarged via a heuristic to slightly over-estimate the spectral radius instead of under-estimating it.\n\n\n\n\n\nE_min, E_max = specrange(H, :diag)\n\nuses exact diagonization via the standard eigvals function to obtain the smallest and largest eigenvalue. This should only be used for relatively small matrices.\n\n\n\n\n\nE_min, E_max = specrange(H, :manual; E_min, E_max)\n\ndirectly returns the given E_min and E_max without considering H.\n\n\n\n\n\n","category":"function"},{"location":"api/quantumpropagators/#Private-members-4","page":"API","title":"Private members","text":"","category":"section"},{"location":"api/quantumpropagators/","page":"API","title":"API","text":"QuantumPropagators.SpectralRange.random_state\nQuantumPropagators.SpectralRange.ritzvals","category":"page"},{"location":"api/quantumpropagators/#QuantumPropagators.SpectralRange.random_state","page":"API","title":"QuantumPropagators.SpectralRange.random_state","text":"Random normalized quantum state.\n\n    Ψ = random_state(H; rng=Random.GLOBAL_RNG)\n\nreturns a random normalized state compatible with the Hamiltonian H. This is intended to provide a starting vector for estimating the spectral radius of H via an Arnoldi method.\n\n\n\n\n\n","category":"function"},{"location":"api/quantumpropagators/#QuantumPropagators.SpectralRange.ritzvals","page":"API","title":"QuantumPropagators.SpectralRange.ritzvals","text":"Calculate a vector for Ritz values converged to a given precision.\n\nR = ritzvals(G, state, m_min, m_max=2*m_min; prec=1e-5, norm_min=1e-15)\n\ncalculates a complex vector R of at least m_min (assuming a sufficient Krylov dimension) and at most m_max Ritz values.\n\n\n\n\n\n","category":"function"},{"location":"api/quantumpropagators/#QuantumPropagatorsArnoldiAPI","page":"API","title":"QuantumPropagators.Arnoldi","text":"","category":"section"},{"location":"api/quantumpropagators/","page":"API","title":"API","text":"Arnoldi iteration is an approximate method to find extremal eigenvalues of a dynamical generator by projecting it into a Krylov subspace. It is used to estimate spectral ranges for Chebychev Propagation and to find appropriate Leja points to support Newton Propagation","category":"page"},{"location":"api/quantumpropagators/#Reference-10","page":"API","title":"Reference","text":"","category":"section"},{"location":"api/quantumpropagators/","page":"API","title":"API","text":"Private Members:","category":"page"},{"location":"api/quantumpropagators/","page":"API","title":"API","text":"extend_arnoldi!\ndiagonalize_hessenberg_matrix\narnoldi!","category":"page"},{"location":"api/quantumpropagators/#Private-members-5","page":"API","title":"Private members","text":"","category":"section"},{"location":"api/quantumpropagators/","page":"API","title":"API","text":"QuantumPropagators.Arnoldi.extend_arnoldi!\nQuantumPropagators.Arnoldi.diagonalize_hessenberg_matrix\nQuantumPropagators.Arnoldi.arnoldi!","category":"page"},{"location":"api/quantumpropagators/#QuantumPropagators.Arnoldi.extend_arnoldi!","page":"API","title":"QuantumPropagators.Arnoldi.extend_arnoldi!","text":"Extend dimension of Hessenberg matrix by one.\n\nextend_arnoldi!(Hess, q, m, H, dt; norm_min=1e-15)\n\nextends the entries in Hess from size (m-1)×(m-1) to size m×m, and the list q of Arnoldi vectors from m to (m+1). It is assumed that the input Hess was created by a call to arnoldi! with extended=false or a previous call to extend_arnoldi!. Note that Hess itself is not resized, so it must be allocated to size m×m or greater on input.\n\n\n\n\n\n","category":"function"},{"location":"api/quantumpropagators/#QuantumPropagators.Arnoldi.diagonalize_hessenberg_matrix","page":"API","title":"QuantumPropagators.Arnoldi.diagonalize_hessenberg_matrix","text":"diagonalize_hessenberg_matrix(Hess, m; accumulate=false)\n\nDiagonalize the m × m top left submatrix of the given Hessenberg matrix.\n\nIf accumulate is true, return the concatenated eigenvalues for Hess[1:1,1:1] to Hess[1:m,1:m], that is, all sumatrices of size 1 through m.\n\n\n\n\n\n","category":"function"},{"location":"api/quantumpropagators/#QuantumPropagators.Arnoldi.arnoldi!","page":"API","title":"QuantumPropagators.Arnoldi.arnoldi!","text":"m = arnoldi!(Hess, q, m, Ψ, H, dt=1.0; extended=true, norm_min=1e-15)\n\nCalculate the Hessenberg matrix and Arnoldi vectors of H dt, from Ψ.\n\nFor a given order m, the m×m Hessemberg matrix is calculated and stored in in the pre-allocated Hess. Further  an array of m normalized Arnoldi vectors is stored in in the pre-allocated q, plus one additional unnormalized Arnoldi vector.  The unnormalized m+1st vector could be used to easily extend a given m×m Hessenberg matrix to a (m+1)×(m+1) matrix.\n\nIf the extended Hessenberg matrix is requested (extended=true, default), the m+1st Arnoldi vector is also normalized, and it's norm will be stored in m+1, m entry of the (extended) Hessenberg matrix, which is an (m+1)×(m+1) matrix.\n\nReturn the size m of the calculated Hessenberg matrix. This will usually be the input m, except when the Krylov dimension of H starting from Ψ is less then m. E.g., if Ψ is an eigenstate of H, the returned m will be 1.\n\nSee https://en.wikipedia.org/wiki/Arnoldi_iteration for a description of the algorithm.\n\nArguments\n\nHess::Matrix{ComplexF64}: Pre-allocated storage for the Hessemberg matrix.  Can be uninitialized on input. The matrix must be at least of size m×m, or  (m+1)×(m+1) if extended=true. On output, the m×m sub-matrix of Hess  (with the returned output m) will contain the Hessenberg matrix, and all  other elements of Hess be be set to zero.\nq: Pre-allocated array of states similar to Ψ, as storage for the calculated Arnoldi vectors. These may be un-initialized on input. Must be at least of length m+1\nm: The requested dimensions of the output Hessenberg matrix.\nΨ: The starting vector for the Arnoldi procedure. This can be of any type,  as long as Φ = H * Ψ results in a vector similar to Ψ, there is an inner  products of Φ and Ψ (Ψ⋅Φ is defined), and norm(Ψ) is defined.\nH: The operator (up to dt) for which to calculate the Arnoldi procedure. Can be of any type, as long as H * Ψ is defined.\ndt: The implicit time step; the total operator for which to calculate the Arnoldi procedure is H * dt\nextended: If true (default), calculate the extended Hessenberg matrix, and normalized the final Arnoldi vector\nnorm_min: the minimum value of the norm of Ψ at which Ψ should be  considered the zero vector\n\n\n\n\n\n","category":"function"},{"location":"api/quantumpropagators/#QuantumPropagatorsInterfacesAPI","page":"API","title":"QuantumPropagators.Interfaces","text":"","category":"section"},{"location":"api/quantumpropagators/","page":"API","title":"API","text":"The following routines allow to test whether custom data structures match the interface requirements of QuantumPropagators.","category":"page"},{"location":"api/quantumpropagators/#Reference-11","page":"API","title":"Reference","text":"","category":"section"},{"location":"api/quantumpropagators/","page":"API","title":"API","text":"Public Members:","category":"page"},{"location":"api/quantumpropagators/","page":"API","title":"API","text":"check_amplitude\ncheck_control\ncheck_generator\ncheck_operator\ncheck_parameterized\ncheck_parameterized_function\ncheck_propagator\ncheck_state\ncheck_tlist\nsupports_inplace","category":"page"},{"location":"api/quantumpropagators/#Public-members-11","page":"API","title":"Public members","text":"","category":"section"},{"location":"api/quantumpropagators/","page":"API","title":"API","text":"QuantumPropagators.Interfaces.check_amplitude\nQuantumPropagators.Interfaces.check_control\nQuantumPropagators.Interfaces.check_generator\nQuantumPropagators.Interfaces.check_operator\nQuantumPropagators.Interfaces.check_parameterized\nQuantumPropagators.Interfaces.check_parameterized_function\nQuantumPropagators.Interfaces.check_propagator\nQuantumPropagators.Interfaces.check_state\nQuantumPropagators.Interfaces.check_tlist\nQuantumPropagators.Interfaces.supports_inplace","category":"page"},{"location":"api/quantumpropagators/#QuantumPropagators.Interfaces.check_amplitude","page":"API","title":"QuantumPropagators.Interfaces.check_amplitude","text":"Check amplitude appearing in Generator.\n\n@test check_amplitude(ampl; tlist, quiet=false)\n\nverifies that the given ampl is a valid element in the list of amplitudes of a Generator object. Specifically:\n\nget_controls(ampl) must be defined and return a tuple\nall controls in ampl must pass check_control\nsubstitute(ampl, controls_replacements) must be defined\nevaluate(ampl, tlist, n) must be defined and return a Number\nevaluate(ampl, tlist, n; vals_dict) must be defined and return a Number\n\nIf for_parameterization (may require the RecursiveArrayTools package to be loaded):\n\nget_parameters(ampl) must be defined and return a vector of floats. Mutating that vector must mutate the controls inside the ampl.\n\nThe function returns true for a valid amplitude and false for an invalid amplitude. Unless quiet=true, it will log an error to indicate which of the conditions failed.\n\n\n\n\n\n","category":"function"},{"location":"api/quantumpropagators/#QuantumPropagators.Interfaces.check_control","page":"API","title":"QuantumPropagators.Interfaces.check_control","text":"Check that control can be evaluated on a time grid.\n\n@test check_control(\n    control;\n    tlist,\n    for_parameterization=true,\n    for_time_continuous=(control isa Function),\n    quiet=false\n)\n\nverifies the given control (one of the elements of the tuple returned by get_controls):\n\nevaluate(control, tlist, n) must be defined and return a Float64\nevaluate(control, tlist, n; vals_dict=IdDict(control => v)) must be defined and return v\ndiscretize(control, tlist) must be defined and return a vector of floats of the same size as tlist. Only if length(tlist) > 2.\nall values in discretize(control, tlist) must be finite (isfinite).\ndiscretize_on_midpoints(control, tlist) must be defined and return a vector of floats with one element less than tlist. Only if length(tlist) > 2.\nall values in discretize_on_midpoints(control, tlist) must be finite (isfinite)\n\nIf for_time_continuous:\n\nevaluate(control, t) must be defined and return a Float64\nevaluate(control, t; vals_dict=IdDict(control => v)) must be defined and return v\n\nIf for_parameterization:\n\nget_parameters(control) must be defined and return a vector of floats. Mutating that vector must mutate the control.\n\nThe function returns true for a valid control and false for an invalid control. Unless quiet=true, it will log an error to indicate which of the conditions failed.\n\n\n\n\n\n","category":"function"},{"location":"api/quantumpropagators/#QuantumPropagators.Interfaces.check_generator","page":"API","title":"QuantumPropagators.Interfaces.check_generator","text":"Check the dynamical generator for propagating state over tlist.\n\n@test check_generator(\n    generator; state, tlist,\n    for_pwc=true, for_time_continuous=false,\n    for_expval=true, for_parameterization=false,\n    atol=1e-14, quiet=false)\n\nverifies the given generator:\n\nget_controls(generator) must be defined and return a tuple\nall controls returned by get_controls(generator) must pass check_control\nsubstitute(generator, replacements) must be defined\nIf generator is a Generator instance, all elements of generator.amplitudes must pass check_amplitude with for_parameterization.\n\nIf for_pwc (default):\n\nop = evaluate(generator, tlist, n) must return a valid operator (check_operator), with forwarded keyword arguments (including for_expval)\nIf QuantumPropagators.Interfaces.supports_inplace(op) is true, evaluate!(op, generator, tlist, n) must be defined\n\nIf for_time_continuous:\n\nevaluate(generator, t) must return a valid operator (check_operator), with forwarded keyword arguments (including for_expval)\nIf QuantumPropagators.Interfaces.supports_inplace(op) is true, evaluate!(op, generator, t) must be defined\n\nIf for_parameterization (may require the RecursiveArrayTools package to be loaded):\n\nget_parameters(generator) must be defined and return a vector of floats. Mutating that vector must mutate the controls inside the generator.\n\nThe function returns true for a valid generator and false for an invalid generator. Unless quiet=true, it will log an error to indicate which of the conditions failed.\n\n\n\n\n\n","category":"function"},{"location":"api/quantumpropagators/#QuantumPropagators.Interfaces.check_operator","page":"API","title":"QuantumPropagators.Interfaces.check_operator","text":"Check that op is a valid operator that can be applied to state.\n\n@test check_operator(op; state, tlist=[0.0, 1.0],\n                     for_expval=true, atol=1e-14, quiet=false)\n\nverifies the given op relative to state. The state must pass check_state.\n\nAn \"operator\" is any object that evaluate returns when evaluating a time-dependent dynamic generator. The specific requirements for op are:\n\nop must not be time-dependent: evaluate(op, tlist, 1) ≡ op\nop must not contain any controls: length(get_controls(op)) == 0\nop * state must be defined\nThe QuantumPropagators.Interfaces.supports_inplace method must be defined for op. If it returns true, it must be possible to evaluate a generator in-place into the existing op. See check_generator.\n\nIf QuantumPropagators.Interfaces.supports_inplace(state):\n\nThe 3-argument LinearAlgebra.mul! must apply op to the given state\nThe 5-argument LinearAlgebra.mul! must apply op to the given state\nLinearAlgebra.mul! must match *, if applicable\nLinearAlgebra.mul! must return the resulting state\n\nIf for_expval (typically required for optimal control):\n\nLinearAlgebra.dot(state, op, state) must return return a number\ndot(state, op, state) must match dot(state, op * state), if applicable\n\nThe function returns true for a valid operator and false for an invalid operator. Unless quiet=true, it will log an error to indicate which of the conditions failed.\n\n\n\n\n\n","category":"function"},{"location":"api/quantumpropagators/#QuantumPropagators.Interfaces.check_parameterized","page":"API","title":"QuantumPropagators.Interfaces.check_parameterized","text":"Check that that the object supports the parameterization interface.\n\n@test check_parameterized(object; name=\"::$typeof(object))\", quiet=false)\n\nverifies that the given object:\n\ncan be passed to get_parameters, which must return an AbstractVector of Float64\nis mutated by mutating the parameters obtained by get_parameters\n\nSee also\n\ncheck_parameterized_function is object is a ParameterizedFunction\n\n\n\n\n\n","category":"function"},{"location":"api/quantumpropagators/#QuantumPropagators.Interfaces.check_parameterized_function","page":"API","title":"QuantumPropagators.Interfaces.check_parameterized_function","text":"Check a ParameterizedFunction instance.\n\n@test check_parameterized_function(f; tlist; quiet=false)\n\nverifies that the given f:\n\nis an instance of ParameterizedFunction.\nhas a field parameters that is an AbstractVector{Float64}.\nis a callable as f(t) for values of t in tlist, returning a Float64.\nget_parameters provides access to the parameters field.\npasses check_parameterized\n\nSee also\n\ncheck_parameterized for objects that have parameters (get_parameters), but are not instances of ParameterizedFunction\n\n\n\n\n\n","category":"function"},{"location":"api/quantumpropagators/#QuantumPropagators.Interfaces.check_propagator","page":"API","title":"QuantumPropagators.Interfaces.check_propagator","text":"Check that the given propagator implements the required interface.\n\n@test check_propagator(propagator; atol=1e-14, quiet=false)\n\nverifies that the propagator matches the interface described for an AbstractPropagator. The propagator must have been freshly initialized with init_prop.\n\npropagator must have the properties state, tlist, t, parameters, backward, and inplace\npropagator.state must be a valid state (see check_state)\nIf propagator.inplace is true, supports_inplace for propagator.state must also be true\npropagator.tlist must be monotonically increasing.\npropagator.t must be the first or last element of propagator.tlist, depending on propagator.backward\nprop_step!(propagator) must be defined and return a valid state until the time grid is exhausted\nFor an in-place propagator, the state returned by prop_step! must be the propagator.state object\nFor a not-in-place propagator, the state returned by prop_step! must be a new object\nprop_step! must advance propagator.t forward or backward one step on the time grid\nprop_step! must return nothing when going beyond the time grid\nset_t!(propagator, t) must be defined and set propagator.t\nset_state!(propagator, state) must be defined and set propagator.state.\nset_state!(propagator, state) for an in-place propagator   must overwrite propagator.state in-place.\nset_state! must return the set propagator.state\nIn a PiecewisePropagator, propagator.parameters must be a dict mapping controls to a vector of values, one for each interval on propagator.tlist\nreinit_prop! must be defined and re-initialize the propagator\nreinit_prop!(propagator, state) must be idempotent. That is, repeated calls to reinit_prop! leave the propagator unchanged.\n\nThe function returns true for a valid propagator and false for an invalid propagator. Unless quiet=true, it will log an error to indicate which of the conditions failed.\n\n\n\n\n\n","category":"function"},{"location":"api/quantumpropagators/#QuantumPropagators.Interfaces.check_state","page":"API","title":"QuantumPropagators.Interfaces.check_state","text":"Check that state is a valid element of a Hilbert space.\n\n@test check_state(state; normalized=false, atol=1e-15, quiet=false)\n\nverifies the following requirements:\n\nThe inner product (LinearAlgebra.dot) of two states must return a Complex number.\nThe LinearAlgebra.norm of state must be defined via the inner product. This is the definition of a Hilbert space, a.k.a a \"complete inner product space\" or more precisely a \"Banach space (normed vector space) where the norm is induced by an inner product\".\nThe `QuantumPropagators.Interfaces.supports_inplace method must be defined for state\n\nAny state must support the following not-in-place operations:\n\nstate + state and state - state must be defined\ncopy(state) must be defined and return an object of the same type as state\nc * state for a scalar c must be defined\nnorm(state + state) must fulfill the triangle inequality\nzero(state) must be defined and produce a state with norm 0\n0.0 * state must produce a state with norm 0\ncopy(state) - state must have norm 0\nnorm(state) must have absolute homogeneity: norm(s * state) = s * norm(state)\n\nIf supports_inplace(state) is true, the state must also support the following:\n\nsimilar(state) must be defined and return a valid state of the same type a state\ncopyto!(other, state) must be defined\nfill!(state, c) must be defined\nLinearAlgebra.lmul!(c, state) for a scalar c must be defined\nLinearAlgebra.axpy!(c, state, other) must be defined\nnorm(state) must fulfill the same general mathematical norm properties as for the non-in-place norm.\n\nIf normalized (not required by default):\n\nLinearAlgebra.norm(state) must be 1\n\nIt is strongly recommended to always support immutable operations (also for mutable states)\n\nThe function returns true for a valid state and false for an invalid state. Unless quiet=true, it will log an error to indicate which of the conditions failed.\n\n\n\n\n\n","category":"function"},{"location":"api/quantumpropagators/#QuantumPropagators.Interfaces.check_tlist","page":"API","title":"QuantumPropagators.Interfaces.check_tlist","text":"Check that the given tlist is valid.\n\n@test check_tlist(tlist; quiet=false)\n\nverifies the given time grid. A valid time grid must\n\nbe a Vector{Float64},\ncontain at least two points (beginning and end),\nbe monotonically increasing\n\nThe function returns true for a valid time grid and false for an invalid time grid. Unless quiet=true, it will log an error to indicated which of the conditions failed.\n\n\n\n\n\n","category":"function"},{"location":"api/quantumpropagators/#QuantumPropagators.Interfaces.supports_inplace","page":"API","title":"QuantumPropagators.Interfaces.supports_inplace","text":"Indicate whether a given state or operator supports in-place operations\n\nsupports_inplace(state)\n\nIndicates that propagators can assume that the in-place requirements defined in QuantumPropagators.Interfaces.check_state hold. States with in-place support must also fulfill specific properties when interacting with operators, see QuantumPropagators.Interfaces.check_operator.\n\nsupports_inplace(op)\n\nIndicates that the operator can be evaluated in-place with evaluate!, see QuantumPropagators.Interfaces.check_generator\n\nNote that supports_inplace is not quite the same as Base.ismutable: When using custom structs for states or operators, even if those structs are not defined as mutable, they may still define the in-place interface (typically because their components are mutable).\n\n\n\n\n\n","category":"function"},{"location":"api/quantumpropagators/#Index","page":"API","title":"Index","text":"","category":"section"},{"location":"api/quantumpropagators/","page":"API","title":"API","text":"","category":"page"},{"location":"benchmarks/profiling/#Profiling-Howto","page":"Profiling Howto","title":"Profiling Howto","text":"","category":"section"},{"location":"benchmarks/profiling/","page":"Profiling Howto","title":"Profiling Howto","text":"To choose an appropriate propagation method and parameters for a given problem, it is essential to benchmark and profile the propagation.","category":"page"},{"location":"benchmarks/profiling/","page":"Profiling Howto","title":"Profiling Howto","text":"Consider the following simple example:","category":"page"},{"location":"benchmarks/profiling/","page":"Profiling Howto","title":"Profiling Howto","text":"using QuantumControlTestUtils.RandomObjects: random_dynamic_generator, random_state_vector\n\ntlist = collect(range(0, step=1.0, length=101));\nN = 200;  # size of Hilbert space\nH = random_dynamic_generator(N, tlist);\nΨ₀ = random_state_vector(N);\nnothing  # hide","category":"page"},{"location":"benchmarks/profiling/#BenchmarkTools","page":"Profiling Howto","title":"BenchmarkTools","text":"","category":"section"},{"location":"benchmarks/profiling/","page":"Profiling Howto","title":"Profiling Howto","text":"The first line of defense is the use of BenchmarkTools. The @benchmark macro allows to generate statistics on how long a call to propagate takes.","category":"page"},{"location":"benchmarks/profiling/#Chebychev-propagation","page":"Profiling Howto","title":"Chebychev propagation","text":"","category":"section"},{"location":"benchmarks/profiling/","page":"Profiling Howto","title":"Profiling Howto","text":"For example, we can time the propagation with the Chebychev method:","category":"page"},{"location":"benchmarks/profiling/","page":"Profiling Howto","title":"Profiling Howto","text":"using BenchmarkTools\nusing QuantumPropagators\nusing QuantumPropagators: Cheby\n\n@benchmark propagate($Ψ₀, $H, $tlist; method=Cheby, check=false) samples=10","category":"page"},{"location":"benchmarks/profiling/#Newton-propagation","page":"Profiling Howto","title":"Newton propagation","text":"","category":"section"},{"location":"benchmarks/profiling/","page":"Profiling Howto","title":"Profiling Howto","text":"Or, the same propagation with the Newton method:","category":"page"},{"location":"benchmarks/profiling/","page":"Profiling Howto","title":"Profiling Howto","text":"using QuantumPropagators: Newton\n\n@benchmark propagate($Ψ₀, $H, $tlist; method=Newton, check=false) samples=10","category":"page"},{"location":"benchmarks/profiling/","page":"Profiling Howto","title":"Profiling Howto","text":"The result in this case illustrates the significant advantage of the Chebychev method for systems of moderate to small size and unitary dynamics.","category":"page"},{"location":"benchmarks/profiling/","page":"Profiling Howto","title":"Profiling Howto","text":"When using custom data structures for the dynamical generators or states, @benchmark should also be used to optimize lower-level operations as much as possible, e.g. the application of the Hamiltonian to the state.","category":"page"},{"location":"benchmarks/profiling/#TimerOutputs","page":"Profiling Howto","title":"TimerOutputs","text":"","category":"section"},{"location":"benchmarks/profiling/","page":"Profiling Howto","title":"Profiling Howto","text":"A lot more insight into the internals of a propagate call can be obtained by collecting timing data. This functionality is integrated in QuantumPropagators and uses the TimerOutputs package internally.","category":"page"},{"location":"benchmarks/profiling/#Enabling-the-collection-of-timing-data","page":"Profiling Howto","title":"Enabling the collection of timing data","text":"","category":"section"},{"location":"benchmarks/profiling/","page":"Profiling Howto","title":"Profiling Howto","text":"To enable collecting internal timing data, call QuantumPropagators.enable_timings:","category":"page"},{"location":"benchmarks/profiling/","page":"Profiling Howto","title":"Profiling Howto","text":"QuantumPropagators.enable_timings()\nnothing # hide","category":"page"},{"location":"benchmarks/profiling/","page":"Profiling Howto","title":"Profiling Howto","text":"The status of the data collection can be verified with QuantumPropagators.timings_enabled.","category":"page"},{"location":"benchmarks/profiling/#Chebychev-propagation-2","page":"Profiling Howto","title":"Chebychev propagation","text":"","category":"section"},{"location":"benchmarks/profiling/","page":"Profiling Howto","title":"Profiling Howto","text":"Since the call to QuantumPropagators.enable_timings invalidates existing compiled code, and to avoid the compilation overhead showing up in the timing data, we call propagate once to ensure compilation:","category":"page"},{"location":"benchmarks/profiling/","page":"Profiling Howto","title":"Profiling Howto","text":"propagate(Ψ₀, H, tlist; method=Cheby);\nnothing  # hide","category":"page"},{"location":"benchmarks/profiling/","page":"Profiling Howto","title":"Profiling Howto","text":"In any subsequent propagation, we could access the timing data in a callback to propagate:","category":"page"},{"location":"benchmarks/profiling/","page":"Profiling Howto","title":"Profiling Howto","text":"function show_timing_data(propagator, args...)\n    if propagator.t == tlist[end]\n        show(propagator.timing_data, compact=true)\n    end\nend\n\npropagate(Ψ₀, H, tlist; method=:cheby, callback=show_timing_data);\nnothing  # hide","category":"page"},{"location":"benchmarks/profiling/","page":"Profiling Howto","title":"Profiling Howto","text":"See the TimerOutputs documentation for details on how to print the timing_data.","category":"page"},{"location":"benchmarks/profiling/","page":"Profiling Howto","title":"Profiling Howto","text":"Alternatively, without a callback:","category":"page"},{"location":"benchmarks/profiling/","page":"Profiling Howto","title":"Profiling Howto","text":"propagator = init_prop(Ψ₀, H, tlist; method=Cheby)\nfor step ∈ 1:(length(tlist)-1)\n    prop_step!(propagator)\nend\nshow(propagator.timing_data, compact=true)","category":"page"},{"location":"benchmarks/profiling/","page":"Profiling Howto","title":"Profiling Howto","text":"The reported runtimes here are less important than the number of function calls and the runtime percentages. In this case, the timing data shows that the propagation is dominated by the matrix-vector products (applying the Hamiltonian to the state), as it should. The percentage would go to 100% for larger Hilbert spaces.","category":"page"},{"location":"benchmarks/profiling/#Newton-propagation-2","page":"Profiling Howto","title":"Newton propagation","text":"","category":"section"},{"location":"benchmarks/profiling/","page":"Profiling Howto","title":"Profiling Howto","text":"For the Newton method:","category":"page"},{"location":"benchmarks/profiling/","page":"Profiling Howto","title":"Profiling Howto","text":"propagate(Ψ₀, H, tlist; method=Newton);   # recompilation\npropagate(Ψ₀, H, tlist; method=Newton, callback=show_timing_data);\nnothing  # hide","category":"page"},{"location":"benchmarks/profiling/","page":"Profiling Howto","title":"Profiling Howto","text":"We see here that the Newton propagation requires more matrix-vector products (2000 compared to 1200 for Chebychev), partly because the Newton propagator is \"chunked\" to m_max applications in each \"restart\" (10 by default, with 2 restarts required to reach machine precision in this case). Moreover, there is significant overhead beyond just matrix-vector multiplication, which will disappear only for significantly larger Hilbert spaces.","category":"page"},{"location":"benchmarks/profiling/#Disabling-the-collection-of-timing-data","page":"Profiling Howto","title":"Disabling the collection of timing data","text":"","category":"section"},{"location":"benchmarks/profiling/","page":"Profiling Howto","title":"Profiling Howto","text":"There there is a small overhead associated with collecting the timing data, it should not be enabled \"in production\". To QuantumPropagators.disable_timings function undoes the previous QuantumPropagators.enable_timings:","category":"page"},{"location":"benchmarks/profiling/","page":"Profiling Howto","title":"Profiling Howto","text":"QuantumPropagators.disable_timings()\nnothing # hide","category":"page"},{"location":"benchmarks/profiling/","page":"Profiling Howto","title":"Profiling Howto","text":"This again will trigger recompilation of any method that was collecting timing data, removing the associated overhead.","category":"page"},{"location":"generators/#Dynamical-Generators","page":"Dynamical Generators","title":"Dynamical Generators","text":"","category":"section"},{"location":"generators/","page":"Dynamical Generators","title":"Dynamical Generators","text":"The propagate routine simulates the dynamics of a state Ψ or ρ under the assumption that the dynamics are described by a generator object. The exact equation of motion is implicit in the Propagator, but all propagators implemented in the QuantumPropagators package assume that the generator is the time-dependent Hamiltonian H(t) in the Schrödinger equation (ħ=1)","category":"page"},{"location":"generators/","page":"Dynamical Generators","title":"Dynamical Generators","text":"<a id=\"eq-se\"></a>","category":"page"},{"location":"generators/","page":"Dynamical Generators","title":"Dynamical Generators","text":"tagSE\ni fract Ψ = H(t) Ψ","category":"page"},{"location":"generators/#Operators","page":"Dynamical Generators","title":"Operators","text":"","category":"section"},{"location":"generators/","page":"Dynamical Generators","title":"Dynamical Generators","text":"When evaluating the right-hand-side of Eq. (SE), the time-dependent generator H(t) is first evaluated into a static operator object H for a specific point in time via the QuantumPropagators.Controls.evaluate function. The 5-argument LinearAlgebra.mul! then implements the application of the operator to the state Ψ.","category":"page"},{"location":"generators/#Hamiltonians","page":"Dynamical Generators","title":"Hamiltonians","text":"","category":"section"},{"location":"generators/","page":"Dynamical Generators","title":"Dynamical Generators","text":"The built-in hamiltonian function initializes a Generator object encapsulating a generator of the most general form","category":"page"},{"location":"generators/","page":"Dynamical Generators","title":"Dynamical Generators","text":"<a id=\"eq-generator\"></a>","category":"page"},{"location":"generators/","page":"Dynamical Generators","title":"Dynamical Generators","text":"tagGenerator\nH(t) = H_0 + sum_l a_l(ϵ_l(t) t)  H_l","category":"page"},{"location":"generators/","page":"Dynamical Generators","title":"Dynamical Generators","text":"The Hamiltonian consists of an (optional) drift term H_0 and an arbitrary number of control terms that separate into a scalar control amplitude a_l(ϵ_l(t) t) and a static control operator  H_l. Each control amplitude may consist of one or more control function ϵ_l(t). Most commonly, a_l(t)  ϵ_l(t), and thus the Hamiltonian is of the simpler form","category":"page"},{"location":"generators/","page":"Dynamical Generators","title":"Dynamical Generators","text":"H(t) = H_0 + sum_l ϵ_l(t)  H_l","category":"page"},{"location":"generators/","page":"Dynamical Generators","title":"Dynamical Generators","text":"The evaluate function evaluates time-dependent Generator instances into static Operator objects.","category":"page"},{"location":"generators/#ControlAmplitudes","page":"Dynamical Generators","title":"Control Amplitudes","text":"","category":"section"},{"location":"generators/","page":"Dynamical Generators","title":"Dynamical Generators","text":"The distinction between control amplitudes and control functions becomes important only in the context of optimal control, where the control functions are directly modified by optimal control, whereas the control amplitudes determine how the control functions couple to the control operators, or account for explicit time dependencies in the Hamiltonian.","category":"page"},{"location":"generators/","page":"Dynamical Generators","title":"Dynamical Generators","text":"Just as the evaluate function evaluates time-dependent generators into static operators, it also evaluates control amplitudes or control functions to scalar values.","category":"page"},{"location":"generators/#Liouvillians","page":"Dynamical Generators","title":"Liouvillians","text":"","category":"section"},{"location":"generators/","page":"Dynamical Generators","title":"Dynamical Generators","text":"In an open quantum system, the equation of motion is assumed to take the exact same form as in Eq. (SE),","category":"page"},{"location":"generators/","page":"Dynamical Generators","title":"Dynamical Generators","text":"i fract ρ = L(t) ρ","category":"page"},{"location":"generators/","page":"Dynamical Generators","title":"Dynamical Generators","text":"where L is the Liouvillian up to a factor of i.","category":"page"},{"location":"generators/","page":"Dynamical Generators","title":"Dynamical Generators","text":"The object representing L should be constructed with the liouvillian function, with convention=:TDSE. Just like hamiltonian, this returns a Generator instance that evaluate turns into a static Operator to be applied to a vectorized (!) state ρ.","category":"page"},{"location":"generators/#Arbitrary-Generators","page":"Dynamical Generators","title":"Arbitrary Generators","text":"","category":"section"},{"location":"generators/","page":"Dynamical Generators","title":"Dynamical Generators","text":"For an \"unusual\" generator, first decide at which level to address the issue:","category":"page"},{"location":"generators/","page":"Dynamical Generators","title":"Dynamical Generators","text":"If there is no optimal control being done, it may be sufficient to define a new control object directly. The required interface is defined in QuantumPropagators.Interfaces.check_control.\nFor e.g. non-linear controls, it is enough to define a new control amplitude type (representing the a_l in Eq. (Generator)). See QuantumPropagators.Interfaces.check_amplitude for the required interface. Some amplitudes that are useful in the context of optimal control defined in QuantumPropagators.Amplitudes. Moreover, QuantumControl.PulseParametrizations provides the tools to define amplitudes of the form a_l(t) = a(ϵ_l(t)). That is, anything where the value of a_l(t) depends directly on the value of ϵ_l(t)). This includes nonlinear controls such as ϵ^2(t).\nFor any Hamiltonian or Liouvillian that is more general than the form in Eq. (Generator), a fully custom generator type would have to be implemented, see below.","category":"page"},{"location":"generators/","page":"Dynamical Generators","title":"Dynamical Generators","text":"In general, the methods defined in the QuantumPropagators.Controls module (respectively QuantumControl.Controls in the broader context of optimal control) determine the relationship between generators, operators, amplitudes, and controls and must be implemented for any custom types.","category":"page"},{"location":"generators/","page":"Dynamical Generators","title":"Dynamical Generators","text":"In particular,","category":"page"},{"location":"generators/","page":"Dynamical Generators","title":"Dynamical Generators","text":"QuantumPropagators.Controls.get_controls extracts the time-dependent control functions from a generator.\nQuantumPropagators.Controls.evaluate and evaluate! convert time-dependent generators into static operators, or control amplitudes/functions into scalar values.\nQuantumPropagators.Controls.substitute substitute control amplitudes or control functions for other control amplitudes or control functions.","category":"page"},{"location":"generators/","page":"Dynamical Generators","title":"Dynamical Generators","text":"See QuantumPropagators.Interfaces.check_generator for the full required interface (or the extended QuantumControl.Interfaces.check_generator that also includes the methods required for optimal control).","category":"page"},{"location":"methods/#Propagation-Methods","page":"Propagation Methods","title":"Propagation Methods","text":"","category":"section"},{"location":"methods/","page":"Propagation Methods","title":"Propagation Methods","text":"gdefop1hat1\ngdefket1vert1rangle\ngdefLiouvillianmathcalL\ngdefReoperatornameRe\ngdefImoperatornameIm","category":"page"},{"location":"methods/","page":"Propagation Methods","title":"Propagation Methods","text":"As discussed in the Overview, time propagation can be implemented in one of two ways:","category":"page"},{"location":"methods/","page":"Propagation Methods","title":"Propagation Methods","text":"By analytically solving the equation of motion and numerically evaluating the application time evolution operator.\nWe consider this especially in the piecewise-constant case (pwc=true in propagate/init_prop), which is required for the traditional optimization methods GRAPE and Krotov. In these propagations, the time-dependent generator opH(t) is evaluated to a constant operator opH on each interval of the time grid. The analytical solution to the Schrödinger or Liouville equation is well known, and propagation step simply has to evaluate the application of the time evolution operator opU = exp-i opH dt to the state Ψ. The following methods are built in to QuantumPropagators:\nExpProp – constructs opU explicitly and then applies it to Ψ\nCheby — expansion of opU Ψ into Chebychev polynomials, valid if opH has real eigenvalues\nNewton – expansion of opU Ψ into Newton polynomials, valid if opH has complex eigenvalues (non-Hermitian Hamiltonian, Liouvillian)\nThe ExpProp method is generally not numerically efficient, but works well for small system for for debugging. The two \"core\" methods based on a polynomials series expansions are more suitable for bigger systems and provide both efficiency and high precision (in general, the is truncated as soon as some desired precision is reached, which is machine precision by default).\nNote that this high precision is within the piecewise-constant approximation. The discretization itself may introduce a non-negligible error compared to the time-continuous dynamics. There is tradeoff: A smaller dt decreases the discretization error, but the polynomial expansions are more effective with larger time steps.\nBy solving the equation of motion explicitly with an ODE solver.\nWe support the use of any of the ODE solvers in OrdinaryDiffEq.jl:\nOrdinaryDiffEq – solve the equation of motion as an ODE\nThe main benefit of using an ODE solver is that the generator opH(t) can be treated as time-continuous, and thus avoid the time discretization error. While this is not compatible with traditional optimal control method like GRAPE and Krotov, it is suitable for control methods for tuning analytical control parameters [6–8].\nThe method=OrdinaryDiffEq is also available in a piecewise-constant mode by setting pwc=true, for comparison with method=Cheby and method=Newton.","category":"page"},{"location":"methods/#method_expprop","page":"Propagation Methods","title":"ExpProp","text":"","category":"section"},{"location":"methods/","page":"Propagation Methods","title":"Propagation Methods","text":"The method should be loaded with","category":"page"},{"location":"methods/","page":"Propagation Methods","title":"Propagation Methods","text":"using QuantumPropagators: ExpProp","category":"page"},{"location":"methods/","page":"Propagation Methods","title":"Propagation Methods","text":"and the passed as method=ExpProp to propagate or init_prop:","category":"page"},{"location":"methods/","page":"Propagation Methods","title":"Propagation Methods","text":"init_prop(state, generator, tlist, method::Val{:ExpProp}; kwargs...)","category":"page"},{"location":"methods/#QuantumPropagators.init_prop-Tuple{Any, Any, Any, Val{:ExpProp}}","page":"Propagation Methods","title":"QuantumPropagators.init_prop","text":"using QuantumPropagators: ExpProp\n\nexp_propagator = init_prop(\n    state,\n    generator,\n    tlist;\n    method=ExpProp,\n    inplace=QuantumPropagators.Interfaces.supports_inplace(state),\n    backward=false,\n    verbose=false,\n    parameters=nothing,\n    func=(H_dt -> exp(-1im * H_dt))\n    convert_state=_exp_prop_convert_state(state),\n    convert_operator=_exp_prop_convert_operator(generator),\n    _...\n)\n\ninitializes an ExpPropagator.\n\nMethod-specific keyword arguments\n\nfunc: The function to evaluate. The argument H_dt is obtained by constructing an operator H from generator via the evaluate function and the multiplied with the time step dt for the current time interval. The propagation then simply multiplies the return value of func with the current state\nconvert_state:  Type to which to temporarily convert states before multiplying the return value of func.\nconvert_operator: Type to which to convert the operator H before multiplying it with dt and plugging the result into func\n\nThe convert_state and convert_operator parameters are useful for when the generator and or state are unusual data structures for which the relevant methods to calculate func are not defined. Often, it is easier to temporarily convert them to standard complex matrices and vectors than to implement the missing methods.\n\n\n\n\n\n","category":"method"},{"location":"methods/","page":"Propagation Methods","title":"Propagation Methods","text":"Advantages","category":"page"},{"location":"methods/","page":"Propagation Methods","title":"Propagation Methods","text":"Simple: no knobs to turn\n\"Exact\" to machine precision (within the piecewise constant approximation)\nDoes not require any special properties or knowledge of the dynamical generator\nEfficient for small systems","category":"page"},{"location":"methods/","page":"Propagation Methods","title":"Propagation Methods","text":"Disadvantages","category":"page"},{"location":"methods/","page":"Propagation Methods","title":"Propagation Methods","text":"Bad numerical scaling with the Hilbert space dimension\nMethod for exp(-1im * H * dt) must be defined (or H must be convertible to a type that can be exponentiated)","category":"page"},{"location":"methods/","page":"Propagation Methods","title":"Propagation Methods","text":"When to use","category":"page"},{"location":"methods/","page":"Propagation Methods","title":"Propagation Methods","text":"Small Hilbert space dimension (<10)\nComparing against another propagator","category":"page"},{"location":"methods/#method_cheby","page":"Propagation Methods","title":"Cheby","text":"","category":"section"},{"location":"methods/","page":"Propagation Methods","title":"Propagation Methods","text":"The method should be loaded with","category":"page"},{"location":"methods/","page":"Propagation Methods","title":"Propagation Methods","text":"using QuantumPropagators: Cheby","category":"page"},{"location":"methods/","page":"Propagation Methods","title":"Propagation Methods","text":"and then passed as method=Cheby to propagate or init_prop:","category":"page"},{"location":"methods/","page":"Propagation Methods","title":"Propagation Methods","text":"init_prop(state, generator, tlist, method::Val{:Cheby}; kwargs...)","category":"page"},{"location":"methods/#QuantumPropagators.init_prop-Tuple{Any, Any, Any, Val{:Cheby}}","page":"Propagation Methods","title":"QuantumPropagators.init_prop","text":"using QuantumPropagators: Cheby\n\ncheby_propagator = init_prop(\n    state,\n    generator,\n    tlist;\n    method=Cheby,\n    inplace=QuantumPropagators.Interfaces.supports_inplace(state),\n    backward=false,\n    verbose=false,\n    parameters=nothing,\n    control_ranges=nothing,\n    specrange_method=:auto,\n    specrange_buffer=0.01,\n    cheby_coeffs_limit=1e-12,\n    check_normalization=false,\n    specrange_kwargs...\n)\n\ninitializes a ChebyPropagator.\n\nMethod-specific keyword arguments\n\ncontrol_ranges: a dict the maps the controls in generator (see get_controls) to a tuple of min/max values. The Chebychev coefficients will be calculated based on a spectral envelope that assumes that each control can take arbitrary values within the min/max range. If not given, the ranges are determined automatically. Specifying manual control ranges can be useful when the the control amplitudes (parameters) may change during the propagation, e.g. in a sequential-update control scheme.\nspecrange_method: Method to pass to the specrange function\nspecrange_buffer: An additional factor by which to enlarge the estimated  spectral range returned by specrange, in order to ensure that Chebychev coefficients are based on an overestimation of the spectral range.\ncheby_coeffs_limit: The maximum magnitude of Chebychev coefficients that should be treated as non-zero\ncheck_normalization: Check whether the Hamiltonian has been properly normalized, i.e., that the spectral range of generator has not been underestimated. This slowes down the propagation, but is advisable for novel generators.\nuniform_dt_tolerance=1e-12: How much the intervals of tlist are allowed to vary while still being considered constant.\nspecrange_kwargs: All further keyword arguments are passed to the specrange function. Most notably, with the default specrange_method=:auto (or specrange_method=:manual), passing E_min and E_max allows to manually specify the spectral range of generator.\n\n\n\n\n\n","category":"method"},{"location":"methods/","page":"Propagation Methods","title":"Propagation Methods","text":"The time evolution operator of the piecewise-constant Schrödinger equation Ψ(t) = e^-i H dt Ψ(0) is evaluated by an expansion into Chebychev polynomials [1, 2]. This requires H to be Hermitian (have real eigenvalues) and to have a known spectral range, so that it can be normalized to the domain -1 1 on which the Chebychev polynomials are defined.","category":"page"},{"location":"methods/","page":"Propagation Methods","title":"Propagation Methods","text":"See [9, Chapter 3.2.1] for a detailed description of the method.","category":"page"},{"location":"methods/","page":"Propagation Methods","title":"Propagation Methods","text":"Advantages","category":"page"},{"location":"methods/","page":"Propagation Methods","title":"Propagation Methods","text":"Very efficient for high precision and moderately large time steps","category":"page"},{"location":"methods/","page":"Propagation Methods","title":"Propagation Methods","text":"Disadvantages","category":"page"},{"location":"methods/","page":"Propagation Methods","title":"Propagation Methods","text":"Only valid for Hermitian operators\nMust be able to estimate the spectral envelope","category":"page"},{"location":"methods/","page":"Propagation Methods","title":"Propagation Methods","text":"When to use","category":"page"},{"location":"methods/","page":"Propagation Methods","title":"Propagation Methods","text":"Closed quantum systems with piecewise constant dynamics","category":"page"},{"location":"methods/#method_newton","page":"Propagation Methods","title":"Newton","text":"","category":"section"},{"location":"methods/","page":"Propagation Methods","title":"Propagation Methods","text":"The method should be loaded with","category":"page"},{"location":"methods/","page":"Propagation Methods","title":"Propagation Methods","text":"using QuantumPropagators: Newton","category":"page"},{"location":"methods/","page":"Propagation Methods","title":"Propagation Methods","text":"and then passed as method=Newton to propagate or init_prop:","category":"page"},{"location":"methods/","page":"Propagation Methods","title":"Propagation Methods","text":"init_prop(state, generator, tlist, method::Val{:Newton}; kwargs...)","category":"page"},{"location":"methods/#QuantumPropagators.init_prop-Tuple{Any, Any, Any, Val{:Newton}}","page":"Propagation Methods","title":"QuantumPropagators.init_prop","text":"using QuantumPropagators: Newton\n\nnewton_propagator = init_prop(\n    state,\n    generator,\n    tlist;\n    method=Newton,\n    inplace=QuantumPropagators.Interfaces.supports_inplace(state),\n    backward=false,\n    verbose=false,\n    parameters=nothing,\n    m_max=10,\n    func=(z -> exp(-1im * z)),\n    norm_min=1e-14,\n    relerr=1e-12,\n    max_restarts=50,\n    _...\n)\n\ninitializes a NewtonPropagator.\n\nMethod-specific keyword arguments\n\nm_max: maximum Krylov dimension, cf. NewtonWrk\nfunc, norm_min, relerr, max_restarts: parameter to pass to newton!\n\n\n\n\n\n","category":"method"},{"location":"methods/","page":"Propagation Methods","title":"Propagation Methods","text":"The time evolution operator of the piecewise-constant Schrödinger equation Ψ(t) = e^-i H dt Ψ(0) is evaluated by an expansion into Newton polynomials [3, 5, 10]. Unlike for Chebychev polynomials, this expansion does not require H to be Hermitian or to have a known spectral radius. This makes the Newton propagation applicable to open quantum systems, where H is replaced by a Liouvillian to calculate the time evolution of the density matrix.","category":"page"},{"location":"methods/","page":"Propagation Methods","title":"Propagation Methods","text":"See [9, Chapter 3.2.2] for a detailed description of the method.","category":"page"},{"location":"methods/","page":"Propagation Methods","title":"Propagation Methods","text":"Advantages","category":"page"},{"location":"methods/","page":"Propagation Methods","title":"Propagation Methods","text":"Reasonably efficient for high precision and moderately large time steps\nSpectral radius does not need to be known","category":"page"},{"location":"methods/","page":"Propagation Methods","title":"Propagation Methods","text":"Disadvantages","category":"page"},{"location":"methods/","page":"Propagation Methods","title":"Propagation Methods","text":"Need to choose m_max and max_restarts well for good performance.","category":"page"},{"location":"methods/","page":"Propagation Methods","title":"Propagation Methods","text":"When to use","category":"page"},{"location":"methods/","page":"Propagation Methods","title":"Propagation Methods","text":"Open quantum systems with piecewise constant dynamics","category":"page"},{"location":"methods/#method_ode","page":"Propagation Methods","title":"OrdinaryDiffEq","text":"","category":"section"},{"location":"methods/","page":"Propagation Methods","title":"Propagation Methods","text":"The method requires that the OrdinaryDiffEq package is loaded","category":"page"},{"location":"methods/","page":"Propagation Methods","title":"Propagation Methods","text":"using OrdinaryDiffEq","category":"page"},{"location":"methods/","page":"Propagation Methods","title":"Propagation Methods","text":"Equivalently, the more general DifferentialEquations.jl package can be used.","category":"page"},{"location":"methods/","page":"Propagation Methods","title":"Propagation Methods","text":"using DifferentialEquations","category":"page"},{"location":"methods/","page":"Propagation Methods","title":"Propagation Methods","text":"There is no difference between these two options: OrdinaryDiffEq is just a smaller dependency, but DifferentialEquations may be preferred if the large DifferentialEquations framework is required for the project.","category":"page"},{"location":"methods/","page":"Propagation Methods","title":"Propagation Methods","text":"In any case, the loaded package to propagate or init_prop via the method keyword argument:","category":"page"},{"location":"methods/","page":"Propagation Methods","title":"Propagation Methods","text":"init_prop(state, generator, tlist, method::Val{:OrdinaryDiffEq}; kwargs...)","category":"page"},{"location":"methods/#QuantumPropagators.init_prop-Tuple{Any, Any, Any, Val{:OrdinaryDiffEq}}","page":"Propagation Methods","title":"QuantumPropagators.init_prop","text":"using OrdinaryDiffEq  # or: `using DifferentialEquations`\n\node_propagator = init_prop(\n    state,\n    generator,\n    tlist;\n    method=OrdinaryDiffEq,  # or: `method=DifferentialEquations`\n    inplace=QuantumPropagators.Interfaces.supports_inplace(state),\n    backward=false,\n    verbose=false,\n    parameters=nothing,\n    piecewise=false,\n    pwc=false,\n    alg=OrdinaryDiffEq.Tsit5(),\n    solver_options...\n)\n\ninitializes a propagator that uses an ODE solver from the OrdinaryDiffEq.jl package as a backend.\n\nBy default, the resulting propagator is for time-continuous controls that can be evaluated with evaluate(control, t) for any t in the range of tlist[begin] to tlist[end]. The controls may be parametrized, see get_parameters. Any parameters will be available in the parameters attribute of the resulting ode_propagator, as a dictionary mapping controls to a vector of parameter values. Mutating ode_propagator.parameters[control] will be reflected in any subsequent call to prop_step!.\n\nIf pwc=true (or, equivalently piecewise=true), all controls will be discretized with discretize_on_midpoints and the propagation will be for piecewise constant dynamics. The resulting ode_propagator will be an instance of PWCPropagator, with the corresponding semantics. In particular, the ode_propatator.parameters will be a mapping of controls to discretized pulse values, not the analytical parameters obtained with get_parameters(control) as in the default case.\n\nInternally, the generator will be wrapped with QuantumPropagators.ode_function. The resulting function f will be called internally as f(ϕ, Ψ, vals_dict, t) or f(Ψ, vals_dict, t) depending on the inplace keyword argument.\n\nMethod-specific keyword arguments\n\npwc: Whether to propagate for piecewise-constant controls or, with the default pwc=false, for time-continuous controls.\npiecewise: Currently equivalent to pwc, but future version may change  this to allow for other piecewise (e.g., piecewise-linear) controls.\nparameters: If given, a mapping of controls to parameter values (pwc=false) or pulse values on the intervals of the time grid (pwc=true). By default, the parameters are determined automatically using get_parameters, respectively discretize_on_midpoints if pwc=true. If they are given manually, they must follow the exact same semantics. In particular, for pwc=false, any parameters must alias the parameters in the controls, such that mutating parameters is automatically reflected in evaluate. The parameters will be available as an attribute of the ode_propagator.\nalg: The algorithm to use for the ODE Solver, see the list of solvers in the DifferentialEquations manual. The default Tsit5() method is the recommended choice for non-stiff problems.\nsolver_options: All other keyword arguments are passed to the ODE solver, see the list of Solve Keyword Arguments in the DifferentialEquations manual. Note that the options for \"Default Algorithm Hinting\" do not apply, since alg must be specified manually. Also, the \"Output Control\" is managed by the ode_propagator, so these options should not be used.\n\n\n\n\n\n","category":"method"},{"location":"methods/","page":"Propagation Methods","title":"Propagation Methods","text":"Advantages","category":"page"},{"location":"methods/","page":"Propagation Methods","title":"Propagation Methods","text":"Suitable for time-continuous dynamics\nThe full power of the DifferentialEquations.jl ecosystem\nEfficient for moderate precisions","category":"page"},{"location":"methods/","page":"Propagation Methods","title":"Propagation Methods","text":"Disadvantages","category":"page"},{"location":"methods/","page":"Propagation Methods","title":"Propagation Methods","text":"Less efficient for piecewise-constant dynamics, and thus less suitable of PWC control methods","category":"page"},{"location":"methods/","page":"Propagation Methods","title":"Propagation Methods","text":"When to use","category":"page"},{"location":"methods/","page":"Propagation Methods","title":"Propagation Methods","text":"Time-continuous dynamics","category":"page"},{"location":"overview/#Overview","page":"Overview","title":"Overview","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"gdefop1hat1\ngdefLiouvillianmathcalL\ngdefReoperatornameRe\ngdefImoperatornameIm","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"The QuantumPropagators packages provides solvers for the dynamic equations of quantum mechanics, most importantly the Schrödinger and Liouville equations. We refer to the numerical evaluation of a quantum state Ψ(t + dt)  from a state Ψ(t) under a given equation of motion as \"time propagation\".","category":"page"},{"location":"overview/#getting_started","page":"Overview","title":"Getting started","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"As a simple \"Hello World\" example, we use the propagate function to simulate a π/2 Rabi flip in a two level system:","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"In a two-level system with ground state 0 and excited state 1, a constant driving field between the two levels with a pulse area of π/2 results in a population inversion, transforming the initial state 0 into -i 1,","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"using QuantumPropagators: propagate, ExpProp\n\nΨ₀ = ComplexF64[1, 0]  #  = |0⟩\nH = ComplexF64[0 1; 1 0]\ntlist = collect(range(0, π/2, length=101))\n\nΨ = propagate(Ψ₀, H, tlist; method=ExpProp)\n\nprint(\"Ψ = $(round.(Ψ; digits=3))\\n\")\n\n# output\n\nΨ = ComplexF64[0.0 + 0.0im, 0.0 - 1.0im]","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"We've used a simple exponential propagator (ExpProp) here, which directly calculates U = exp(-1im * H * dt) in every time step and applies it to the current state Ψ.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"Instead of just returning the final state, we can use storage=true to return an array with all the states at every point in the time grid (tlist). This allows us to plot the Rabi oscillation over time:","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"using Plots\ngr() # hide\nusing QuantumPropagators: propagate, ExpProp # hide\nΨ₀ = ComplexF64[1, 0] # hide\nH = ComplexF64[0 1; 1 0] # hide\ntlist = collect(range(0, π/2, length=101)) # hide\nstates = propagate(Ψ₀, H, tlist; method=ExpProp, storage=true)\nplot(tlist./π, abs.(states').^2; label=[\"ground\" \"excited\"],\n     xlabel=\"pulse area / π\", ylabel=\"population\", legend=:right)","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"The storage parameter provides a powerful way to obtain arbitrary dynamic quantities from the propagation:","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"If given as true, return a storage array with the propagated states at each point in time instead of just the final state.\nIf given a pre-allocated storage array, fill it with the propagated states at each point in time, and return the final state.\nIf given in combination with observables, put arbitrary \"observable\" data derived from the propagated states in the storage array.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"See the discussion of Expectation Values for details.","category":"page"},{"location":"overview/#overview_approaches","page":"Overview","title":"Approaches to time propagation","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"We are primarily interested in the time propagation of a quantum state under the Schrödinger equation (ħ = 1)","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"i fracpartialpartial t Psi(t) = opH(t) Psi(t)","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"which describes the dynamics of a closed quantum system. For open quantum systems, the equivalent equation is the Liouville equation, which we write as","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"i fracpartialpartial t hatrho(t) = Liouvillian(t) hatrho(t)","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"This form differs from most textbooks by a factor of i, but has the benefit that it is structurally identical to the Schrödinger equation, so that the propagation methods do not actually need to know whether they are propagating a Hilbert space vector or a (vectorized) density matrix. See liouvillian with convention=:LvN for how to construct an appropriate Liouvillian.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"There are two fundamental approaches to solving the Schrödinger equation (or any equation of motion):","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"We can analytically solve the Schrödinger equation and then numerically evaluate the solution. Mathematically, this is the application of the time evolution operator opH as Ψ(t+dt) = opU(t) Ψ(t). For a piecewise-constant opH(t)where there is a time-independent opH in the interval t t+dt, the time evolution operator is well-known to be\nopU = exp-i opH dt\nThe propagated state opU Ψ(t) would then be obtained, e.g., by expanding the exponentiation of the operator opH into a polynomial series. This can be done to arbitrary precision by truncating the series at an appropriate point.\nWe can use a general ODE solver, e.g., using some kind of Runge-Kutta scheme. These work by following the derivative between t and t+dt with some adaptive internal step size to achieve a given precision.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"The first case of a piecewise-constant time evolution operator is particularly relevant to quantum control, since the two most venerable methods of quantum control (GRAPE and Krotov's method) are inherently piecewise-constant. Hence, the QuantumPropagators package implements two efficient polynomial propagators that have a long history in quantum control, using Chebychev polynomials for closed quantum systems [1, 2] and Newton polynomials for open quantum systems [3–5].","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"For propagation via an ODE Solver, QuantumPropagators delegates to the DifferentialEquations.jl, respectively the OrdinaryDiffEq.jl package.","category":"page"},{"location":"overview/#overview_propagation","page":"Overview","title":"Propagation methods","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"The propagate function has a mandatory method keyword argument. It should be passed a module that implements the method. For the built-in methods, this would be one of the following submodule of QuantumPropagators:","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"using QuantumPropagators: ExpProp, Cheby, Newton","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"The equation of motion is implicit in the propagation method. The above methods target the Schrödinger or Liouville equations for a piecewise-constant Hamiltonian that is evaluated on the midpoints of the propagation time grid.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"The two core method are:","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"method=Cheby: Evaluate the application of the unitary time-evolution operator via an expansion into Chebychev polynomials.\nmethod=Newton: Evaluate the application of the non-unitary time-evolution operator via an expansion into Newton polynomials, for a Liouvillian or a non-Hermitian Hamiltonian.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"Furthermore, as a fallback for very small system or for debugging,","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"method=ExpProp: Explicitly construct the time evolution operator by matrix exponentiation and apply it to the state.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"If the OrdinaryDiffEq.jl or (equivalently) th DifferentialEquations.jl package is loaded, QuantumPropagators can delegate to it:","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"using OrdinaryDiffEq","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"allows to pass","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"method=OrdinaryDiffEq: Use OrdinaryDiffEq.jl as a backend with any of the algorithms available for ODEs in DifferentialEquations.jl, alg=Tsit5() by default.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"Unlike any of the built-in methods, OrdinaryDiffEq is able to propagate for time-continuous generators. This is the default for that propagator (pwc=false). By setting pwc=true or piecewise=true) the ODE solvers can also be used for piecewise-constant Hamiltonians or Liouvillians, providing an alternative to the built-in method=Cheby and method=Newton.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"See the more extended discussion of Propagation Methods for more details.","category":"page"},{"location":"overview/#overview_dynamical_generators","page":"Overview","title":"Dynamical generators","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"In the initial example, the \"generator\" H that is the second argument to propagate was a simple static operator. In general, we will want time-dependent Hamiltonians or Liouvillians. The standard way to initialize a time-dependent Hamiltonian is via the hamiltonian function, e.g., as  hamiltonian(Ĥ₀, (Ĥ₁, ϵ₁), (Ĥ₂, ϵ₂)). The Ĥ₀, Ĥ₁, and Ĥ₂ are static operators, and ϵ₁ and ϵ₂ are control fields, typically functions (or function-like objects) of time t. For piecewise-constant propagators, ϵ₁ and ϵ₂ may also be an array of amplitude values appropriate to the time grid tlist. The tuple-syntax for the time-dependent terms is inspired by QuTiP.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"Generally, the generator, or the operators/controls inside the tuples can be a arbitrary objects, as long as some relevant methods are implemented for these objects, see the full section on Dynamical Generators.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"Open quantum systems are handled identically to closed quantum system, except that Hamiltonian operator are replaced by Liouvillian super-operators. For any system of non-trivial Hilbert space dimension, all (super-)operators should be sparse matrices.","category":"page"},{"location":"overview/#The-Propagator-interface","page":"Overview","title":"The Propagator interface","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"As a lower-level interface than propagate, the QuantumPropagators package defines an interface for \"propagator\" objects. These are initialized via init_prop as, e.g.,","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"using QuantumPropagators: init_prop\n\npropagator = init_prop(Ψ₀, H, tlist; method)","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"with a mandatory method keyword argument.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"The propagator is a propagation-method-dependent object with the interface described by AbstractPropagator and QuantumPropagators.Interfaces.check_propagator.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"The  prop_step! function can then be used to advance the propagator:","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"DocTestSetup = quote\n    using QuantumPropagators: init_prop, ExpProp\n    propagator = init_prop(Ψ₀, H, tlist; method=ExpProp)\nend","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"using QuantumPropagators: prop_step!\n\nΨ = prop_step!(propagator)  # single step\n\nwhile !isnothing(prop_step!(propagator)); end  # go to end\nΨ = propagator.state\n\nprint(\"Ψ = $(round.(Ψ; digits=3)))\\n\")\nprint(\"t = $(round(propagator.t / π; digits=3))π\\n\")\n\n# output\n\nΨ = ComplexF64[0.0 + 0.0im, 0.0 - 1.0im])\nt = 0.5π","category":"page"},{"location":"overview/#In-place-propagation","page":"Overview","title":"In-place propagation","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"Most propagators support both an in-place and a not-in-place mode. These modes can be switched via the inplace parameter to propagate/init_prop, which defaults to the value of QuantumPropagators.Interfaces.supports_inplace for the given initial state. When using in-place operations, propagators should minimize the allocation of memory and modify states using in-place linear algebra operations (BLAS). Otherwise, with inplace=false, mutating states or operators is avoided. See the in-place and not-in-place operations described in QuantumPropagators.Interfaces.check_state and QuantumPropagators.Interfaces.check_operator.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"In-place operations can be dramatically more efficient for large Hilbert space dimensions. On the other hand, not-in-place operations can be more efficient for small Hilbert spaces, in particular when a static vector can be used to represent the state. Moreover, frameworks for automatic differentiation such as Zygote do not support in-place operations.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"When using custom structs for states, operators, or generators, the struct itself not not need to be mutable (according to Base.ismutable) in order to support inplace=true. It only must support the in-place operations defined in the formal interface and indicate that support by defining QuantumPropagators.Interfaces.supports_inplace. Typically, in-place operations on immutable custom structs involve mutating the mutable properties of that struct.","category":"page"},{"location":"overview/#Backward-propagation","page":"Overview","title":"Backward propagation","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"When propagate or init_prop are called with backward=true, the propagation is initialized to run backward. The initial state is then defined at propagator.t == tlist[end] and each prop_step! moves to the previous point in tlist. The equation of motion is the Schrödinger or Liouville equation with a negative dt. For a Hermitian generator, doing a forward propagation followed by a backward propagation will recover the initial state. For a non-Hermitian generator, this no longer holds. Note that in optimal control methods such as GRAPE or Krotov's method, obtaining gradients involves a \"backward propagation with the adjoint generator\" (when the generator is non-Hermitian and adjoint/non-adjoint makes a difference). The propagate routine with backward=true will not automatically take this adjoint of the generator; instead, the adjoint generator must be passed explicitly.","category":"page"},{"location":"overview/#Parameterized-controls","page":"Overview","title":"Parameterized controls","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"Controls may depend on a list of tunable parameters. Such controls must be especially defined and should be subtypes of QuantumPropagators.Controls.ParameterizedFunction, or more generally \"functors\" of a single float t for which QuantumPropagators.Controls.get_parameters is implemented.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"Independently, all propagators have a field parameters that is a dict of controls to propagation parameters for that control. For continuous-time propagators, such as a propagator initialized with method=OrdinaryDiffEq and pwc=false, these propagation parameters are exactly the analytic parameters of the control as obtained by QuantumPropagators.Controls.get_parameters.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"For piecewise-constant propagators (all the default built-in propagators), the propagation parameters are always the values of the control evaluated on the mid points of the time grid, see QuantumPropagators.Controls.discretize_on_midpoints. Specifically, the analytic parameters from get_parameters(control) are not used as propagation parameters for piecewise propagators.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"In any case, mutating propagator.parameters affects the propagation in subsequent calls to prop_step!.","category":"page"},{"location":"overview/#Connection-to-DifferentialEquations.jl","page":"Overview","title":"Connection to DifferentialEquations.jl","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"The QuantumPropagators API is structured similarly to the DifferentialEquations.jl","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"The propagate function is similar to DifferentialEquations.solve\nThe init_prop function is similar to DifferentialEquations.init\nThe reinit_prop! function is similar to DifferentialEquations.reinit!\nThe Propagator interface is similar to DifferentialEquations' Integrator Interface\nprop_step! corresponds to DifferentialEquations.step!\nset_state! corresponds to DifferentialEquations.set_u!\nset_t! corresponds to DifferentialEquations.set_t!","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"Note that the equation of motion for QuantumPropagators is implicit in the propagation method (usually the Schrödinger/Liouville equation), so the initialization of a Propagator via the initial state and the \"generator\" is more specialized than DifferentialEquations' Problem Interface.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"The propagator returned by using DifferentialEquations; init_prop(Ψ₀, H, tlist; method=DifferentialEquations) is a thin wrapper around DifferentialEquations' integrator. That propagator uses an un-exported function QuantumPropagators.ode_function to wrap around the evaluation of a time-dependent generator. The ode_function wrapper could also be used directly to enable working with the data structures defined in QuantumPropagators in the context of the DifferentialEquations package.","category":"page"},{"location":"#QuantumPropagators","page":"Home","title":"QuantumPropagators","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using Markdown\nusing Pkg\n\nVERSION = Pkg.dependencies()[Base.UUID(\"7bf12567-5742-4b91-a078-644e72a65fc1\")].version\n\ngithub_badge = \"[![Github](https://img.shields.io/badge/JuliaQuantumControl-QuantumPropagators.jl-blue.svg?logo=github)](https://github.com/JuliaQuantumControl/QuantumPropagators.jl)\"\n\nversion_badge = \"![v$VERSION](https://img.shields.io/badge/version-v$VERSION-green.svg)\"\n\nMarkdown.parse(\"$github_badge $version_badge\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"The QuantumPropagators package implements methods for simulating the time dynamics of a quantum system. It is the numerical backend for all packages implementing methods of optimal control within the JuliaQuantumControl organization.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The purpose is this package is to:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Implement the piecewise-constant propagation methods that have been traditionally used in quantum control, based on an expansion of the time evolution operator into Chebychev polynomials (closed systems) or Newton polynomials (open systems),\nDelegate to third-party packages that implement state-of-the-art methods for time-continuous dynamics (DifferentialEquations.jl).\nDefine data structures for \"dynamical generators\" (time-dependent Hamiltonians or Liouvillians) that are relevant to quantum control. Specifically, this includes a well-defined notion of \"control functions\" and \"control parameters\" inside the Hamiltonian.\nDefine a  general interface for a time propagators that is suitable for all aspects of quantum control. This includes the ability to efficiently tune control parameters or control functions while the propagation is running (for \"sequential updates\"), and the ability to propagate both forwards and backwards in time.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The focus on quantum control separates this package from other solutions for just simulating the time dynamics of a quantum system, e.g. within QuantumOptics.jl or directly with DifferentialEquations.jl. Also, while QuantumPropagators defines a general interface for dynamic generators, it is otherwise agnostic about the data structures to represent Hamiltonians or quantum states. This allows for the use of modeling frameworks like QuantumOptics.jl or of custom problem-specific data structures.","category":"page"},{"location":"#Contents","page":"Home","title":"Contents","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages=[\n \"overview.md\",\n \"generators.md\",\n \"methods.md\",\n \"storage.md\",\n \"howto.md\",\n \"benchmarks.md\",\n \"api/quantumpropagators.md\",\n]\nDepth = 2","category":"page"},{"location":"#History","page":"Home","title":"History","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"See the Releases on Github.","category":"page"}]
}
